[
  {
    "chapter": "01_introduction",
    "content_file": "/home/jack/workspace/zig_guide/sections/01_introduction/content.md",
    "total_blocks": 5,
    "runnable_blocks": 4,
    "snippet_blocks": 1,
    "runnable": [
      {
        "index": 2,
        "start_line": 87,
        "end_line": 93,
        "code": "const std = @import(\"std\");\n\npub fn main() void {\n    std.debug.print(\"Hello, {s}!\\n\", .{\"World\"});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/01_introduction/content.md",
        "lines": 5,
        "chars": 101
      },
      {
        "index": 3,
        "start_line": 110,
        "end_line": 122,
        "code": "const std = @import(\"std\");\n\nfn fibonacci(n: u16) u16 {\n    if (n == 0 or n == 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\ntest \"comptime execution\" {\n    const x = comptime fibonacci(10);\n    try std.testing.expect(x == 55);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/01_introduction/content.md",
        "lines": 11,
        "chars": 247
      },
      {
        "index": 4,
        "start_line": 137,
        "end_line": 144,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello from 0.14!\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/01_introduction/content.md",
        "lines": 6,
        "chars": 149
      },
      {
        "index": 5,
        "start_line": 147,
        "end_line": 155,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    try stdout.print(\"Hello from 0.15!\\n\", .{});\n    try stdout.context.flush();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/01_introduction/content.md",
        "lines": 7,
        "chars": 181
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 35,
        "end_line": 43,
        "code": "// \ud83d\udd50 0.14.x\nvar list = std.ArrayList(u8).init(allocator);\ndefer list.deinit();\n\n// \u2705 0.15+\nvar list: std.ArrayList(u8) = .empty;\ndefer list.deinit(allocator);",
        "file": "/home/jack/workspace/zig_guide/sections/01_introduction/content.md",
        "lines": 7,
        "chars": 158
      }
    ]
  },
  {
    "chapter": "02_language_idioms",
    "content_file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
    "total_blocks": 34,
    "runnable_blocks": 4,
    "snippet_blocks": 30,
    "runnable": [
      {
        "index": 14,
        "start_line": 194,
        "end_line": 205,
        "code": "const std = @import(\"std\");\n\nfn maximum(comptime T: type, a: T, b: T) T {\n    return if (a > b) a else b;\n}\n\ntest \"generic maximum\" {\n    try std.testing.expect(maximum(i32, 10, 20) == 20);\n    try std.testing.expect(maximum(f64, 3.14, 2.71) == 3.14);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 10,
        "chars": 253
      },
      {
        "index": 22,
        "start_line": 366,
        "end_line": 405,
        "code": "const std = @import(\"std\");\n\nfn Stack(comptime T: type) type {\n    return struct {\n        items: std.ArrayList(T),\n\n        const Self = @This();\n\n        pub fn init(allocator: std.mem.Allocator) Self {\n            return .{ .items = std.ArrayList(T).init(allocator) };\n        }\n\n        pub fn deinit(self: *Self) void {\n            self.items.deinit();\n        }\n\n        pub fn push(self: *Self, item: T) !void {\n            try self.items.append(item);\n        }\n\n        pub fn pop(self: *Self) ?T {\n            return self.items.popOrNull();\n        }\n    };\n}\n\ntest \"generic stack\" {\n    const allocator = std.testing.allocator;\n    var stack = Stack(i32).init(allocator);\n    defer stack.deinit();\n\n    try stack.push(10);\n    try stack.push(20);\n\n    try std.testing.expect(stack.pop().? == 20);\n    try std.testing.expect(stack.pop().? == 10);\n    try std.testing.expect(stack.pop() == null);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 38,
        "chars": 907
      },
      {
        "index": 23,
        "start_line": 409,
        "end_line": 440,
        "code": "// shapes.zig\npub const Point = struct {\n    x: i32,\n    y: i32,\n\n    pub fn add(self: Point, other: Point) Point {\n        return .{ .x = self.x + other.x, .y = self.y + other.y };\n    }\n};\n\npub const Rectangle = struct {\n    top_left: Point,\n    width: u32,\n    height: u32,\n};\n\npub fn distance(a: Point, b: Point) f64 {\n    const dx = @as(f64, @floatFromInt(a.x - b.x));\n    const dy = @as(f64, @floatFromInt(a.y - b.y));\n    return @sqrt(dx * dx + dy * dy);\n}\n\n// main.zig\nconst shapes = @import(\"shapes.zig\");\n\npub fn main() void {\n    const p1 = shapes.Point{ .x = 0, .y = 0 };\n    const p2 = shapes.Point{ .x = 3, .y = 4 };\n    const dist = shapes.distance(p1, p2);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 30,
        "chars": 674
      },
      {
        "index": 33,
        "start_line": 557,
        "end_line": 566,
        "code": "// src/main.zig\npub fn main() !void {\n    if (builtin.os.tag == .macos) {\n        return @import(\"apprt\").run();  // Swift/AppKit integration\n    } else {\n        return @import(\"cli\").run();     // Standard CLI\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 8,
        "chars": 219
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 28,
        "end_line": 31,
        "code": "const Point = struct { x: i32, y: i32 };\nconst Color = enum { red, green, blue };",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 2,
        "chars": 81
      },
      {
        "index": 2,
        "start_line": 34,
        "end_line": 38,
        "code": "fn calculateSum(a: i32, b: i32) i32 {\n    return a + b;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 3,
        "chars": 57
      },
      {
        "index": 3,
        "start_line": 41,
        "end_line": 45,
        "code": "fn ArrayList(comptime T: type) type {\n    return struct { /* ... */ };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 3,
        "chars": 72
      },
      {
        "index": 4,
        "start_line": 48,
        "end_line": 55,
        "code": "const max_connections = 100;\nvar file_path: []const u8 = \"/tmp/data.bin\";\n\nconst math = struct {\n    pub fn add(a: i32, b: i32) i32 { return a + b; }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 6,
        "chars": 152
      },
      {
        "index": 5,
        "start_line": 64,
        "end_line": 68,
        "code": "const latency_ms_max: u64 = 1000;  // Not max_latency_ms\nconst buffer_size_bytes: usize = 4096;\nconst timeout_ns_min: u64 = 100_000;",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 3,
        "chars": 132
      },
      {
        "index": 6,
        "start_line": 71,
        "end_line": 73,
        "code": "const VSRState = enum { normal, view_change, recovering };  // Not VsrState",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 1,
        "chars": 75
      },
      {
        "index": 7,
        "start_line": 76,
        "end_line": 80,
        "code": "fn process(gpa: Allocator, arena: Allocator) !void {\n    // Name signals: gpa requires explicit deinit, arena gets bulk-freed\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 3,
        "chars": 127
      },
      {
        "index": 8,
        "start_line": 90,
        "end_line": 104,
        "code": "const std = @import(\"std\");\n\nfn demonstrateDeferOrder() void {\n    defer std.debug.print(\"3. Third (executed first)\\n\", .{});\n    defer std.debug.print(\"2. Second\\n\", .{});\n    defer std.debug.print(\"1. First (executed last)\\n\", .{});\n    std.debug.print(\"0. Function body\\n\", .{});\n}\n// Output:\n// 0. Function body\n// 1. First (executed last)\n// 2. Second\n// 3. Third (executed first)",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 13,
        "chars": 385
      },
      {
        "index": 9,
        "start_line": 108,
        "end_line": 120,
        "code": "const std = @import(\"std\");\n\nfn processFile(allocator: std.mem.Allocator, path: []const u8) !void {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    const content = try file.readToEndAlloc(allocator, 1024 * 1024);\n    defer allocator.free(content);\n\n    // Process content here\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 11,
        "chars": 314
      },
      {
        "index": 10,
        "start_line": 124,
        "end_line": 136,
        "code": "const std = @import(\"std\");\n\nfn createResources(allocator: std.mem.Allocator) !struct { a: []u8, b: []u8 } {\n    const a = try allocator.alloc(u8, 100);\n    errdefer allocator.free(a);  // Only frees if subsequent operations fail\n\n    const b = try allocator.alloc(u8, 200);\n    errdefer allocator.free(b);\n\n    return .{ .a = a, .b = b };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 11,
        "chars": 341
      },
      {
        "index": 11,
        "start_line": 147,
        "end_line": 152,
        "code": "fn parseNumber(text: []const u8) !u32 {\n    if (text.len == 0) return error.Empty;\n    // Parse logic\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 4,
        "chars": 103
      },
      {
        "index": 12,
        "start_line": 155,
        "end_line": 162,
        "code": "fn findFirst(items: []i32, target: i32) ?usize {\n    for (items, 0..) |item, index| {\n        if (item == target) return index;\n    }\n    return null;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 6,
        "chars": 152
      },
      {
        "index": 13,
        "start_line": 170,
        "end_line": 184,
        "code": "// Error union with try (propagates error)\nconst value = try parseNumber(\"42\");\n\n// Error union with catch (handles error)\nconst value = parseNumber(\"42\") catch 0;\n\n// Optional with orelse (provides default)\nconst index = findFirst(items, 10) orelse return;\n\n// Optional with if (conditional execution)\nif (findFirst(items, 10)) |index| {\n    // Use index\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 13,
        "chars": 357
      },
      {
        "index": 15,
        "start_line": 211,
        "end_line": 223,
        "code": "fn Buffer(comptime size: usize) type {\n    if (size == 0) {\n        @compileError(\"Buffer size must be greater than zero\");\n    }\n    return struct {\n        data: [size]u8,\n    };\n}\n\nconst ValidBuffer = Buffer(128);   // \u2705 Compiles\n// const Invalid = Buffer(0);       // \u274c Compile error",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 11,
        "chars": 287
      },
      {
        "index": 16,
        "start_line": 227,
        "end_line": 242,
        "code": "const std = @import(\"std\");\n\nfn fieldCount(comptime T: type) comptime_int {\n    const info = @typeInfo(T);\n    return switch (info) {\n        .Struct => |s| s.fields.len,\n        else => 0,\n    };\n}\n\nconst Point = struct { x: i32, y: i32 };\ncomptime {\n    std.debug.assert(fieldCount(Point) == 2);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 14,
        "chars": 299
      },
      {
        "index": 17,
        "start_line": 251,
        "end_line": 254,
        "code": "const std = @import(\"std\");           // Standard library\nconst utils = @import(\"utils.zig\");   // Local module",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 2,
        "chars": 111
      },
      {
        "index": 18,
        "start_line": 258,
        "end_line": 267,
        "code": "// math.zig\npub fn add(a: i32, b: i32) i32 {  // Exported\n    return addImpl(a, b);\n}\n\nfn addImpl(a: i32, b: i32) i32 {  // Private to this module\n    return a + b;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 8,
        "chars": 166
      },
      {
        "index": 19,
        "start_line": 302,
        "end_line": 309,
        "code": "pub const Lexer = @import(\"lexer.zig\").Lexer;\npub const AST = @import(\"ast.zig\").AST;\n\npub fn parse(source: []const u8) !AST {\n    // Implementation\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 6,
        "chars": 150
      },
      {
        "index": 20,
        "start_line": 319,
        "end_line": 342,
        "code": "const std = @import(\"std\");\n\nfn copyFile(\n    allocator: std.mem.Allocator,\n    src_path: []const u8,\n    dst_path: []const u8\n) !void {\n    const src = try std.fs.cwd().openFile(src_path, .{});\n    defer src.close();\n\n    const dst = try std.fs.cwd().createFile(dst_path, .{});\n    defer dst.close();\n\n    const buffer = try allocator.alloc(u8, 4096);\n    defer allocator.free(buffer);\n\n    while (true) {\n        const bytes_read = try src.read(buffer);\n        if (bytes_read == 0) break;\n        try dst.writeAll(buffer[0..bytes_read]);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 22,
        "chars": 548
      },
      {
        "index": 21,
        "start_line": 348,
        "end_line": 360,
        "code": "const std = @import(\"std\");\n\nfn findUser(db: *Database, id: u32) !?User {\n    const conn = try db.connect();  // Can fail\n    defer conn.close();\n\n    return conn.query(\"SELECT * FROM users WHERE id = ?\", .{id}) catch |err| {\n        if (err == error.NotFound) return null;  // Absence is valid\n        return err;  // Other errors propagate\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 11,
        "chars": 350
      },
      {
        "index": 24,
        "start_line": 450,
        "end_line": 457,
        "code": "// \u274c WRONG: Leaks file handles until function returns\nfor (file_paths) |path| {\n    const file = try openFile(path);\n    defer file.close();  // Defers until function ends, not loop end\n    processFile(file);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 6,
        "chars": 210
      },
      {
        "index": 25,
        "start_line": 461,
        "end_line": 470,
        "code": "// \u2705 CORRECT: Closes each file immediately\nfor (file_paths) |path| {\n    {\n        const file = try openFile(path);\n        defer file.close();  // Executes at block end\n        processFile(file);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 8,
        "chars": 204
      },
      {
        "index": 26,
        "start_line": 476,
        "end_line": 482,
        "code": "// \u274c WRONG: Cannot distinguish between \"not found\" and \"permission denied\"\nfn readConfig(path: []const u8) ?Config {\n    const file = std.fs.cwd().openFile(path, .{}) catch return null;\n    // Caller cannot tell why this failed\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 5,
        "chars": 229
      },
      {
        "index": 27,
        "start_line": 486,
        "end_line": 493,
        "code": "// \u2705 CORRECT: Preserves error information\nfn readConfig(path: []const u8) !Config {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n    // Parse and return config\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 6,
        "chars": 195
      },
      {
        "index": 28,
        "start_line": 499,
        "end_line": 504,
        "code": "// \u274c WRONG: T is not known at comptime in this context\nfn createArray(T: type, size: usize) ![]T {\n    return try allocator.alloc(T, size);  // T is runtime, won't compile\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 4,
        "chars": 173
      },
      {
        "index": 29,
        "start_line": 508,
        "end_line": 513,
        "code": "// \u2705 CORRECT: Explicit comptime parameter\nfn createArray(comptime T: type, allocator: std.mem.Allocator, size: usize) ![]T {\n    return try allocator.alloc(T, size);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 4,
        "chars": 167
      },
      {
        "index": 30,
        "start_line": 518,
        "end_line": 521,
        "code": "const utils = @import(\"utils.zig\");\npub usingnamespace utils;  // Implicitly re-exports everything",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 2,
        "chars": 98
      },
      {
        "index": 31,
        "start_line": 524,
        "end_line": 527,
        "code": "const utils = @import(\"utils.zig\");\npub const helper = utils.helper;  // Explicit control over API surface",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 2,
        "chars": 106
      },
      {
        "index": 32,
        "start_line": 539,
        "end_line": 549,
        "code": "// src/vsr.zig\nfn prepare(self: *Self, op: Operation) !void {\n    assert(self.status == .normal);  // Precondition\n    assert(op.isValid());            // Input validation\n\n    // Implementation\n\n    assert(self.log.len > 0);        // Postcondition\n}",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 9,
        "chars": 251
      },
      {
        "index": 34,
        "start_line": 574,
        "end_line": 583,
        "code": "const ComptimeStringMapWithKeyType = std.ComptimeStringMapWithKeyType;\n\nconst http_methods = ComptimeStringMapWithKeyType(Method, .{\n    .{ \"GET\", .GET },\n    .{ \"POST\", .POST },\n    .{ \"PUT\", .PUT },\n    // Lookup compiled into perfect hash or switch\n});",
        "file": "/home/jack/workspace/zig_guide/sections/02_language_idioms/content.md",
        "lines": 8,
        "chars": 255
      }
    ]
  },
  {
    "chapter": "03_memory_allocators",
    "content_file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
    "total_blocks": 15,
    "runnable_blocks": 3,
    "snippet_blocks": 12,
    "runnable": [
      {
        "index": 1,
        "start_line": 24,
        "end_line": 50,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer {\n        const deinit_status = gpa.deinit();\n        if (deinit_status == .leak) {\n            std.debug.print(\"Memory leak detected!\\n\", .{});\n        }\n    }\n    const allocator = gpa.allocator();\n\n    // Slice allocation\n    const numbers = try allocator.alloc(u32, 5);\n    defer allocator.free(numbers);\n\n    // Single item allocation\n    const single = try allocator.create(u32);\n    defer allocator.destroy(single);\n    single.* = 42;\n\n    // Aligned allocation (16-byte boundary)\n    const aligned = try allocator.alignedAlloc(u8, 16, 64);\n    defer allocator.free(aligned);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 25,
        "chars": 700
      },
      {
        "index": 9,
        "start_line": 202,
        "end_line": 244,
        "code": "const std = @import(\"std\");\n\nfn handleRequest(allocator: std.mem.Allocator, req_id: u32, data: []const u8) ![]u8 {\n    var parts = std.ArrayList([]const u8).init(allocator);\n    defer parts.deinit();\n\n    try parts.append(\"Processing request \");\n    const id_str = try std.fmt.allocPrint(allocator, \"{}\", .{req_id});\n    defer allocator.free(id_str);\n    try parts.append(id_str);\n\n    // Concatenate parts\n    var total_len: usize = 0;\n    for (parts.items) |part| total_len += part.len;\n\n    const result = try allocator.alloc(u8, total_len);\n    var offset: usize = 0;\n    for (parts.items) |part| {\n        @memcpy(result[offset..][0..part.len], part);\n        offset += part.len;\n    }\n\n    return result;\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n\n    var arena = std.heap.ArenaAllocator.init(gpa.allocator());\n    defer arena.deinit();\n\n    // Process multiple requests\n    var i: u32 = 0;\n    while (i < 3) : (i += 1) {\n        defer _ = arena.reset(.{ .retain_with_limit = 4096 });\n        const response = try handleRequest(arena.allocator(), i, \"data\");\n        std.debug.print(\"{s}\\n\", .{response});\n        // No individual frees needed\u2014arena handles it\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 41,
        "chars": 1240
      },
      {
        "index": 10,
        "start_line": 250,
        "end_line": 274,
        "code": "const std = @import(\"std\");\n\nfn formatMessage(buffer: []u8, name: []const u8, value: i32) ![]const u8 {\n    var fba = std.heap.FixedBufferAllocator.init(buffer);\n    const allocator = fba.allocator();\n\n    return try std.fmt.allocPrint(\n        allocator,\n        \"User: {s}, Score: {}\",\n        .{ name, value }\n    );\n}\n\npub fn main() !void {\n    var stack_buffer: [256]u8 = undefined;\n\n    const msg1 = try formatMessage(&stack_buffer, \"Alice\", 100);\n    std.debug.print(\"{s}\\n\", .{msg1});\n\n    // Reuse same buffer (overwrites previous content)\n    const msg2 = try formatMessage(&stack_buffer, \"Bob\", 200);\n    std.debug.print(\"{s}\\n\", .{msg2});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 23,
        "chars": 652
      }
    ],
    "snippets": [
      {
        "index": 2,
        "start_line": 80,
        "end_line": 86,
        "code": "fn processData(allocator: std.mem.Allocator, data: []const u8) !Result {\n    const buffer = try allocator.alloc(u8, data.len * 2);\n    defer allocator.free(buffer);\n    // Process data...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 5,
        "chars": 189
      },
      {
        "index": 3,
        "start_line": 90,
        "end_line": 107,
        "code": "const Parser = struct {\n    allocator: std.mem.Allocator,\n    tokens: std.ArrayList(Token),\n\n    pub fn init(allocator: std.mem.Allocator) !Parser {\n        return .{\n            .allocator = allocator,\n            .tokens = std.ArrayList(Token).init(allocator),\n        };\n    }\n\n    pub fn deinit(self: *Parser) void {\n        self.tokens.deinit();\n        // Allocator stored for cleanup\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 16,
        "chars": 399
      },
      {
        "index": 4,
        "start_line": 117,
        "end_line": 123,
        "code": "/// Processes data into caller-provided buffer.\n/// Caller retains ownership of `buffer`.\nfn processInPlace(buffer: []u8, data: []const u8) void {\n    @memcpy(buffer[0..data.len], data);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 5,
        "chars": 188
      },
      {
        "index": 5,
        "start_line": 127,
        "end_line": 137,
        "code": "/// Allocates and returns a buffer. Caller owns returned memory\n/// and must free it with the same allocator.\nfn allocateResult(allocator: std.mem.Allocator, size: usize) ![]u8 {\n    return try allocator.alloc(u8, size);\n}\n\n// Usage\nconst result = try allocateResult(allocator, 100);\ndefer allocator.free(result); // Caller must free",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 9,
        "chars": 333
      },
      {
        "index": 6,
        "start_line": 141,
        "end_line": 161,
        "code": "const Resource = struct {\n    allocator: std.mem.Allocator,\n    data: []u8,\n\n    pub fn init(allocator: std.mem.Allocator, size: usize) !Resource {\n        return .{\n            .allocator = allocator,\n            .data = try allocator.alloc(u8, size),\n        };\n    }\n\n    pub fn deinit(self: *Resource) void {\n        self.allocator.free(self.data);\n    }\n};\n\n// Usage\nvar resource = try Resource.init(allocator, 1024);\ndefer resource.deinit();",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 19,
        "chars": 447
      },
      {
        "index": 7,
        "start_line": 171,
        "end_line": 177,
        "code": "const data = try allocator.alloc(u8, 100);\ndefer allocator.free(data); // Executes when scope exits\n\nconst file = try std.fs.cwd().openFile(\"data.txt\", .{});\ndefer file.close();",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 5,
        "chars": 177
      },
      {
        "index": 8,
        "start_line": 181,
        "end_line": 192,
        "code": "fn createResources(allocator: std.mem.Allocator) !Resources {\n    const buffer1 = try allocator.alloc(u8, 100);\n    errdefer allocator.free(buffer1); // Only on error\n\n    const buffer2 = try allocator.alloc(u8, 200);\n    errdefer allocator.free(buffer2); // Only on error\n\n    return .{ .buf1 = buffer1, .buf2 = buffer2 };\n    // Success: both buffers returned, no cleanup\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 10,
        "chars": 375
      },
      {
        "index": 11,
        "start_line": 280,
        "end_line": 318,
        "code": "const std = @import(\"std\");\n\nconst Database = struct {\n    connection: []u8,\n    buffer: []u8,\n    cache: []u8,\n    allocator: std.mem.Allocator,\n\n    pub fn init(allocator: std.mem.Allocator, conn_str: []const u8) !Database {\n        const connection = try allocator.alloc(u8, conn_str.len);\n        errdefer allocator.free(connection);\n        @memcpy(connection, conn_str);\n\n        const buffer = try allocator.alloc(u8, 1024);\n        errdefer allocator.free(buffer);\n\n        const cache = try allocator.alloc(u8, 2048);\n        errdefer allocator.free(cache);\n\n        if (conn_str.len > 100) {\n            return error.ConnectionFailed; // Automatic cleanup via errdefer\n        }\n\n        return .{\n            .connection = connection,\n            .buffer = buffer,\n            .cache = cache,\n            .allocator = allocator,\n        };\n    }\n\n    pub fn deinit(self: *Database) void {\n        self.allocator.free(self.cache);\n        self.allocator.free(self.buffer);\n        self.allocator.free(self.connection);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 37,
        "chars": 1037
      },
      {
        "index": 12,
        "start_line": 326,
        "end_line": 339,
        "code": "// \u274c WRONG: Leak on early return\nfn leakyFunction(allocator: std.mem.Allocator) !void {\n    const data = try allocator.alloc(u8, 100);\n    if (someCondition) return error.Failed; // Leak!\n}\n\n// \u2705 CORRECT: defer ensures cleanup\nfn fixedFunction(allocator: std.mem.Allocator) !void {\n    const data = try allocator.alloc(u8, 100);\n    defer allocator.free(data);\n    if (someCondition) return error.Failed; // No leak\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 12,
        "chars": 417
      },
      {
        "index": 13,
        "start_line": 345,
        "end_line": 356,
        "code": "// \u274c WRONG: Wrong allocator\nvar arena = std.heap.ArenaAllocator.init(gpa.allocator());\nconst data = try arena.allocator().alloc(u8, 100);\ngpa.allocator().free(data); // Wrong allocator!\n\n// \u2705 CORRECT: Use same allocator\nvar arena = std.heap.ArenaAllocator.init(gpa.allocator());\nconst allocator = arena.allocator();\nconst data = try allocator.alloc(u8, 100);\n// Rely on arena.deinit() or use same allocator",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 10,
        "chars": 406
      },
      {
        "index": 14,
        "start_line": 362,
        "end_line": 372,
        "code": "// \u274c WRONG: Use after free\nvar data = try allocator.alloc(u8, 100);\nallocator.free(data);\ndata[0] = 42; // Use after free!\n\n// \u2705 CORRECT: defer delays free until end of scope\nvar data = try allocator.alloc(u8, 100);\ndefer allocator.free(data);\ndata[0] = 42; // Still valid",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 9,
        "chars": 272
      },
      {
        "index": 15,
        "start_line": 378,
        "end_line": 391,
        "code": "// \u274c WRONG: Dangling pointer\nfn createData() *u8 {\n    var data: u8 = 42;\n    return &data; // Pointer to stack memory!\n}\n\n// \u2705 CORRECT: Heap allocation, caller owns\nfn createData(allocator: std.mem.Allocator) !*u8 {\n    const data = try allocator.create(u8);\n    data.* = 42;\n    return data; // Caller must destroy()\n}",
        "file": "/home/jack/workspace/zig_guide/sections/03_memory_allocators/content.md",
        "lines": 12,
        "chars": 320
      }
    ]
  },
  {
    "chapter": "04_collections_containers",
    "content_file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
    "total_blocks": 41,
    "runnable_blocks": 6,
    "snippet_blocks": 35,
    "runnable": [
      {
        "index": 18,
        "start_line": 327,
        "end_line": 369,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // \u2705 0.15+ Unmanaged ArrayList (default)\n    std.debug.print(\"=== Unmanaged ArrayList ===\\n\", .{});\n    var unmanaged_list = std.ArrayList(u32).init(allocator);\n    defer unmanaged_list.deinit(allocator);  // Allocator required\n\n    try unmanaged_list.append(allocator, 10);  // Allocator required\n    try unmanaged_list.append(allocator, 20);\n    try unmanaged_list.append(allocator, 30);\n\n    std.debug.print(\"Items: \", .{});\n    for (unmanaged_list.items) |item| {\n        std.debug.print(\"{} \", .{item});\n    }\n    std.debug.print(\"\\n\", .{});\n    std.debug.print(\"Capacity: {}, Length: {}\\n\", .{ unmanaged_list.capacity, unmanaged_list.items.len });\n\n    // Show struct size difference\n    std.debug.print(\"Unmanaged struct size: {} bytes\\n\\n\", .{@sizeOf(@TypeOf(unmanaged_list))});\n\n    // Pre-allocation pattern\n    std.debug.print(\"=== Pre-allocation Pattern ===\\n\", .{});\n    var preallocated = std.ArrayList(u32).init(allocator);\n    defer preallocated.deinit(allocator);\n\n    // Allocate exact capacity upfront (no reallocation needed)\n    try preallocated.ensureTotalCapacity(allocator, 100);\n    std.debug.print(\"Pre-allocated capacity: {}\\n\", .{preallocated.capacity});\n\n    // Fast append without allocation\n    for (0..100) |i| {\n        preallocated.appendAssumeCapacity(@intCast(i));\n    }\n    std.debug.print(\"After 100 appends, capacity: {}\\n\", .{preallocated.capacity});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 41,
        "chars": 1570
      },
      {
        "index": 19,
        "start_line": 375,
        "end_line": 452,
        "code": "const std = @import(\"std\");\n\nconst User = struct {\n    id: u32,\n    name: []u8,\n    score: i32,\n\n    pub fn init(allocator: std.mem.Allocator, id: u32, name: []const u8, score: i32) !User {\n        return .{\n            .id = id,\n            .name = try allocator.dupe(u8, name),\n            .score = score,\n        };\n    }\n\n    pub fn deinit(self: *User, allocator: std.mem.Allocator) void {\n        allocator.free(self.name);\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Pattern 1: Direct value storage\n    std.debug.print(\"=== Pattern 1: Direct Value Storage ===\\n\", .{});\n    var users_direct = std.AutoHashMapUnmanaged(u32, User).init();\n    defer {\n        // Must clean up allocated fields within values\n        var it = users_direct.iterator();\n        while (it.next()) |entry| {\n            entry.value_ptr.deinit(allocator);\n        }\n        users_direct.deinit(allocator);\n    }\n\n    var user1 = try User.init(allocator, 1, \"Alice\", 100);\n    try users_direct.put(allocator, user1.id, user1);\n\n    if (users_direct.get(1)) |user| {\n        std.debug.print(\"Found user: {s}, score: {}\\n\\n\", .{ user.name, user.score });\n    }\n\n    // Pattern 2: Pointer storage (detached lifetime)\n    std.debug.print(\"=== Pattern 2: Pointer Storage ===\\n\", .{});\n    var users_ptr = std.AutoHashMapUnmanaged(u32, *User).init();\n    defer {\n        // Must free both the pointed-to objects AND the pointers\n        var it = users_ptr.iterator();\n        while (it.next()) |entry| {\n            entry.value_ptr.*.deinit(allocator);\n            allocator.destroy(entry.value_ptr.*);\n        }\n        users_ptr.deinit(allocator);\n    }\n\n    var user2 = try allocator.create(User);\n    user2.* = try User.init(allocator, 2, \"Bob\", 200);\n    try users_ptr.put(allocator, user2.id, user2);\n\n    if (users_ptr.get(2)) |user_ptr| {\n        std.debug.print(\"Found user: {s}, score: {}\\n\\n\", .{ user_ptr.name, user_ptr.score });\n    }\n\n    // Pattern 3: HashMap as Set (void value)\n    std.debug.print(\"=== Pattern 3: HashMap as Set ===\\n\", .{});\n    var seen_ids = std.AutoHashMapUnmanaged(u32, void).init();\n    defer seen_ids.deinit(allocator);\n\n    try seen_ids.put(allocator, 42, {});\n    try seen_ids.put(allocator, 100, {});\n\n    std.debug.print(\"Contains 42? {}\\n\", .{seen_ids.contains(42)});\n    std.debug.print(\"Contains 99? {}\\n\", .{seen_ids.contains(99)});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 76,
        "chars": 2474
      },
      {
        "index": 20,
        "start_line": 458,
        "end_line": 546,
        "code": "const std = @import(\"std\");\n\nconst Database = struct {\n    tables: std.ArrayList(Table),\n    allocator: std.mem.Allocator,\n\n    const Table = struct {\n        name: []u8,\n        rows: std.ArrayList([]u8),\n    };\n\n    pub fn init(allocator: std.mem.Allocator, table_names: []const []const u8) !Database {\n        var tables = std.ArrayList(Table).init(allocator);\n        errdefer {\n            // Clean up any successfully initialized tables on error\n            for (tables.items) |*table| {\n                for (table.rows.items) |row| {\n                    allocator.free(row);\n                }\n                table.rows.deinit(allocator);\n                allocator.free(table.name);\n            }\n            tables.deinit(allocator);\n        }\n\n        for (table_names) |name| {\n            const table_name = try allocator.dupe(u8, name);\n            errdefer allocator.free(table_name);  // If rows allocation fails\n\n            var rows = std.ArrayList([]u8).init(allocator);\n            errdefer rows.deinit(allocator);  // If append to tables fails\n\n            try tables.append(allocator, .{\n                .name = table_name,\n                .rows = rows,\n            });\n        }\n\n        return .{\n            .tables = tables,\n            .allocator = allocator,\n        };\n    }\n\n    pub fn deinit(self: *Database) void {\n        for (self.tables.items) |*table| {\n            for (table.rows.items) |row| {\n                self.allocator.free(row);\n            }\n            table.rows.deinit(self.allocator);\n            self.allocator.free(table.name);\n        }\n        self.tables.deinit(self.allocator);\n    }\n\n    pub fn addRow(self: *Database, table_idx: usize, data: []const u8) !void {\n        if (table_idx >= self.tables.items.len) return error.InvalidTable;\n\n        const row = try self.allocator.dupe(u8, data);\n        errdefer self.allocator.free(row);\n\n        try self.tables.items[table_idx].rows.append(self.allocator, row);\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    std.debug.print(\"=== Nested Container with errdefer ===\\n\", .{});\n\n    // Success case\n    const table_names = [_][]const u8{ \"users\", \"products\", \"orders\" };\n    var db = try Database.init(allocator, &table_names);\n    defer db.deinit();\n\n    try db.addRow(0, \"Alice\");\n    try db.addRow(0, \"Bob\");\n    try db.addRow(1, \"Widget\");\n\n    for (db.tables.items, 0..) |table, i| {\n        std.debug.print(\"Table {s} has {} rows\\n\", .{ table.name, table.rows.items.len });\n    }\n\n    std.debug.print(\"\\nDatabase cleaned up successfully\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 87,
        "chars": 2670
      },
      {
        "index": 21,
        "start_line": 552,
        "end_line": 623,
        "code": "const std = @import(\"std\");\n\nfn buildMessage(allocator: std.mem.Allocator, parts: []const []const u8) ![]const u8 {\n    var list = std.ArrayList(u8).init(allocator);\n    // Note: No defer here - ownership transferred via toOwnedSlice\n\n    for (parts, 0..) |part, i| {\n        try list.appendSlice(allocator, part);\n        if (i < parts.len - 1) {\n            try list.append(allocator, ' ');\n        }\n    }\n\n    // Transfer ownership to caller\n    return list.toOwnedSlice(allocator);\n}\n\nfn processData(allocator: std.mem.Allocator, input: []const u8) !std.ArrayList(u32) {\n    var numbers = std.ArrayList(u32).init(allocator);\n    errdefer numbers.deinit(allocator);  // Clean up on error\n\n    for (input) |byte| {\n        if (byte >= '0' and byte <= '9') {\n            try numbers.append(allocator, byte - '0');\n        }\n    }\n\n    // Transfer ownership by returning the ArrayList directly\n    return numbers;\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    std.debug.print(\"=== Ownership Transfer Patterns ===\\n\\n\", .{});\n\n    // Pattern 1: toOwnedSlice (ArrayList \u2192 Slice)\n    std.debug.print(\"Pattern 1: toOwnedSlice\\n\", .{});\n    const parts = [_][]const u8{ \"Hello\", \"from\", \"Zig\" };\n    const message = try buildMessage(allocator, &parts);\n    defer allocator.free(message);  // Caller owns and must free\n\n    std.debug.print(\"Message: {s}\\n\\n\", .{message});\n\n    // Pattern 2: Return ArrayList directly\n    std.debug.print(\"Pattern 2: Return ArrayList\\n\", .{});\n    var numbers = try processData(allocator, \"a1b2c3d4e5\");\n    defer numbers.deinit(allocator);  // Caller owns and must deinit\n\n    std.debug.print(\"Numbers: \", .{});\n    for (numbers.items) |num| {\n        std.debug.print(\"{} \", .{num});\n    }\n    std.debug.print(\"\\n\\n\", .{});\n\n    // Pattern 3: fromOwnedSlice (Slice \u2192 ArrayList)\n    std.debug.print(\"Pattern 3: fromOwnedSlice\\n\", .{});\n    const raw_data = try allocator.alloc(u8, 5);\n    for (raw_data, 0..) |*byte, i| {\n        byte.* = @intCast('A' + i);\n    }\n\n    var list_from_slice = std.ArrayList(u8).fromOwnedSlice(allocator, raw_data);\n    defer list_from_slice.deinit(allocator);  // Now list owns the data\n\n    try list_from_slice.append(allocator, 'F');  // Can grow\n    std.debug.print(\"From slice: {s}\\n\", .{list_from_slice.items});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 70,
        "chars": 2383
      },
      {
        "index": 22,
        "start_line": 629,
        "end_line": 688,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    std.debug.print(\"=== Reusing Containers Across Iterations ===\\n\\n\", .{});\n\n    var buffer = std.ArrayList(u8).init(allocator);\n    defer buffer.deinit(allocator);\n\n    // Pre-allocate reasonable capacity\n    try buffer.ensureTotalCapacity(allocator, 1024);\n\n    const requests = [_][]const u8{ \"request1\", \"request2\", \"request3\" };\n\n    for (requests, 0..) |request, i| {\n        // Clear contents but keep capacity\n        buffer.clearRetainingCapacity();\n\n        std.debug.print(\"Iteration {}: \", .{i});\n        std.debug.print(\"Length: {}, Capacity: {}\\n\", .{ buffer.items.len, buffer.capacity });\n\n        // Build response using existing capacity\n        try buffer.appendSlice(allocator, \"Response to \");\n        try buffer.appendSlice(allocator, request);\n\n        std.debug.print(\"  Built: {s}\\n\", .{buffer.items});\n        std.debug.print(\"  Final length: {}, Capacity: {}\\n\\n\", .{ buffer.items.len, buffer.capacity });\n    }\n\n    std.debug.print(\"No reallocations occurred - capacity stayed constant\\n\", .{});\n\n    // HashMap example\n    std.debug.print(\"\\n=== HashMap Reset Pattern ===\\n\\n\", .{});\n\n    var cache = std.AutoHashMapUnmanaged(u32, []const u8).init();\n    defer cache.deinit(allocator);\n\n    try cache.ensureTotalCapacity(allocator, 100);\n\n    for (0..3) |batch| {\n        std.debug.print(\"Batch {}: \", .{batch});\n\n        // Populate cache\n        for (0..10) |i| {\n            try cache.put(allocator, @intCast(i), \"data\");\n        }\n\n        std.debug.print(\"Count: {}, Capacity: {}\\n\", .{ cache.count(), cache.capacity() });\n\n        // Reset for next batch\n        cache.clearRetainingCapacity();\n    }\n\n    std.debug.print(\"\\nCache reused across batches without reallocation\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 58,
        "chars": 1895
      },
      {
        "index": 23,
        "start_line": 694,
        "end_line": 749,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const iterations = 1000;\n\n    // HashMap vs ArrayHashMap iteration performance\n    std.debug.print(\"=== HashMap vs ArrayHashMap Iteration ===\\n\", .{});\n\n    var hash_map = std.AutoHashMapUnmanaged(u32, u32).init();\n    defer hash_map.deinit(allocator);\n\n    var array_hash_map = std.AutoArrayHashMapUnmanaged(u32, u32).init();\n    defer array_hash_map.deinit(allocator);\n\n    // Populate both\n    for (0..100) |i| {\n        try hash_map.put(allocator, @intCast(i), @intCast(i * 2));\n        try array_hash_map.put(allocator, @intCast(i), @intCast(i * 2));\n    }\n\n    // Iterate HashMap\n    var timer = try std.time.Timer.start();\n    var sum1: u64 = 0;\n    for (0..iterations) |_| {\n        var it1 = hash_map.iterator();\n        while (it1.next()) |entry| {\n            sum1 += entry.value_ptr.*;\n        }\n    }\n    const hash_map_time = timer.read();\n\n    // Iterate ArrayHashMap\n    timer.reset();\n    var sum2: u64 = 0;\n    for (0..iterations) |_| {\n        var it2 = array_hash_map.iterator();\n        while (it2.next()) |entry| {\n            sum2 += entry.value_ptr.*;\n        }\n    }\n    const array_hash_map_time = timer.read();\n\n    std.debug.print(\"HashMap iteration: {} ns (sum: {})\\n\", .{ hash_map_time, sum1 });\n    std.debug.print(\"ArrayHashMap iteration: {} ns (sum: {})\\n\", .{ array_hash_map_time, sum2 });\n\n    if (array_hash_map_time > 0) {\n        const speedup = @as(f64, @floatFromInt(hash_map_time)) / @as(f64, @floatFromInt(array_hash_map_time));\n        std.debug.print(\"ArrayHashMap is {d:.2}x faster for iteration\\n\", .{speedup});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 54,
        "chars": 1743
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 25,
        "end_line": 37,
        "code": "const std = @import(\"std\");\n\n// \ud83d\udd50 0.14.x - Managed (default)\nconst ManagedList = struct {\n    data: std.ArrayList(u32),\n};\n\n// \u2705 0.15+ - Unmanaged (new default)\nconst UnmanagedList = struct {\n    data: std.ArrayList(u32),\n};",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 11,
        "chars": 224
      },
      {
        "index": 2,
        "start_line": 49,
        "end_line": 56,
        "code": "pub fn Aligned(comptime T: type, comptime alignment: ?u29) type {\n    return struct {\n        items: Slice = &[_]T{},\n        capacity: usize = 0,\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 6,
        "chars": 155
      },
      {
        "index": 3,
        "start_line": 60,
        "end_line": 64,
        "code": "var list = std.ArrayList(u32).init(allocator);\ntry list.append(allocator, 42);  // Allocator explicit\ndefer list.deinit(allocator);    // Allocator required for cleanup",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 3,
        "chars": 168
      },
      {
        "index": 4,
        "start_line": 74,
        "end_line": 78,
        "code": "var users = std.AutoHashMapUnmanaged(u32, User).init();\ntry users.put(allocator, 1, user_instance);\ndefer users.deinit(allocator);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 3,
        "chars": 130
      },
      {
        "index": 5,
        "start_line": 82,
        "end_line": 92,
        "code": "var ordered = std.AutoArrayHashMapUnmanaged(u32, []const u8).init();\ntry ordered.put(allocator, 1, \"first\");\ntry ordered.put(allocator, 2, \"second\");\n\n// Iteration over contiguous memory is cache-friendly\nvar it = ordered.iterator();\nwhile (it.next()) |entry| {\n    std.debug.print(\"{}: {s}\\n\", .{ entry.key_ptr.*, entry.value_ptr.* });\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 9,
        "chars": 338
      },
      {
        "index": 6,
        "start_line": 102,
        "end_line": 111,
        "code": "const User = struct {\n    id: u32,\n    age: u8,\n};\n\nvar users = std.AutoHashMapUnmanaged(u32, User).init();\ntry users.put(allocator, 1, User{ .id = 1, .age = 30 });\ndefer users.deinit(allocator);  // Frees hash map structure",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 8,
        "chars": 224
      },
      {
        "index": 7,
        "start_line": 115,
        "end_line": 133,
        "code": "const User = struct {\n    id: u32,\n    name: []u8,  // Allocated separately\n\n    fn deinit(self: *User, alloc: std.mem.Allocator) void {\n        alloc.free(self.name);\n    }\n};\n\nvar users = std.AutoHashMapUnmanaged(u32, User).init();\ndefer {\n    var it = users.iterator();\n    while (it.next()) |entry| {\n        entry.value_ptr.deinit(allocator);  // Clean user's name\n    }\n    users.deinit(allocator);  // Clean hash map structure\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 17,
        "chars": 435
      },
      {
        "index": 8,
        "start_line": 137,
        "end_line": 147,
        "code": "var users = std.AutoHashMapUnmanaged(u32, *User).init();\ndefer {\n    var it = users.iterator();\n    while (it.next()) |entry| {\n        entry.value_ptr.*.deinit(allocator);  // Clean user object\n        allocator.destroy(entry.value_ptr.*);  // Free pointer\n    }\n    users.deinit(allocator);  // Clean map structure\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 9,
        "chars": 318
      },
      {
        "index": 9,
        "start_line": 153,
        "end_line": 161,
        "code": "var list = std.ArrayList(u8).init(allocator);\ntry list.appendSlice(allocator, \"Hello\");\n\nconst owned = try list.toOwnedSlice(allocator);\ndefer allocator.free(owned);  // Caller must free\n\n// list is now empty: items.len == 0, capacity == 0",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 7,
        "chars": 239
      },
      {
        "index": 10,
        "start_line": 171,
        "end_line": 176,
        "code": "var list = std.ArrayList(u32).init(allocator);\ndefer list.deinit(allocator);  // Required\n\ntry list.append(allocator, 42);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 122
      },
      {
        "index": 11,
        "start_line": 182,
        "end_line": 190,
        "code": "var outer = std.ArrayList(std.ArrayList(u32)).init(allocator);\ndefer {\n    for (outer.items) |*inner| {\n        inner.deinit(allocator);  // Clean each inner list first\n    }\n    outer.deinit(allocator);  // Clean outer list last\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 7,
        "chars": 231
      },
      {
        "index": 12,
        "start_line": 194,
        "end_line": 219,
        "code": "pub fn init(allocator: std.mem.Allocator, options: Options) !CacheMap {\n    var cache: ?Cache = if (options.cache_value_count_max == 0)\n        null\n    else\n        try Cache.init(allocator, options.cache_value_count_max, .{ .name = options.name });\n    errdefer if (cache) |*c| c.deinit(allocator);\n\n    var stash: Map = .{};\n    try stash.ensureTotalCapacity(allocator, options.stash_value_count_max);\n    errdefer stash.deinit(allocator);\n\n    var scope_rollback_log = try std.ArrayListUnmanaged(Value).initCapacity(\n        allocator,\n        options.scope_value_count_max,\n    );\n    errdefer scope_rollback_log.deinit(allocator);\n\n    return CacheMap{\n        .cache = cache,\n        .stash = stash,\n        .scope_rollback_log = scope_rollback_log,\n        .options = options,\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 24,
        "chars": 793
      },
      {
        "index": 13,
        "start_line": 225,
        "end_line": 236,
        "code": "var arena = std.heap.ArenaAllocator.init(page_allocator);\ndefer arena.deinit();  // Frees everything at once\nconst arena_alloc = arena.allocator();\n\nvar list1 = std.ArrayList(u8).init(arena_alloc);\nvar list2 = std.ArrayList(u32).init(arena_alloc);\n\n// No individual deinit needed - arena cleanup handles all\ntry list1.appendSlice(arena_alloc, \"data\");\ntry list2.append(arena_alloc, 42);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 10,
        "chars": 386
      },
      {
        "index": 14,
        "start_line": 250,
        "end_line": 260,
        "code": "// ArrayList: Unknown size, heap allocation\nvar dynamic = std.ArrayList(u8).init(allocator);\ndefer dynamic.deinit(allocator);\n\n// Fixed array: Known size, stack allocation\nvar fixed: [128]u8 = undefined;\n\n// Slice: Borrows data\nconst borrowed: []const u8 = \"static string\";",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 9,
        "chars": 273
      },
      {
        "index": 15,
        "start_line": 279,
        "end_line": 290,
        "code": "var list = std.ArrayList(u32).init(allocator);\ndefer list.deinit(allocator);\n\n// Pre-allocate known capacity\ntry list.ensureTotalCapacity(allocator, 100);\n\n// Append without allocation\nfor (0..100) |i| {\n    list.appendAssumeCapacity(@intCast(i));  // No allocation\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 10,
        "chars": 267
      },
      {
        "index": 16,
        "start_line": 294,
        "end_line": 303,
        "code": "var args: std.ArrayList([:0]const u8) = try .initCapacity(\n    alloc,\n    // This capacity is chosen based on what we'd need to\n    // execute a shell command (very common). We can/will\n    // grow if necessary for a longer command (uncommon).\n    9,\n);\ndefer args.deinit(alloc);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 8,
        "chars": 279
      },
      {
        "index": 17,
        "start_line": 309,
        "end_line": 319,
        "code": "var buffer = std.ArrayList(u8).init(allocator);\ndefer buffer.deinit(allocator);\n\ntry buffer.ensureTotalCapacity(allocator, 1024);\n\nfor (requests) |request| {\n    buffer.clearRetainingCapacity();  // Clear contents, keep capacity\n    try processRequest(request, &buffer);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 9,
        "chars": 272
      },
      {
        "index": 24,
        "start_line": 760,
        "end_line": 767,
        "code": "fn processData(allocator: std.mem.Allocator) !void {\n    var list = std.ArrayList(u8).init(allocator);\n    try list.append(allocator, 'A');\n    // Forgot: defer list.deinit(allocator);\n    if (someCondition) return error.Failed;  // Leak!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 6,
        "chars": 240
      },
      {
        "index": 25,
        "start_line": 772,
        "end_line": 778,
        "code": "test \"container cleanup\" {\n    var list = std.ArrayList(u8).init(std.testing.allocator);\n    defer list.deinit(std.testing.allocator);\n    try list.append(std.testing.allocator, 'A');\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 5,
        "chars": 185
      },
      {
        "index": 26,
        "start_line": 785,
        "end_line": 792,
        "code": "fn processData(allocator: std.mem.Allocator) !void {\n    var list = std.ArrayList(u8).init(allocator);\n    defer list.deinit(allocator);  // Placed immediately\n    try list.append(allocator, 'A');\n    if (someCondition) return error.Failed;  // No leak\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 6,
        "chars": 254
      },
      {
        "index": 27,
        "start_line": 799,
        "end_line": 806,
        "code": "var outer = std.ArrayList(std.ArrayList(u8)).init(allocator);\ndefer outer.deinit(allocator);  // Only frees outer, not inner lists!\n\nvar inner = std.ArrayList(u8).init(allocator);\ntry inner.append(allocator, 1);\ntry outer.append(allocator, inner);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 6,
        "chars": 247
      },
      {
        "index": 28,
        "start_line": 811,
        "end_line": 819,
        "code": "var outer = std.ArrayList(std.ArrayList(u8)).init(allocator);\ndefer {\n    for (outer.items) |*inner_list| {\n        inner_list.deinit(allocator);  // Free each inner\n    }\n    outer.deinit(allocator);  // Free outer\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 7,
        "chars": 217
      },
      {
        "index": 29,
        "start_line": 826,
        "end_line": 829,
        "code": "var cache = std.StringHashMapUnmanaged(*User).init();\ndefer cache.deinit(allocator);  // Doesn't free User pointers!",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 2,
        "chars": 116
      },
      {
        "index": 30,
        "start_line": 834,
        "end_line": 844,
        "code": "var cache = std.StringHashMapUnmanaged(*User).init();\ndefer {\n    var it = cache.iterator();\n    while (it.next()) |entry| {\n        entry.value_ptr.*.deinit();  // Clean user object\n        allocator.destroy(entry.value_ptr.*);  // Free pointer\n    }\n    cache.deinit(allocator);  // Free map\n}",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 9,
        "chars": 295
      },
      {
        "index": 31,
        "start_line": 853,
        "end_line": 860,
        "code": "var list = std.ArrayList(u32).init(allocator);\ntry list.append(allocator, 1);\nconst ptr = &list.items[0];  // Get pointer to first element\n\ntry list.append(allocator, 2);  // May reallocate!\nptr.* = 10;  // Pointer may be invalid",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 6,
        "chars": 229
      },
      {
        "index": 32,
        "start_line": 867,
        "end_line": 874,
        "code": "var list = std.ArrayList(u32).init(allocator);\ntry list.append(allocator, 1);\nconst index = 0;\n\ntry list.append(allocator, 2);\nlist.items[index] = 10;  // Safe",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 6,
        "chars": 159
      },
      {
        "index": 33,
        "start_line": 878,
        "end_line": 883,
        "code": "var list = std.ArrayList(u32).init(allocator);\ntry list.ensureTotalCapacity(allocator, 10);\nconst ptr = &list.items[0];  // Safe until capacity exceeded\ntry list.append(allocator, 1);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 183
      },
      {
        "index": 34,
        "start_line": 890,
        "end_line": 895,
        "code": "// This worked in 0.14.x (managed)\nvar list = std.ArrayList(u32).init(allocator);\ndefer list.deinit();  // 0.15+: missing allocator parameter\ntry list.append(42);  // 0.15+: missing allocator parameter",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 201
      },
      {
        "index": 35,
        "start_line": 907,
        "end_line": 912,
        "code": "// \u2705 0.15+ (unmanaged)\nvar list = std.ArrayList(u32).init(allocator);\ndefer list.deinit(allocator);  // Pass allocator\ntry list.append(allocator, 42);  // Pass allocator",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 169
      },
      {
        "index": 36,
        "start_line": 926,
        "end_line": 931,
        "code": "var scope_rollback_log = try std.ArrayListUnmanaged(Value).initCapacity(\n    allocator,\n    options.scope_value_count_max,\n);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 125
      },
      {
        "index": 37,
        "start_line": 937,
        "end_line": 951,
        "code": "pub const Map = std.HashMapUnmanaged(\n    Value,\n    void,  // Set pattern: no associated data\n    struct {\n        pub inline fn eql(_: @This(), a: Value, b: Value) bool {\n            return key_from_value(&a) == key_from_value(&b);\n        }\n        pub inline fn hash(_: @This(), value: Value) u64 {\n            return stdx.hash_inline(key_from_value(&value));\n        }\n    },\n    50,  // 50% max load factor\n);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 13,
        "chars": 415
      },
      {
        "index": 38,
        "start_line": 959,
        "end_line": 964,
        "code": "var args: std.ArrayList([:0]const u8) = try .initCapacity(\n    alloc,\n    9,  // Covers shell execution (common case)\n);",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 120
      },
      {
        "index": 39,
        "start_line": 972,
        "end_line": 977,
        "code": "var arena = std.heap.ArenaAllocator.init(allocator);\ndefer arena.deinit();\n\nvar result_text = std.ArrayList(u8).init(arena.allocator());",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 4,
        "chars": 136
      },
      {
        "index": 40,
        "start_line": 985,
        "end_line": 989,
        "code": "items: std.MultiArrayList(Item) = .empty,\nextra: std.ArrayList(u32) = .empty,\ndecls: std.SegmentedList(Decl, 0) = .{},",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 3,
        "chars": 118
      },
      {
        "index": 41,
        "start_line": 997,
        "end_line": 1006,
        "code": "allocator: std.mem.Allocator,\ninstructions: std.AutoArrayHashMapUnmanaged(Inst, void) = .{},\nrefs: std.ArrayListUnmanaged(InstIndex) = .{},\nstrings: std.ArrayListUnmanaged(u8) = .{},\nvalues: std.ArrayListUnmanaged(u8) = .{},\nscratch: std.ArrayListUnmanaged(InstIndex) = .{},\nglobal_var_refs: std.AutoArrayHashMapUnmanaged(InstIndex, void) = .{},\nglobals: std.ArrayListUnmanaged(InstIndex) = .{},",
        "file": "/home/jack/workspace/zig_guide/sections/04_collections_containers/content.md",
        "lines": 8,
        "chars": 395
      }
    ]
  },
  {
    "chapter": "05_io_streams",
    "content_file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
    "total_blocks": 27,
    "runnable_blocks": 1,
    "snippet_blocks": 26,
    "runnable": [
      {
        "index": 3,
        "start_line": 51,
        "end_line": 63,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.fs.File.stdout();  // \u2705 0.15+\n    var buf: [256]u8 = undefined;\n    var writer = stdout.writer(&buf);\n\n    try writer.interface.print(\"Hello from stdout! Number: {d}\\n\", .{42});\n    try writer.interface.print(\"Hex: 0x{x}, Binary: 0b{b}\\n\", .{ 255, 5 });\n    try writer.interface.flush();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 11,
        "chars": 363
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 20,
        "end_line": 27,
        "code": "const std = @import(\"std\");\n\nconst stdout = std.io.getStdOut();\nconst stderr = std.io.getStdErr();\nconst writer = stdout.writer();\ntry writer.print(\"Hello!\\n\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 6,
        "chars": 165
      },
      {
        "index": 2,
        "start_line": 30,
        "end_line": 45,
        "code": "const std = @import(\"std\");\n\nconst stdout = std.fs.File.stdout();\nconst stderr = std.fs.File.stderr();\n\n// Buffered writer (requires explicit buffer)\nvar buf: [4096]u8 = undefined;\nvar file_writer = stdout.writer(&buf);\ntry file_writer.interface.print(\"Hello!\\n\", .{});\ntry file_writer.interface.flush();\n\n// Unbuffered writer\nvar unbuffered = stdout.writer(&.{});  // Empty slice = unbuffered\ntry unbuffered.interface.writeAll(\"Direct output\\n\");",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 14,
        "chars": 447
      },
      {
        "index": 4,
        "start_line": 69,
        "end_line": 80,
        "code": "const std = @import(\"std\");\n\npub fn readEntireFile(path: []const u8, allocator: std.mem.Allocator) ![]u8 {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();  // Always close on scope exit\n\n    // Read entire file with 1MB limit\n    const contents = try file.readToEndAlloc(allocator, 1024 * 1024);\n    return contents;  // Caller must free\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 10,
        "chars": 370
      },
      {
        "index": 5,
        "start_line": 84,
        "end_line": 95,
        "code": "pub fn writeToFile(path: []const u8, data: []const u8) !void {\n    const file = try std.fs.cwd().createFile(path, .{});\n    defer file.close();\n\n    // \u2705 0.15+: Buffered writing\n    var buf: [4096]u8 = undefined;\n    var file_writer = file.writer(&buf);\n    try file_writer.interface.writeAll(data);\n    try file_writer.interface.flush();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 10,
        "chars": 340
      },
      {
        "index": 6,
        "start_line": 101,
        "end_line": 123,
        "code": "pub fn processFileLine(path: []const u8) !void {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    var buf: [4096]u8 = undefined;\n    var file_reader = file.reader(&buf);\n\n    while (true) {\n        const line = file_reader.readUntilDelimiterOrEof(&buf, '\\n') catch |err| switch (err) {\n            error.StreamTooLong => {\n                // Line longer than buffer, skip to next newline\n                try file_reader.skipUntilDelimiterOrEof('\\n');\n                continue;\n            },\n            else => return err,\n        } orelse break;  // EOF\n\n        // Process line...\n        std.debug.print(\"{s}\\n\", .{line});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 21,
        "chars": 669
      },
      {
        "index": 7,
        "start_line": 148,
        "end_line": 168,
        "code": "const Point = struct {\n    x: f32,\n    y: f32,\n\n    pub fn format(\n        self: Point,\n        comptime fmt_str: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) !void {\n        _ = options;\n        _ = fmt_str;\n        try writer.print(\"Point({d:.2}, {d:.2})\", .{ self.x, self.y });\n    }\n};\n\n// Usage:\nconst p = Point{ .x = 3.14, .y = 2.71 };\ntry writer.print(\"Location: {}\\n\", .{p});  // Output: Location: Point(3.14, 2.71)",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 19,
        "chars": 461
      },
      {
        "index": 8,
        "start_line": 172,
        "end_line": 197,
        "code": "const Color = struct {\n    r: u8,\n    g: u8,\n    b: u8,\n\n    pub fn format(\n        self: Color,\n        comptime fmt_str: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) !void {\n        _ = options;\n        if (std.mem.eql(u8, fmt_str, \"hex\")) {\n            try writer.print(\"#{x:0>2}{x:0>2}{x:0>2}\", .{ self.r, self.g, self.b });\n        } else {\n            try writer.print(\"rgb({d}, {d}, {d})\", .{ self.r, self.g, self.b });\n        }\n    }\n};\n\n// Usage:\nconst color = Color{ .r = 255, .g = 128, .b = 64 };\ntry writer.print(\"Default: {}\\n\", .{color});      // rgb(255, 128, 64)\ntry writer.print(\"Hex: {hex}\\n\", .{color});       // #ff8040",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 24,
        "chars": 678
      },
      {
        "index": 9,
        "start_line": 203,
        "end_line": 212,
        "code": "pub fn safeFileOperation(path: []const u8) !void {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();  // Executed when scope exits (success or error)\n\n    // File automatically closed on error or normal return\n    const stat = try file.stat();\n    std.debug.print(\"Size: {d} bytes\\n\", .{stat.size});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 8,
        "chars": 330
      },
      {
        "index": 10,
        "start_line": 216,
        "end_line": 226,
        "code": "pub fn createAndWrite(path: []const u8, data: []const u8) !void {\n    const file = try std.fs.cwd().createFile(path, .{});\n    errdefer file.close();  // Only executed if subsequent operations fail\n\n    // If writeAll fails, errdefer closes the file\n    try file.writeAll(data);\n\n    file.close();  // Normal close on success path\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 9,
        "chars": 332
      },
      {
        "index": 11,
        "start_line": 230,
        "end_line": 248,
        "code": "pub fn complexOperation(allocator: std.mem.Allocator) !void {\n    const file1 = try std.fs.cwd().createFile(\"file1.txt\", .{});\n    errdefer file1.close();\n\n    const file2 = try std.fs.cwd().createFile(\"file2.txt\", .{});\n    errdefer file2.close();\n\n    const buffer = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(buffer);\n\n    // Do work...\n\n    // Success path: clean up in reverse order\n    allocator.free(buffer);\n    file2.close();\n    file1.close();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 17,
        "chars": 471
      },
      {
        "index": 12,
        "start_line": 254,
        "end_line": 276,
        "code": "pub fn processBatch() !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit();  // Frees all allocations at once\n\n    const allocator = arena.allocator();\n\n    const file = try std.fs.cwd().createFile(\"output.txt\", .{});\n    defer file.close();\n\n    var buf: [256]u8 = undefined;\n    var file_writer = file.writer(&buf);\n\n    // Multiple allocations\u2014all freed by arena.deinit()\n    for (0..10) |i| {\n        const line = try std.fmt.allocPrint(allocator, \"Line {d}\\n\", .{i});\n        try file_writer.interface.writeAll(line);\n        // No need to free 'line'\u2014arena handles it\n    }\n\n    try file_writer.interface.flush();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 21,
        "chars": 672
      },
      {
        "index": 13,
        "start_line": 284,
        "end_line": 296,
        "code": "const std = @import(\"std\");\n\npub fn formatMetric(value: u64) ![512]u8 {\n    var buffer: [512]u8 = undefined;\n    var fbs = std.io.fixedBufferStream(&buffer);\n    const writer = fbs.writer();\n\n    try writer.print(\"metric.count:{d}|g\\n\", .{value});\n\n    return buffer;  // Entire buffer returned\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 11,
        "chars": 296
      },
      {
        "index": 14,
        "start_line": 304,
        "end_line": 344,
        "code": "const std = @import(\"std\");\n\npub fn demonstrateBuffering() !void {\n    const iterations = 1000;\n\n    // Unbuffered (slower)\n    {\n        const file = try std.fs.cwd().createFile(\"unbuffered.txt\", .{});\n        defer file.close();\n\n        var writer = file.writer(&.{});  // Empty slice = unbuffered\n        var timer = try std.time.Timer.start();\n\n        for (0..iterations) |i| {\n            try writer.interface.print(\"Line {d}\\n\", .{i});\n        }\n\n        const unbuffered_time = timer.read();\n        std.debug.print(\"Unbuffered: {d}ns\\n\", .{unbuffered_time});\n    }\n\n    // Buffered (faster)\n    {\n        const file = try std.fs.cwd().createFile(\"buffered.txt\", .{});\n        defer file.close();\n\n        var buf: [4096]u8 = undefined;\n        var writer = file.writer(&buf);\n        var timer = try std.time.Timer.start();\n\n        for (0..iterations) |i| {\n            try writer.interface.print(\"Line {d}\\n\", .{i});\n        }\n        try writer.interface.flush();\n\n        const buffered_time = timer.read();\n        std.debug.print(\"Buffered: {d}ns\\n\", .{buffered_time});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 39,
        "chars": 1093
      },
      {
        "index": 15,
        "start_line": 352,
        "end_line": 382,
        "code": "const FileBuffer = struct {\n    file: std.fs.File,\n    buffer: []u8,\n    allocator: std.mem.Allocator,\n\n    pub fn init(path: []const u8, allocator: std.mem.Allocator) !FileBuffer {\n        const file = try std.fs.cwd().openFile(path, .{});\n        errdefer file.close();\n\n        const buffer = try file.readToEndAlloc(allocator, 10 * 1024 * 1024);\n        errdefer allocator.free(buffer);\n\n        return FileBuffer{\n            .file = file,\n            .buffer = buffer,\n            .allocator = allocator,\n        };\n    }\n\n    pub fn deinit(self: *FileBuffer) void {\n        self.allocator.free(self.buffer);\n        self.file.close();\n    }\n};\n\n// Usage:\nvar fb = try FileBuffer.init(\"data.txt\", allocator);\ndefer fb.deinit();\n// Use fb.buffer...",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 29,
        "chars": 753
      },
      {
        "index": 16,
        "start_line": 390,
        "end_line": 396,
        "code": "// \u274c Data might not be written\nvar buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Important data\\n\", .{});\nfile.close();  // Buffer contents lost!",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 5,
        "chars": 186
      },
      {
        "index": 17,
        "start_line": 400,
        "end_line": 407,
        "code": "// \u2705 Correct\nvar buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Important data\\n\", .{});\ntry writer.interface.flush();  // Ensure data is written\nfile.close();",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 6,
        "chars": 199
      },
      {
        "index": 18,
        "start_line": 413,
        "end_line": 419,
        "code": "// \u274c File leaks if readToEndAlloc fails\npub fn readConfig(path: []const u8) ![]u8 {\n    const file = try std.fs.cwd().openFile(path, .{});\n    return try file.readToEndAlloc(allocator, max_size);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 5,
        "chars": 197
      },
      {
        "index": 19,
        "start_line": 423,
        "end_line": 430,
        "code": "// \u2705 File always closed\npub fn readConfig(path: []const u8) ![]u8 {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n    return try file.readToEndAlloc(allocator, max_size);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 6,
        "chars": 205
      },
      {
        "index": 20,
        "start_line": 436,
        "end_line": 439,
        "code": "// \u274c Debug only, not suitable for production\nstd.debug.print(\"Status: {}\\n\", .{status});",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 2,
        "chars": 88
      },
      {
        "index": 21,
        "start_line": 443,
        "end_line": 448,
        "code": "// \u2705 Production-ready\nconst stderr = std.fs.File.stderr();  // \u2705 0.15+\nvar writer = stderr.writer(&.{});\ntry writer.interface.print(\"Status: {}\\n\", .{status});",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 4,
        "chars": 159
      },
      {
        "index": 22,
        "start_line": 454,
        "end_line": 461,
        "code": "// \u274c Too small, causes many syscalls\nvar buf: [16]u8 = undefined;\nvar writer = file.writer(&buf);\nfor (0..1000) |i| {\n    try writer.interface.print(\"Line {d}\\n\", .{i});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 6,
        "chars": 171
      },
      {
        "index": 23,
        "start_line": 465,
        "end_line": 473,
        "code": "// \u2705 Better performance\nvar buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\nfor (0..1000) |i| {\n    try writer.interface.print(\"Line {d}\\n\", .{i});\n}\ntry writer.interface.flush();",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 7,
        "chars": 190
      },
      {
        "index": 24,
        "start_line": 479,
        "end_line": 487,
        "code": "// \u274c buf and file are local variables!\nfn getWriter() !std.Io.Writer {\n    var buf: [256]u8 = undefined;\n    var file = try std.fs.cwd().createFile(\"out.txt\", .{});\n    var file_writer = file.writer(&buf);\n    return file_writer.interface;  // Dangling references!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 7,
        "chars": 266
      },
      {
        "index": 25,
        "start_line": 491,
        "end_line": 499,
        "code": "// \u2705 Buffer and file have appropriate lifetime\nfn writeData(file: std.fs.File, data: []const u8) !void {\n    var buf: [4096]u8 = undefined;\n    var writer = file.writer(&buf);\n    try writer.interface.writeAll(data);\n    try writer.interface.flush();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 7,
        "chars": 252
      },
      {
        "index": 26,
        "start_line": 505,
        "end_line": 509,
        "code": "// \u274c 0.15+ compilation error\nconst stdout = std.fs.File.stdout();\nvar writer = stdout.writer();  // Missing buffer parameter!",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 3,
        "chars": 125
      },
      {
        "index": 27,
        "start_line": 513,
        "end_line": 520,
        "code": "// \u2705 0.15+ correct\nvar buf: [4096]u8 = undefined;\nvar writer = stdout.writer(&buf);  // Buffered\n\n// Or for unbuffered:\nvar writer = stdout.writer(&.{});  // Unbuffered",
        "file": "/home/jack/workspace/zig_guide/sections/05_io_streams/content.md",
        "lines": 6,
        "chars": 168
      }
    ]
  },
  {
    "chapter": "06_error_handling",
    "content_file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
    "total_blocks": 42,
    "runnable_blocks": 3,
    "snippet_blocks": 39,
    "runnable": [
      {
        "index": 16,
        "start_line": 280,
        "end_line": 342,
        "code": "const std = @import(\"std\");\n\n// Define custom error sets\nconst FileError = error{\n    AccessDenied,\n    NotFound,\n    InvalidFormat,\n};\n\nconst ParseError = error{\n    InvalidSyntax,\n    UnexpectedEOF,\n};\n\n// Error sets can be merged\nconst AllErrors = FileError || ParseError;\n\n// Function returning explicit error union\nfn openFile(path: []const u8) FileError!void {\n    if (std.mem.eql(u8, path, \"\")) {\n        return error.InvalidFormat;\n    }\n    if (std.mem.eql(u8, path, \"/forbidden\")) {\n        return error.AccessDenied;\n    }\n    if (std.mem.eql(u8, path, \"/missing\")) {\n        return error.NotFound;\n    }\n    std.debug.print(\"File opened: {s}\\n\", .{path});\n}\n\n// Function with inferred error set\nfn parseData(data: []const u8) !u32 {\n    if (data.len == 0) return error.UnexpectedEOF;\n    if (data[0] != '[') return error.InvalidSyntax;\n    return 42;\n}\n\npub fn main() !void {\n    // Using try - propagates error if it occurs\n    try openFile(\"/valid/path\");\n\n    // Using catch - provides default behavior on error\n    openFile(\"/forbidden\") catch {\n        std.debug.print(\"Access denied, using default behavior\\n\", .{});\n    };\n\n    // Capturing the error value\n    openFile(\"/missing\") catch |err| {\n        std.debug.print(\"Error occurred: {s}\\n\", .{@errorName(err)});\n    };\n\n    // Merged error sets\n    const merged_fn = struct {\n        fn process() AllErrors!void {\n            try openFile(\"/valid\");\n            _ = try parseData(\"[1]\");\n        }\n    }.process;\n    try merged_fn();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 61,
        "chars": 1508
      },
      {
        "index": 19,
        "start_line": 517,
        "end_line": 579,
        "code": "const std = @import(\"std\");\nconst testing = std.testing;\n\nfn createNestedStructure(allocator: std.mem.Allocator) !struct {\n    data: []u32,\n    metadata: []u8,\n} {\n    const data = try allocator.alloc(u32, 10);\n    errdefer allocator.free(data);\n\n    const metadata = try allocator.alloc(u8, 5);\n    errdefer allocator.free(metadata);\n\n    return .{ .data = data, .metadata = metadata };\n}\n\ntest \"errdefer cleanup on partial initialization\" {\n    var failing_allocator_state = testing.FailingAllocator.init(\n        testing.allocator,\n        .{ .fail_index = 1 },\n    );\n    const failing_alloc = failing_allocator_state.allocator();\n\n    const result = createNestedStructure(failing_alloc);\n    try testing.expectError(error.OutOfMemory, result);\n\n    // First allocation should have been cleaned up by errdefer\n    try testing.expectEqual(1, failing_allocator_state.allocations);\n    try testing.expectEqual(1, failing_allocator_state.deallocations);\n    try testing.expect(\n        failing_allocator_state.allocated_bytes == failing_allocator_state.freed_bytes\n    );\n}\n\ntest \"systematic error path testing\" {\n    // Test all possible error paths by failing at each allocation point\n    for (0..3) |fail_index| {\n        var failing_state = testing.FailingAllocator.init(\n            testing.allocator,\n            .{ .fail_index = fail_index },\n        );\n        const failing_alloc = failing_state.allocator();\n\n        _ = createNestedStructure(failing_alloc) catch |err| {\n            try testing.expectEqual(error.OutOfMemory, err);\n\n            // Verify no memory leaks occurred\n            try testing.expect(\n                failing_state.allocated_bytes == failing_state.freed_bytes\n            );\n            continue;\n        };\n\n        // If reached, allocation succeeded; clean up\n        const result = try createNestedStructure(failing_alloc);\n        defer {\n            failing_alloc.free(result.data);\n            failing_alloc.free(result.metadata);\n        }\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 61,
        "chars": 1993
      },
      {
        "index": 20,
        "start_line": 601,
        "end_line": 673,
        "code": "const std = @import(\"std\");\n\n// Graceful degradation on allocation failure\nfn processWithFallback(allocator: std.mem.Allocator, size: usize) ![]u8 {\n    const buffer = allocator.alloc(u8, size) catch |err| {\n        std.debug.print(\"Allocation of {d} bytes failed\\n\", .{size});\n\n        // Fall back to smaller allocation\n        const fallback_size = size / 2;\n        return allocator.alloc(u8, fallback_size) catch {\n            std.debug.print(\"Fallback also failed\\n\", .{});\n            return err;\n        };\n    };\n\n    return buffer;\n}\n\n// Container with complex cleanup\nconst Container = struct {\n    items: std.ArrayList([]const u8),\n    scratch: []u8,\n    allocator: std.mem.Allocator,\n\n    fn init(allocator: std.mem.Allocator) !Container {\n        var items = std.ArrayList([]const u8).init(allocator);\n        errdefer items.deinit();\n\n        const scratch = try allocator.alloc(u8, 1024);\n        errdefer allocator.free(scratch);\n\n        return Container{\n            .items = items,\n            .scratch = scratch,\n            .allocator = allocator,\n        };\n    }\n\n    fn deinit(self: *Container) void {\n        for (self.items.items) |item| {\n            self.allocator.free(item);\n        }\n        self.items.deinit();\n        self.allocator.free(self.scratch);\n    }\n\n    fn addItem(self: *Container, data: []const u8) !void {\n        const copy = try self.allocator.dupe(u8, data);\n        errdefer self.allocator.free(copy);\n\n        try self.items.append(copy);\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer {\n        const leaked = gpa.deinit();\n        if (leaked == .leak) {\n            std.debug.print(\"Memory leaked!\\n\", .{});\n        }\n    }\n    const allocator = gpa.allocator();\n\n    var container = try Container.init(allocator);\n    defer container.deinit();\n\n    try container.addItem(\"first\");\n    try container.addItem(\"second\");\n    try container.addItem(\"third\");\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 71,
        "chars": 1961
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 23,
        "end_line": 29,
        "code": "const FileError = error{\n    AccessDenied,\n    NotFound,\n    InvalidFormat,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 5,
        "chars": 78
      },
      {
        "index": 2,
        "start_line": 33,
        "end_line": 40,
        "code": "const ParseError = error{\n    InvalidSyntax,\n    UnexpectedEOF,\n};\n\nconst AllErrors = FileError || ParseError;",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 6,
        "chars": 110
      },
      {
        "index": 3,
        "start_line": 44,
        "end_line": 48,
        "code": "fn readFile(path: []const u8) FileError![]u8 {\n    // Returns either a FileError or []u8\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 3,
        "chars": 90
      },
      {
        "index": 4,
        "start_line": 52,
        "end_line": 58,
        "code": "fn parseData(data: []const u8) !u32 {\n    if (data.len == 0) return error.UnexpectedEOF;\n    if (data[0] != '[') return error.InvalidSyntax;\n    return 42;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 5,
        "chars": 157
      },
      {
        "index": 5,
        "start_line": 75,
        "end_line": 81,
        "code": "// Explicit form:\nconst result = operation() catch |err| return err;\n\n// Equivalent shorthand:\nconst result = try operation();",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 5,
        "chars": 126
      },
      {
        "index": 6,
        "start_line": 87,
        "end_line": 109,
        "code": "// Provide default value\nconst count = parseNumber(input) catch 0;\n\n// Capture and log error\nconst file = openFile(path) catch |err| {\n    log.err(\"Failed to open {s}: {s}\", .{path, @errorName(err)});\n    return err;\n};\n\n// Error-specific handling\nconst data = queryDatabase(id) catch |err| switch (err) {\n    error.Timeout => {\n        log.warn(\"Retrying after timeout\", .{});\n        return err;\n    },\n    error.QueryFailed => {\n        log.info(\"Using cached data\", .{});\n        return cached_data;\n    },\n    else => return err,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 21,
        "chars": 537
      },
      {
        "index": 7,
        "start_line": 115,
        "end_line": 120,
        "code": "const result = queryDatabase(id) catch |err| {\n    log.err(\"Database query failed for user {d}: {s}\", .{id, @errorName(err)});\n    return err; // Propagate with logged context\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 4,
        "chars": 178
      },
      {
        "index": 8,
        "start_line": 126,
        "end_line": 140,
        "code": "fn demonstrateDefer() void {\n    var r1 = Resource.init(1);\n    defer r1.deinit(); // Executes third (LIFO)\n\n    var r2 = Resource.init(2);\n    defer r2.deinit(); // Executes second\n\n    var r3 = Resource.init(3);\n    defer r3.deinit(); // Executes first\n\n    // Do work...\n    // Cleanup happens in order: r3, r2, r1\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 13,
        "chars": 319
      },
      {
        "index": 9,
        "start_line": 146,
        "end_line": 153,
        "code": "// Preferred style from TIGER_STYLE.md:\nconst buffer = try allocator.alloc(u8, size);\ndefer allocator.free(buffer);\n\nconst metadata = try allocator.alloc(Metadata, count);\ndefer allocator.free(metadata);",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 6,
        "chars": 203
      },
      {
        "index": 10,
        "start_line": 161,
        "end_line": 174,
        "code": "fn allocateResource(allocator: Allocator) !Resource {\n    const buffer = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(buffer); // Only if subsequent errors occur\n\n    const metadata = try allocator.alloc(Metadata, 10);\n    errdefer allocator.free(metadata);\n\n    return Resource{\n        .buffer = buffer,\n        .metadata = metadata,\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 12,
        "chars": 358
      },
      {
        "index": 11,
        "start_line": 180,
        "end_line": 194,
        "code": "fn processData(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u8, 128);\n    errdefer allocator.free(buffer); // Cleanup if error occurs\n    defer allocator.free(buffer);     // Cleanup on success too\n\n    var resource = try Resource.init(allocator);\n    errdefer resource.deinit();\n    defer resource.deinit();\n\n    // Use resources...\n    // If error: errdefer runs, defer skipped\n    // If success: defer runs, errdefer skipped\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 13,
        "chars": 453
      },
      {
        "index": 12,
        "start_line": 202,
        "end_line": 210,
        "code": "// src/unicode/lut.zig:114-119\nconst stage1_owned = try stage1.toOwnedSlice(alloc);\nerrdefer alloc.free(stage1_owned);\nconst stage2_owned = try stage2.toOwnedSlice(alloc);\nerrdefer alloc.free(stage2_owned);\nconst stage3_owned = try stage3.toOwnedSlice(alloc);\nerrdefer alloc.free(stage3_owned);",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 7,
        "chars": 294
      },
      {
        "index": 13,
        "start_line": 229,
        "end_line": 236,
        "code": "// src/multiversion.zig:693\nerr: anyerror,\n\nfn handle_error(self: *MultiversionOS, result: anyerror) void {\n    // Generic error handling for multiple operation types\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 6,
        "chars": 168
      },
      {
        "index": 14,
        "start_line": 244,
        "end_line": 250,
        "code": "const buffer = allocator.alloc(u8, size) catch |err| {\n    log.err(\"Allocation failed: {s}\", .{@errorName(err)});\n    return err;\n};\ndefer allocator.free(buffer);",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 5,
        "chars": 162
      },
      {
        "index": 15,
        "start_line": 256,
        "end_line": 268,
        "code": "fn processWithArena(parent_allocator: Allocator) !void {\n    var arena = std.heap.ArenaAllocator.init(parent_allocator);\n    defer arena.deinit(); // Single cleanup for all allocations\n\n    const buffer1 = try arena.allocator().alloc(u8, 100);\n    const buffer2 = try arena.allocator().alloc(u32, 50);\n    const buffer3 = try arena.allocator().alloc(u64, 25);\n\n    // Use buffers...\n    // All freed automatically by arena.deinit()\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 11,
        "chars": 433
      },
      {
        "index": 17,
        "start_line": 359,
        "end_line": 416,
        "code": "const std = @import(\"std\");\n\nconst DatabaseError = error{\n    ConnectionFailed,\n    QueryFailed,\n    Timeout,\n};\n\nfn queryDatabase(id: u32) DatabaseError![]const u8 {\n    if (id == 0) return error.InvalidInput;\n    if (id > 1000) return error.QueryFailed;\n    return \"result\";\n}\n\n// Simple propagation\nfn getUserData(user_id: u32) ![]const u8 {\n    const data = try queryDatabase(user_id);\n    return data;\n}\n\n// Catching and adding context\nfn validateAndQuery(input: ?u32) ![]const u8 {\n    const id = input orelse {\n        std.debug.print(\"Validation failed: missing user ID\\n\", .{});\n        return error.MissingField;\n    };\n\n    const result = queryDatabase(id) catch |err| {\n        std.debug.print(\"Database query failed for user {d}: {s}\\n\",\n            .{id, @errorName(err)});\n        return err;\n    };\n\n    return result;\n}\n\n// Error-specific handling with switch\nfn processRequest(user_id: u32) !void {\n    const data = queryDatabase(user_id) catch |err| switch (err) {\n        error.ConnectionFailed => {\n            std.debug.print(\"Retrying after connection failure...\\n\", .{});\n            return err;\n        },\n        error.Timeout => {\n            std.debug.print(\"Request timed out, will retry later\\n\", .{});\n            return err;\n        },\n        error.QueryFailed => {\n            std.debug.print(\"Query failed, using cached data\\n\", .{});\n            return; // Recovered with fallback\n        },\n        else => return err,\n    };\n\n    std.debug.print(\"Received data: {s}\\n\", .{data});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 56,
        "chars": 1519
      },
      {
        "index": 18,
        "start_line": 431,
        "end_line": 500,
        "code": "const std = @import(\"std\");\n\nconst Resource = struct {\n    id: u32,\n    name: []const u8,\n\n    fn init(id: u32, name: []const u8) Resource {\n        std.debug.print(\"Resource {d} ({s}) initialized\\n\", .{id, name});\n        return Resource{ .id = id, .name = name };\n    }\n\n    fn deinit(self: *Resource) void {\n        std.debug.print(\"Resource {d} ({s}) cleaned up\\n\", .{self.id, self.name});\n    }\n};\n\n// Demonstrate defer - LIFO execution order\nfn demonstrateDefer() void {\n    var r1 = Resource.init(1, \"first\");\n    defer r1.deinit(); // Executes last (LIFO)\n\n    var r2 = Resource.init(2, \"second\");\n    defer r2.deinit(); // Executes second\n\n    var r3 = Resource.init(3, \"third\");\n    defer r3.deinit(); // Executes first\n\n    std.debug.print(\"All resources initialized\\n\", .{});\n    // Cleanup happens in reverse order: r3, r2, r1\n}\n\n// Demonstrate errdefer - only executes on error\nfn initializeWithErrorHandling(\n    allocator: std.mem.Allocator,\n    should_fail: bool,\n) ![]Resource {\n    var list = try allocator.alloc(Resource, 3);\n    errdefer allocator.free(list);\n\n    list[0] = Resource.init(10, \"alpha\");\n    errdefer list[0].deinit();\n\n    list[1] = Resource.init(11, \"beta\");\n    errdefer list[1].deinit();\n\n    if (should_fail) {\n        std.debug.print(\"Simulating failure...\\n\", .{});\n        return error.InitFailed;\n    }\n\n    list[2] = Resource.init(12, \"gamma\");\n    errdefer list[2].deinit();\n\n    return list;\n}\n\n// Both defer and errdefer\nfn complexCleanup(allocator: std.mem.Allocator) !void {\n    const buffer = try allocator.alloc(u8, 128);\n    errdefer allocator.free(buffer);\n    defer allocator.free(buffer);\n\n    var resource = Resource.init(20, \"complex\");\n    errdefer resource.deinit();\n    defer resource.deinit();\n\n    std.debug.print(\"Resources allocated successfully\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 68,
        "chars": 1823
      },
      {
        "index": 21,
        "start_line": 688,
        "end_line": 742,
        "code": "const Transaction = struct {\n    allocator: std.mem.Allocator,\n    operations: std.ArrayList(Operation),\n    committed: bool,\n\n    const Operation = struct {\n        id: u32,\n        data: []u8,\n    };\n\n    fn init(allocator: std.mem.Allocator) Transaction {\n        return Transaction{\n            .allocator = allocator,\n            .operations = std.ArrayList(Operation).init(allocator),\n            .committed = false,\n        };\n    }\n\n    fn deinit(self: *Transaction) void {\n        if (!self.committed) {\n            // Rollback - free all operations\n            std.debug.print(\"Rolling back {d} operations\\n\",\n                .{self.operations.items.len});\n            for (self.operations.items) |op| {\n                self.allocator.free(op.data);\n            }\n        }\n        self.operations.deinit();\n    }\n\n    fn addOperation(self: *Transaction, id: u32, size: usize) !void {\n        const data = try self.allocator.alloc(u8, size);\n        errdefer self.allocator.free(data);\n\n        const op = Operation{ .id = id, .data = data };\n        try self.operations.append(op);\n    }\n\n    fn commit(self: *Transaction) !void {\n        // Validate all operations\n        for (self.operations.items) |op| {\n            if (op.data.len == 0) return error.InvalidOperation;\n        }\n\n        self.committed = true;\n\n        // Clean up operation data\n        for (self.operations.items) |op| {\n            self.allocator.free(op.data);\n        }\n        self.operations.clearRetainingCapacity();\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 53,
        "chars": 1516
      },
      {
        "index": 22,
        "start_line": 757,
        "end_line": 764,
        "code": "fn createPair(allocator: Allocator) !Pair {\n    const first = try allocator.alloc(u8, 100);\n    const second = try allocator.alloc(u8, 200); // If this fails, first leaks!\n\n    return Pair{ .first = first, .second = second };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 6,
        "chars": 227
      },
      {
        "index": 23,
        "start_line": 768,
        "end_line": 778,
        "code": "fn createPair(allocator: Allocator) !Pair {\n    const first = try allocator.alloc(u8, 100);\n    errdefer allocator.free(first); // Cleanup if subsequent allocations fail\n\n    const second = try allocator.alloc(u8, 200);\n    errdefer allocator.free(second);\n\n    return Pair{ .first = first, .second = second };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 9,
        "chars": 312
      },
      {
        "index": 24,
        "start_line": 786,
        "end_line": 795,
        "code": "fn process(allocator: Allocator) !Result {\n    const buffer = try allocator.alloc(u8, 1024);\n    defer allocator.free(buffer); // Wrong! Frees even when returning buffer\n\n    // ... work that might fail ...\n\n    return Result{ .data = buffer }; // Buffer already scheduled for freeing!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 8,
        "chars": 287
      },
      {
        "index": 25,
        "start_line": 799,
        "end_line": 808,
        "code": "fn process(allocator: Allocator) !Result {\n    const buffer = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(buffer); // Only free on error\n\n    // ... work that might fail ...\n\n    return Result{ .data = buffer }; // Caller now owns buffer\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 8,
        "chars": 254
      },
      {
        "index": 26,
        "start_line": 812,
        "end_line": 821,
        "code": "fn process(allocator: Allocator) !void {\n    const buffer = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(buffer); // Free on error\n    defer allocator.free(buffer);     // Free on success\n\n    // ... work that might fail ...\n    // Buffer is always freed before function returns\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 8,
        "chars": 294
      },
      {
        "index": 27,
        "start_line": 827,
        "end_line": 834,
        "code": "fn loadFile(path: []const u8) ![]u8 {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close();\n\n    return try file.readToEndAlloc(allocator, 1024 * 1024);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 6,
        "chars": 179
      },
      {
        "index": 28,
        "start_line": 840,
        "end_line": 853,
        "code": "fn loadFile(path: []const u8) ![]u8 {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| {\n        log.err(\"Failed to open file '{s}': {s}\", .{path, @errorName(err)});\n        return err;\n    };\n    defer file.close();\n\n    return file.readToEndAlloc(allocator, 1024 * 1024) catch |err| {\n        log.err(\"Failed to read file '{s}': {s}\", .{path, @errorName(err)});\n        return err;\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 12,
        "chars": 405
      },
      {
        "index": 29,
        "start_line": 861,
        "end_line": 870,
        "code": "fn processAll(allocator: Allocator, items: []Item) !void {\n    for (items) |item| {\n        const buffer = try allocator.alloc(u8, item.size);\n        defer allocator.free(buffer); // Deferred until function exit, not loop iteration!\n\n        try processItem(buffer, item);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 8,
        "chars": 281
      },
      {
        "index": 30,
        "start_line": 876,
        "end_line": 889,
        "code": "fn processOne(allocator: Allocator, item: Item) !void {\n    const buffer = try allocator.alloc(u8, item.size);\n    defer allocator.free(buffer); // Now properly scoped\n\n    try processItem(buffer, item);\n}\n\nfn processAll(allocator: Allocator, items: []Item) !void {\n    for (items) |item| {\n        try processOne(allocator, item);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 12,
        "chars": 339
      },
      {
        "index": 31,
        "start_line": 893,
        "end_line": 904,
        "code": "fn processAll(allocator: Allocator, items: []Item) !void {\n    for (items) |item| {\n        const buffer = try allocator.alloc(u8, item.size);\n        errdefer allocator.free(buffer);\n\n        try processItem(buffer, item);\n\n        allocator.free(buffer); // Explicit cleanup within loop\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 10,
        "chars": 296
      },
      {
        "index": 32,
        "start_line": 910,
        "end_line": 920,
        "code": "fn createResource(allocator: Allocator) !Resource {\n    const data = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(data);\n\n    const metadata = try allocator.alloc(Metadata, 10);\n    errdefer allocator.free(metadata); // This errdefer is NEVER TESTED\n\n    return Resource{ .data = data, .metadata = metadata };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 9,
        "chars": 325
      },
      {
        "index": 33,
        "start_line": 926,
        "end_line": 946,
        "code": "test \"createResource handles allocation failure\" {\n    for (0..2) |fail_index| {\n        var failing_state = testing.FailingAllocator.init(\n            testing.allocator,\n            .{ .fail_index = fail_index },\n        );\n        const failing_alloc = failing_state.allocator();\n\n        _ = createResource(failing_alloc) catch |err| {\n            try testing.expectEqual(error.OutOfMemory, err);\n\n            // Verify no leaks\n            try testing.expect(\n                failing_state.allocated_bytes == failing_state.freed_bytes\n            );\n            continue;\n        };\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 19,
        "chars": 594
      },
      {
        "index": 34,
        "start_line": 969,
        "end_line": 978,
        "code": "// Assertion - programmer error, must never happen\nassert(index < array.len);\n\n// Error - operating error, must be handled\nconst file = std.fs.cwd().openFile(path, .{}) catch |err| {\n    log.err(\"Failed to open {s}: {s}\", .{path, @errorName(err)});\n    return err;\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 8,
        "chars": 267
      },
      {
        "index": 35,
        "start_line": 984,
        "end_line": 987,
        "code": "// src/io/linux.zig:1220\npub const TimeoutError = error{Canceled} || posix.UnexpectedError;",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 2,
        "chars": 91
      },
      {
        "index": 36,
        "start_line": 997,
        "end_line": 1007,
        "code": "fn writeData(data: []const u8) !void {\n    assert(validate(data)); // Pre-condition\n    try disk.write(data);\n}\n\nfn readData(buffer: []u8) !void {\n    try disk.read(buffer);\n    assert(validate(buffer)); // Post-condition\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 9,
        "chars": 223
      },
      {
        "index": 37,
        "start_line": 1015,
        "end_line": 1029,
        "code": "// src/unicode/lut.zig:114-125\nconst stage1_owned = try stage1.toOwnedSlice(alloc);\nerrdefer alloc.free(stage1_owned);\nconst stage2_owned = try stage2.toOwnedSlice(alloc);\nerrdefer alloc.free(stage2_owned);\nconst stage3_owned = try stage3.toOwnedSlice(alloc);\nerrdefer alloc.free(stage3_owned);\n\nreturn .{\n    .stage1 = stage1_owned,\n    .stage2 = stage2_owned,\n    .stage3 = stage3_owned,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 13,
        "chars": 392
      },
      {
        "index": 38,
        "start_line": 1035,
        "end_line": 1050,
        "code": "// src/config/RepeatableStringMap.zig:43-56\nconst key_copy = try alloc.dupeZ(u8, key);\nerrdefer alloc.free(key_copy);\n\nif (val.len == 0) {\n    _ = self.map.orderedRemove(key_copy);\n    alloc.free(key_copy);\n    return;\n}\n\nconst val_copy = try alloc.dupeZ(u8, val);\nerrdefer alloc.free(val_copy);\n\ntry self.map.put(alloc, key_copy, val_copy);",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 14,
        "chars": 341
      },
      {
        "index": 39,
        "start_line": 1056,
        "end_line": 1066,
        "code": "// src/config/RepeatableStringMap.zig:60-70\nerrdefer {\n    var it = map.iterator();\n    while (it.next()) |entry| {\n        alloc.free(entry.key_ptr.*);\n        alloc.free(entry.value_ptr.*);\n    }\n    map.deinit(alloc);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 9,
        "chars": 222
      },
      {
        "index": 40,
        "start_line": 1074,
        "end_line": 1080,
        "code": "// src/sys.zig:21-33\npub const E = platform_defs.E;\npub const UV_E = platform_defs.UV_E;\npub const S = platform_defs.S;\npub const SystemErrno = platform_defs.SystemErrno;",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 5,
        "chars": 170
      },
      {
        "index": 41,
        "start_line": 1086,
        "end_line": 1096,
        "code": "// src/StandaloneModuleGraph.zig:723-729\nvar macho_file = bun.macho.MachoFile.init(\n    bun.default_allocator,\n    input_result.bytes.items,\n    bytes.len,\n) catch |err| {\n    log.err(\"Failed to parse Mach-O file: {s}\", .{@errorName(err)});\n    return err;\n};",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 9,
        "chars": 259
      },
      {
        "index": 42,
        "start_line": 1104,
        "end_line": 1113,
        "code": "// src/translate_c.zig:144-161\ndefer allocator.free(file_path);\n\nconst args = try collectCFlgsFrom(allocator, config, diag);\ndefer argv.deinit(allocator);\n\nvar poller: std.io.Poller(PollerFifo) = .init();\ndefer poller.deinit();",
        "file": "/home/jack/workspace/zig_guide/sections/06_error_handling/content.md",
        "lines": 8,
        "chars": 227
      }
    ]
  },
  {
    "chapter": "07_async_concurrency",
    "content_file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
    "total_blocks": 53,
    "runnable_blocks": 1,
    "snippet_blocks": 52,
    "runnable": [
      {
        "index": 3,
        "start_line": 96,
        "end_line": 117,
        "code": "const std = @import(\"std\");\n\nfn workerThread(id: u32, iterations: u32) void {\n    std.debug.print(\"Worker {d} starting\\n\", .{id});\n\n    var sum: u64 = 0;\n    for (0..iterations) |i| {\n        sum += i;\n    }\n\n    std.debug.print(\"Worker {d} sum: {d}\\n\", .{id, sum});\n}\n\npub fn main() !void {\n    // Spawn thread with arguments\n    const thread = try std.Thread.spawn(.{}, workerThread, .{ 1, 1000 });\n\n    // Wait for completion (required!)\n    thread.join();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 20,
        "chars": 461
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 58,
        "end_line": 78,
        "code": "pub const Thread = struct {\n    /// Spawn a new thread\n    pub fn spawn(config: SpawnConfig, comptime f: anytype, args: anytype) SpawnError!Thread\n\n    /// Wait for thread completion and return result\n    pub fn join(self: Thread) ReturnType\n\n    /// Detach thread (runs independently)\n    pub fn detach(self: Thread) void\n\n    /// Yield CPU to other threads\n    pub fn yield() void\n\n    /// Sleep for specified nanoseconds\n    pub fn sleep(nanoseconds: u64) void\n\n    /// Get current thread ID\n    pub fn getCurrentId() Id\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 19,
        "chars": 526
      },
      {
        "index": 2,
        "start_line": 82,
        "end_line": 87,
        "code": "pub const SpawnConfig = struct {\n    stack_size: usize = default_stack_size,\n    allocator: ?std.mem.Allocator = null,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 4,
        "chars": 121
      },
      {
        "index": 4,
        "start_line": 121,
        "end_line": 135,
        "code": "var threads: [4]std.Thread = undefined;\n\n// Spawn workers\nfor (&threads, 0..) |*thread, i| {\n    thread.* = try std.Thread.spawn(.{}, workerThread, .{\n        @as(u32, @intCast(i)), 500\n    });\n}\n\n// Join all\nfor (threads) |thread| {\n    thread.join();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 13,
        "chars": 254
      },
      {
        "index": 5,
        "start_line": 141,
        "end_line": 166,
        "code": "const WorkerData = struct {\n    id: u32,\n    message: []const u8,\n    result: *u32,  // Shared state (needs synchronization)\n\n    fn run(self: WorkerData) void {\n        std.debug.print(\"{s}\\n\", .{self.message});\n        self.result.* = self.id * 10;\n    }\n};\n\npub fn example() !void {\n    var result: u32 = 0;\n    const data = WorkerData{\n        .id = 42,\n        .message = \"Processing...\",\n        .result = &result,\n    };\n\n    const thread = try std.Thread.spawn(.{}, WorkerData.run, .{data});\n    thread.join();\n\n    std.debug.print(\"Result: {d}\\n\", .{result});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 24,
        "chars": 570
      },
      {
        "index": 6,
        "start_line": 170,
        "end_line": 177,
        "code": "// Get current thread ID\nconst thread_id = std.Thread.getCurrentId();\n\n// Get available CPU cores\nconst cpu_count = try std.Thread.getCpuCount();\nstd.debug.print(\"CPU cores: {d}\\n\", .{cpu_count});",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 6,
        "chars": 196
      },
      {
        "index": 7,
        "start_line": 193,
        "end_line": 204,
        "code": "const Impl = if (builtin.mode == .Debug and !builtin.single_threaded)\n    DebugImpl      // Detects deadlocks\nelse if (builtin.single_threaded)\n    SingleThreadedImpl  // No-op\nelse if (builtin.os.tag == .windows)\n    WindowsImpl    // SRWLOCK\nelse if (builtin.os.tag.isDarwin())\n    DarwinImpl     // os_unfair_lock (priority inheritance)\nelse\n    FutexImpl;     // Linux futex",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 10,
        "chars": 378
      },
      {
        "index": 8,
        "start_line": 210,
        "end_line": 224,
        "code": "const DebugImpl = struct {\n    locking_thread: std.atomic.Value(Thread.Id),\n    impl: ReleaseImpl,\n\n    fn lock(self: *@This()) void {\n        const current_id = Thread.getCurrentId();\n        if (self.locking_thread.load(.unordered) == current_id) {\n            @panic(\"Deadlock detected\");  // Same thread trying to lock twice\n        }\n        self.impl.lock();\n        self.locking_thread.store(current_id, .unordered);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 13,
        "chars": 432
      },
      {
        "index": 9,
        "start_line": 228,
        "end_line": 232,
        "code": "pub fn lock(self: *Mutex) void       // Block until acquired\npub fn tryLock(self: *Mutex) bool    // Non-blocking attempt\npub fn unlock(self: *Mutex) void     // Release lock",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 3,
        "chars": 174
      },
      {
        "index": 10,
        "start_line": 236,
        "end_line": 254,
        "code": "const SharedCounter = struct {\n    mutex: std.Thread.Mutex = .{},\n    value: u32 = 0,\n\n    fn increment(self: *SharedCounter) void {\n        self.mutex.lock();\n        defer self.mutex.unlock();  // Always unlocks, even on early return\n\n        self.value += 1;\n    }\n\n    fn getValue(self: *SharedCounter) u32 {\n        self.mutex.lock();\n        defer self.mutex.unlock();\n        return self.value;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 17,
        "chars": 410
      },
      {
        "index": 11,
        "start_line": 260,
        "end_line": 269,
        "code": "// src/clients/c/tb_client/context.zig:62-83\npub fn submit(client: *ClientInterface, packet: *Packet.Extern) Error!void {\n    client.locker.lock();\n    defer client.locker.unlock();\n\n    const context = client.context.ptr orelse return Error.ClientInvalid;\n    client.vtable.ptr.submit_fn(context, packet);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 8,
        "chars": 308
      },
      {
        "index": 12,
        "start_line": 285,
        "end_line": 295,
        "code": "// Writer operations\npub fn lock(rwl: *RwLock) void          // Exclusive access\npub fn tryLock(rwl: *RwLock) bool\npub fn unlock(rwl: *RwLock) void\n\n// Reader operations\npub fn lockShared(rwl: *RwLock) void    // Shared access\npub fn tryLockShared(rwl: *RwLock) bool\npub fn unlockShared(rwl: *RwLock) void",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 9,
        "chars": 305
      },
      {
        "index": 13,
        "start_line": 299,
        "end_line": 322,
        "code": "const Document = struct {\n    lock: std.Thread.RwLock = .{},\n    content: []const u8,\n    version: u32 = 0,\n\n    // Many readers can access simultaneously\n    fn read(self: *Document) []const u8 {\n        self.lock.lockShared();\n        defer self.lock.unlockShared();\n        return self.content;\n    }\n\n    // Writers require exclusive access\n    fn update(self: *Document, new_content: []const u8) !void {\n        self.lock.lock();\n        defer self.lock.unlock();\n\n        // Safe to modify: no readers or writers\n        self.content = new_content;\n        self.version += 1;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 22,
        "chars": 590
      },
      {
        "index": 14,
        "start_line": 328,
        "end_line": 348,
        "code": "// src/DocumentStore.zig:23\nconst DocumentStore = struct {\n    lock: std.Thread.RwLock = .{},\n    handles: Uri.ArrayHashMap(*Handle),\n\n    pub fn getHandle(self: *DocumentStore, uri: Uri) ?*Handle {\n        self.lock.lockShared();\n        defer self.lock.unlockShared();\n        return self.handles.get(uri);\n    }\n\n    pub fn createHandle(self: *DocumentStore, uri: Uri) !*Handle {\n        self.lock.lock();\n        defer self.lock.unlock();\n        const handle = try self.allocator.create(Handle);\n        try self.handles.put(uri, handle);\n        return handle;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 19,
        "chars": 575
      },
      {
        "index": 15,
        "start_line": 367,
        "end_line": 373,
        "code": "pub const Condition = struct {\n    pub fn wait(cond: *Condition, mutex: *Mutex) void\n    pub fn signal(cond: *Condition) void      // Wake one waiter\n    pub fn broadcast(cond: *Condition) void   // Wake all waiters\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 5,
        "chars": 218
      },
      {
        "index": 16,
        "start_line": 377,
        "end_line": 410,
        "code": "var mutex = std.Thread.Mutex{};\nvar condition = std.Thread.Condition{};\nvar queue = std.ArrayList(T).init(allocator);\n\nfn producer() void {\n    while (true) {\n        const item = produceItem();\n\n        mutex.lock();\n        defer mutex.unlock();\n\n        queue.append(item) catch unreachable;\n        condition.signal();  // Wake one consumer\n    }\n}\n\nfn consumer() void {\n    while (true) {\n        mutex.lock();\n        defer mutex.unlock();\n\n        // Wait while queue is empty\n        while (queue.items.len == 0) {\n            condition.wait(&mutex);  // Atomically unlock and sleep\n        }\n\n        const item = queue.orderedRemove(0);\n        mutex.unlock();  // Release lock during processing\n\n        processItem(item);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 32,
        "chars": 741
      },
      {
        "index": 17,
        "start_line": 422,
        "end_line": 435,
        "code": "pub fn Value(comptime T: type) type {\n    return struct {\n        pub fn init(value: T) @This()\n        pub fn load(self: *const @This(), ordering: Ordering) T\n        pub fn store(self: *@This(), value: T, ordering: Ordering) void\n        pub fn swap(self: *@This(), value: T, ordering: Ordering) T\n        pub fn cmpxchg(self: *@This(), expected: T, new: T,\n                       success: Ordering, failure: Ordering) ?T\n        pub fn fetchAdd(self: *@This(), operand: T, ordering: Ordering) T\n        pub fn fetchSub(self: *@This(), operand: T, ordering: Ordering) T\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 12,
        "chars": 580
      },
      {
        "index": 18,
        "start_line": 446,
        "end_line": 458,
        "code": "const AtomicCounter = struct {\n    value: std.atomic.Value(u32) = std.atomic.Value(u32).init(0),\n\n    fn increment(self: *AtomicCounter) void {\n        _ = self.value.fetchAdd(1, .monotonic);\n    }\n\n    fn getValue(self: *const AtomicCounter) u32 {\n        return self.value.load(.monotonic);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 11,
        "chars": 301
      },
      {
        "index": 19,
        "start_line": 495,
        "end_line": 510,
        "code": "var data: u32 = undefined;\nvar ready = std.atomic.Value(bool).init(false);\n\n// Producer thread\nfn producer() void {\n    data = 42;                      // (1) Normal store\n    ready.store(true, .release);    // (2) Release: makes (1) visible\n}\n\n// Consumer thread\nfn consumer() void {\n    while (!ready.load(.acquire)) {}  // (3) Acquire: synchronizes with (2)\n    const value = data;                // (4) Guaranteed to see 42\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 14,
        "chars": 429
      },
      {
        "index": 20,
        "start_line": 520,
        "end_line": 531,
        "code": "var value = std.atomic.Value(u32).init(100);\n\n// Try to change 100 \u2192 200\nconst result = value.cmpxchgStrong(100, 200, .seq_cst, .seq_cst);\nif (result == null) {\n    // Success: value was 100, now 200\n} else {\n    // Failure: value was not 100, result contains actual value\n    std.debug.print(\"CAS failed, actual: {d}\\n\", .{result.?});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 10,
        "chars": 337
      },
      {
        "index": 21,
        "start_line": 537,
        "end_line": 545,
        "code": "// src/threading/ThreadPool.zig:374-379\nsync = @bitCast(self.sync.cmpxchgWeak(\n    @as(u32, @bitCast(sync)),\n    @as(u32, @bitCast(new_sync)),\n    .release,    // Success: publish state change\n    .monotonic,  // Failure: just reload\n) orelse { ... });",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 7,
        "chars": 252
      },
      {
        "index": 22,
        "start_line": 553,
        "end_line": 574,
        "code": "// src/clients/c/tb_client/signal.zig:87-107\npub fn notify(self: *Signal) void {\n    var state: @TypeOf(self.event_state.raw) = .waiting;\n    while (self.event_state.cmpxchgStrong(\n        state,\n        .notified,\n        .release,  // Publish notification\n        .acquire,  // Reload current state\n    )) |state_actual| {\n        switch (state_actual) {\n            .waiting, .running => state = state_actual,\n            .notified => return,  // Already notified\n            .shutdown => return,  // Ignore after shutdown\n        }\n    }\n\n    if (state == .waiting) {\n        self.io.event_trigger(self.event, &self.completion);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 20,
        "chars": 640
      },
      {
        "index": 23,
        "start_line": 595,
        "end_line": 608,
        "code": "pub const Pool = struct {\n    pub fn init(options: InitOptions) Allocator.Error!Pool\n    pub fn deinit(self: *Pool) void\n    pub fn spawnWg(self: *Pool, wait_group: *WaitGroup,\n                   comptime func: anytype, args: anytype) void\n    pub fn waitAndWork(self: *Pool, wait_group: *WaitGroup) void\n};\n\npub const InitOptions = struct {\n    allocator: Allocator,\n    n_jobs: ?u32 = null,  // Defaults to CPU count\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 12,
        "chars": 421
      },
      {
        "index": 24,
        "start_line": 612,
        "end_line": 632,
        "code": "var pool: std.Thread.Pool = undefined;\ntry pool.init(.{ .allocator = allocator });\ndefer pool.deinit();\n\nvar wait_group: std.Thread.WaitGroup = .{};\n\n// Task function\nfn processTask(task_id: usize) void {\n    std.debug.print(\"Processing task {d}\\n\", .{task_id});\n    // ... do work\n}\n\n// Spawn tasks\nfor (0..10) |i| {\n    pool.spawnWg(&wait_group, processTask, .{i});\n}\n\n// Wait for all tasks to complete\npool.waitAndWork(&wait_group);",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 19,
        "chars": 435
      },
      {
        "index": 25,
        "start_line": 636,
        "end_line": 653,
        "code": "var counter = std.atomic.Value(u32).init(0);\n\nfn increment(c: *std.atomic.Value(u32), iterations: u32) void {\n    for (0..iterations) |_| {\n        _ = c.fetchAdd(1, .monotonic);\n    }\n}\n\n// Spawn workers\nfor (0..num_workers) |_| {\n    pool.spawnWg(&wait_group, increment, .{ &counter, 1000 });\n}\n\npool.waitAndWork(&wait_group);\n\nstd.debug.print(\"Final count: {d}\\n\", .{counter.load(.monotonic)});",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 16,
        "chars": 397
      },
      {
        "index": 26,
        "start_line": 663,
        "end_line": 695,
        "code": "// src/threading/ThreadPool.zig:1-82\nconst ThreadPool = @This();\n\n// Configuration\nsleep_on_idle_network_thread: bool = true,\nstack_size: u32,\nmax_threads: u32,\n\n// State (packed atomic for cache efficiency)\nsync: Atomic(u32) = .init(@as(u32, @bitCast(Sync{}))),\n\n// Synchronization\nidle_event: Event = .{},\njoin_event: Event = .{},\n\n// Work queues\nrun_queue: Node.Queue = .{},         // Global MPMC queue\nthreads: Atomic(?*Thread) = .init(null),  // Thread stack\n\nconst Sync = packed struct {\n    idle: u14 = 0,        // Idle threads\n    spawned: u14 = 0,     // Total threads\n    unused: bool = false,\n    notified: bool = false,\n    state: enum(u2) {\n        pending = 0,\n        signaled,\n        waking,\n        shutdown,\n    } = .pending,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 31,
        "chars": 749
      },
      {
        "index": 27,
        "start_line": 706,
        "end_line": 743,
        "code": "// src/threading/ThreadPool.zig:600-644\npub fn pop(self: *Thread, thread_pool: *ThreadPool) ?Node.Buffer.Stole {\n    // 1. Local buffer (L1 cache)\n    if (self.run_buffer.pop()) |node| {\n        return .{ .node = node, .pushed = false };\n    }\n\n    // 2. Local queue\n    if (self.run_buffer.consume(&self.run_queue)) |stole| {\n        return stole;\n    }\n\n    // 3. Global queue\n    if (self.run_buffer.consume(&thread_pool.run_queue)) |stole| {\n        return stole;\n    }\n\n    // 4. Work stealing from other threads\n    var num_threads = @as(Sync, @bitCast(thread_pool.sync.load(.monotonic))).spawned;\n    while (num_threads > 0) : (num_threads -= 1) {\n        const target = self.target orelse thread_pool.threads.load(.acquire) orelse break;\n        self.target = target.next;\n\n        if (self.run_buffer.consume(&target.run_queue)) |stole| {\n            return stole;\n        }\n\n        if (target == self) continue;\n\n        if (self.run_buffer.steal(&target.run_buffer)) |stole| {\n            return stole;\n        }\n    }\n\n    return null;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 36,
        "chars": 1050
      },
      {
        "index": 28,
        "start_line": 751,
        "end_line": 773,
        "code": "// src/threading/ThreadPool.zig:156-229\npub fn each(\n    this: *ThreadPool,\n    allocator: std.mem.Allocator,\n    ctx: anytype,\n    comptime run_fn: anytype,\n    values: anytype,\n) !void {\n    // Spawns one task per value, distributes across thread pool\n    // Waits for all to complete\n}\n\n// Usage:\nconst Context = struct {\n    fn process(ctx: *Context, value: *Item, index: usize) void {\n        // Process item\n    }\n};\n\nvar ctx = Context{};\ntry thread_pool.each(allocator, &ctx, Context.process, items);",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 21,
        "chars": 507
      },
      {
        "index": 29,
        "start_line": 781,
        "end_line": 802,
        "code": "// src/work_pool.zig:4-30\npub const WorkPool = struct {\n    var pool: ThreadPool = undefined;\n\n    var createOnce = bun.once(\n        struct {\n            pub fn create() void {\n                pool = ThreadPool.init(.{\n                    .max_threads = bun.getThreadCount(),\n                    .stack_size = ThreadPool.default_thread_stack_size,\n                });\n            }\n        }.create,\n    );\n\n    pub inline fn get() *ThreadPool {\n        createOnce.call(.{});\n        return &pool;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 20,
        "chars": 507
      },
      {
        "index": 30,
        "start_line": 866,
        "end_line": 873,
        "code": ".dependencies = .{\n    .libxev = .{\n        .url = \"https://github.com/mitchellh/libxev/archive/<commit>.tar.gz\",\n        .hash = \"<hash>\",\n    },\n},",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 6,
        "chars": 149
      },
      {
        "index": 31,
        "start_line": 877,
        "end_line": 888,
        "code": "const xev = @import(\"xev\");\n\n// Initialize event loop\nvar loop = try xev.Loop.init(.{});\ndefer loop.deinit();\n\n// Run modes:\ntry loop.run(.no_wait);      // Poll once and return\ntry loop.run(.once);          // Wait for one event\ntry loop.run(.until_done);    // Run until all completions finished",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 10,
        "chars": 297
      },
      {
        "index": 32,
        "start_line": 894,
        "end_line": 906,
        "code": "pub const Completion = struct {\n    userdata: ?*anyopaque = null,  // User state\n    callback: *const CallbackFn,    // Result handler\n};\n\npub const CallbackFn = fn (\n    userdata: ?*anyopaque,\n    loop: *xev.Loop,\n    completion: *xev.Completion,\n    result: Result,\n) xev.CallbackAction;",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 11,
        "chars": 289
      },
      {
        "index": 33,
        "start_line": 910,
        "end_line": 940,
        "code": "fn timerCallback(\n    userdata: ?*anyopaque,\n    loop: *xev.Loop,\n    c: *xev.Completion,\n    result: xev.Timer.RunError!void,\n) xev.CallbackAction {\n    _ = userdata;\n    _ = loop;\n    _ = c;\n    _ = result catch unreachable;\n\n    std.debug.print(\"Timer fired!\\n\", .{});\n    return .disarm;  // Remove from event loop\n}\n\npub fn main() !void {\n    var loop = try xev.Loop.init(.{});\n    defer loop.deinit();\n\n    var timer = try xev.Timer.init();\n    defer timer.deinit();\n\n    var completion: xev.Completion = .{\n        .callback = timerCallback,\n    };\n\n    timer.run(&loop, &completion, 1000, .{});  // 1000ms\n    try loop.run(.until_done);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 29,
        "chars": 646
      },
      {
        "index": 34,
        "start_line": 970,
        "end_line": 983,
        "code": "// \u274c BAD: Blocks entire event loop\nfn badCallback(...) xev.CallbackAction {\n    std.Thread.sleep(5 * std.time.ns_per_s);  // \u274c Blocks all I/O!\n    expensive_computation();                   // \u274c Blocks all I/O!\n    return .disarm;\n}\n\n// \u2713 GOOD: Offload to thread pool\nfn goodCallback(...) xev.CallbackAction {\n    thread_pool.spawn(expensive_computation, .{});\n    return .disarm;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 12,
        "chars": 382
      },
      {
        "index": 35,
        "start_line": 1004,
        "end_line": 1013,
        "code": "// 0.14.x - DO NOT USE IN 0.15+\nfn asyncFunction() callconv(.async) !void {\n    const result = await otherAsyncFunction();\n    // ...\n}\n\nvar frame = async asyncFunction();\nconst result = await frame;",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 8,
        "chars": 199
      },
      {
        "index": 36,
        "start_line": 1048,
        "end_line": 1065,
        "code": "// Spawn with arguments\nconst thread = try std.Thread.spawn(.{}, workerThread, .{ 1, 1000 });\nthread.join();\n\n// Multiple threads\nvar threads: [3]std.Thread = undefined;\nfor (&threads, 0..) |*thread, i| {\n    thread.* = try std.Thread.spawn(.{}, workerThread, .{@intCast(i), 500});\n}\nfor (threads) |thread| {\n    thread.join();\n}\n\n// Detached thread\nconst thread = try std.Thread.spawn(.{}, workerThread, .{ 777, 50 });\nthread.detach();  // Runs independently, cleans up automatically",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 16,
        "chars": 484
      },
      {
        "index": 37,
        "start_line": 1088,
        "end_line": 1116,
        "code": "// Mutex pattern\nconst SharedCounter = struct {\n    mutex: std.Thread.Mutex = .{},\n    value: u32 = 0,\n\n    fn increment(self: *SharedCounter) void {\n        self.mutex.lock();\n        defer self.mutex.unlock();\n        self.value += 1;\n    }\n};\n\n// Atomic pattern\nconst AtomicCounter = struct {\n    value: std.atomic.Value(u32) = .init(0),\n\n    fn increment(self: *AtomicCounter) void {\n        _ = self.value.fetchAdd(1, .monotonic);\n    }\n};\n\n// Memory ordering\ndata.store(42, .monotonic);\nflag.store(true, .release);  // Publish data\n\nwhile (!flag.load(.acquire)) {}  // Synchronize\nconst value = data.load(.monotonic);  // Guaranteed to see 42",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 27,
        "chars": 648
      },
      {
        "index": 38,
        "start_line": 1138,
        "end_line": 1152,
        "code": "var pool: std.Thread.Pool = undefined;\ntry pool.init(.{ .allocator = allocator });\ndefer pool.deinit();\n\nvar wait_group: std.Thread.WaitGroup = .{};\n\n// Spawn tasks\nfor (0..10) |i| {\n    pool.spawnWg(&wait_group, processTask, .{i});\n}\n\n// Wait for completion\npool.waitAndWork(&wait_group);",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 13,
        "chars": 289
      },
      {
        "index": 39,
        "start_line": 1175,
        "end_line": 1193,
        "code": "// Basic timing\nvar timer = try std.time.Timer.start();\nexpensiveOperation();\nconst elapsed = timer.read();  // nanoseconds\n\n// Prevent optimization\nstd.mem.doNotOptimizeAway(&result);\n\n// Lap measurements\nconst phase1 = timer.lap();\noperation1();\nconst phase2 = timer.lap();\noperation2();\n\n// Throughput\nconst elapsed_s = @as(f64, @floatFromInt(elapsed)) / std.time.ns_per_s;\nconst throughput_mb = data_size_mb / elapsed_s;",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 17,
        "chars": 424
      },
      {
        "index": 40,
        "start_line": 1226,
        "end_line": 1232,
        "code": "// \u274c BAD: Resource leak\nfn processData(data: []const u8) void {\n    _ = std.Thread.spawn(.{}, worker, .{data}) catch unreachable;\n    // Thread handle lost! Leaks 16 MiB stack memory + thread descriptor\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 5,
        "chars": 204
      },
      {
        "index": 41,
        "start_line": 1241,
        "end_line": 1253,
        "code": "// \u2713 GOOD: Always join or detach\nfn processData(data: []const u8) !void {\n    const thread = try std.Thread.spawn(.{}, worker, .{data});\n    thread.join();  // Wait for completion\n}\n\n// OR detach if fire-and-forget is intended\nfn processDataAsync(data: []const u8) !void {\n    const thread = try std.Thread.spawn(.{}, worker, .{data});\n    thread.detach();  // Explicitly allow independent execution\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 11,
        "chars": 401
      },
      {
        "index": 42,
        "start_line": 1259,
        "end_line": 1264,
        "code": "test \"thread leak\" {\n    _ = std.Thread.spawn(.{}, worker, .{}) catch unreachable;\n    // Test framework will fail: thread not joined\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 4,
        "chars": 135
      },
      {
        "index": 43,
        "start_line": 1270,
        "end_line": 1285,
        "code": "// \u274c BAD: Race condition\nvar counter: u64 = 0;\n\nfn increment() void {\n    counter += 1;  // NOT ATOMIC! Compiles to: load, add, store\n}\n\npub fn main() !void {\n    const t1 = try std.Thread.spawn(.{}, increment, .{});\n    const t2 = try std.Thread.spawn(.{}, increment, .{});\n    t1.join();\n    t2.join();\n    std.debug.print(\"Counter: {}\\n\", .{counter});  // Could be 1, not 2!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 14,
        "chars": 379
      },
      {
        "index": 44,
        "start_line": 1311,
        "end_line": 1318,
        "code": "// \u2713 GOOD: Lock-free atomic\nvar counter = std.atomic.Value(u64).init(0);\n\nfn increment() void {\n    _ = counter.fetchAdd(1, .monotonic);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 6,
        "chars": 138
      },
      {
        "index": 45,
        "start_line": 1322,
        "end_line": 1332,
        "code": "// \u2713 GOOD: Mutex for complex updates\nvar counter: u64 = 0;\nvar mutex = std.Thread.Mutex{};\n\nfn increment() void {\n    mutex.lock();\n    defer mutex.unlock();\n    counter += 1;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 9,
        "chars": 177
      },
      {
        "index": 46,
        "start_line": 1348,
        "end_line": 1368,
        "code": "// \u274c BAD: Inconsistent lock ordering\nvar mutex_a = std.Thread.Mutex{};\nvar mutex_b = std.Thread.Mutex{};\n\nfn thread1() void {\n    mutex_a.lock();\n    std.time.sleep(1 * std.time.ns_per_ms);  // Simulate work\n    mutex_b.lock();  // \u2190 Deadlock here!\n    defer mutex_b.unlock();\n    defer mutex_a.unlock();\n}\n\nfn thread2() void {\n    mutex_b.lock();  // \u2190 Opposite order!\n    std.time.sleep(1 * std.time.ns_per_ms);\n    mutex_a.lock();  // \u2190 Deadlock here!\n    defer mutex_a.unlock();\n    defer mutex_b.unlock();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 19,
        "chars": 512
      },
      {
        "index": 47,
        "start_line": 1384,
        "end_line": 1401,
        "code": "// \u2713 GOOD: Always acquire locks in same order\nfn thread1() void {\n    mutex_a.lock();  // Always A first\n    defer mutex_a.unlock();\n    mutex_b.lock();  // Then B\n    defer mutex_b.unlock();\n    // ... critical section\n}\n\nfn thread2() void {\n    mutex_a.lock();  // Same order: A first\n    defer mutex_a.unlock();\n    mutex_b.lock();  // Then B\n    defer mutex_b.unlock();\n    // ... critical section\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 16,
        "chars": 403
      },
      {
        "index": 48,
        "start_line": 1407,
        "end_line": 1414,
        "code": "// Lock hierarchy (enforced by convention):\n// 1. resource_lock\n// 2. state_lock\n// 3. cache_lock\n\n// All code must acquire locks in this order",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 6,
        "chars": 143
      },
      {
        "index": 49,
        "start_line": 1420,
        "end_line": 1425,
        "code": "var mutex = std.Thread.Mutex{};\n\nmutex.lock();\nmutex.lock();  // Panic: \"Deadlock detected\"",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 4,
        "chars": 91
      },
      {
        "index": 50,
        "start_line": 1436,
        "end_line": 1452,
        "code": "// \u274c BAD: Memory ordering violation\nvar data: u32 = 0;\nvar ready = std.atomic.Value(bool).init(false);\n\n// Writer\nfn writer() void {\n    data = 42;\n    ready.store(true, .monotonic);  // \u274c Does not publish data!\n}\n\n// Reader\nfn reader() void {\n    while (!ready.load(.monotonic)) {}  // \u274c Does not synchronize!\n    const value = data;  // May see 0, not 42!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 15,
        "chars": 359
      },
      {
        "index": 51,
        "start_line": 1460,
        "end_line": 1471,
        "code": "// \u2713 GOOD: Proper synchronization\nfn writer() void {\n    data = 42;\n    ready.store(true, .release);  // Publish data\n}\n\nfn reader() void {\n    while (!ready.load(.acquire)) {}  // Synchronize with writer\n    const value = data;  // Guaranteed to see 42\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 10,
        "chars": 255
      },
      {
        "index": 52,
        "start_line": 1487,
        "end_line": 1503,
        "code": "// \u274c BAD: Blocks entire event loop\nfn httpRequestCallback(\n    userdata: ?*anyopaque,\n    loop: *xev.Loop,\n    completion: *xev.Completion,\n    result: anyerror!usize,\n) xev.CallbackAction {\n    const bytes = result catch return .disarm;\n\n    // \u274c This blocks ALL other I/O operations!\n    const processed = processImage(bytes);  // Takes 100ms\n\n    sendResponse(processed);\n    return .disarm;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 15,
        "chars": 396
      },
      {
        "index": 53,
        "start_line": 1520,
        "end_line": 1539,
        "code": "// \u2713 GOOD: Offload CPU work\nfn httpRequestCallback(...) xev.CallbackAction {\n    const bytes = result catch return .disarm;\n\n    // Queue work to thread pool\n    const task = allocator.create(ProcessTask) catch return .disarm;\n    task.* = .{ .data = bytes, .loop = loop };\n    thread_pool.spawn(processInBackground, .{task});\n\n    return .disarm;\n}\n\nfn processInBackground(task: *ProcessTask) void {\n    const processed = processImage(task.data);  // Runs on thread pool\n\n    // Post result back to event loop\n    task.loop.notify(.{ .callback = sendResponseCallback, .data = processed });\n}",
        "file": "/home/jack/workspace/zig_guide/sections/07_async_concurrency/content.md",
        "lines": 18,
        "chars": 592
      }
    ]
  },
  {
    "chapter": "08_build_system",
    "content_file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
    "total_blocks": 30,
    "runnable_blocks": 3,
    "snippet_blocks": 27,
    "runnable": [
      {
        "index": 5,
        "start_line": 134,
        "end_line": 142,
        "code": "const build_options = @import(\"build_options\");\n\npub fn main() void {\n    if (build_options.enable_logging) {\n        std.log.info(\"Version: {s}\", .{build_options.version});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 7,
        "chars": 181
      },
      {
        "index": 10,
        "start_line": 323,
        "end_line": 335,
        "code": "const std = @import(\"std\");\nconst build_options = @import(\"build_options\");\n\npub fn main() void {\n    std.debug.print(\"Server version: {s}\\n\", .{build_options.version});\n    std.debug.print(\"Max connections: {}\\n\", .{build_options.max_connections});\n\n    if (build_options.enable_logging) {\n        std.debug.print(\"[DEBUG] Logging enabled\\n\", .{});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 11,
        "chars": 357
      },
      {
        "index": 12,
        "start_line": 398,
        "end_line": 431,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    var args = try std.process.argsWithAllocator(allocator);\n    defer args.deinit();\n    _ = args.skip(); // program name\n\n    var output_path: ?[]const u8 = null;\n    while (args.next()) |arg| {\n        if (std.mem.eql(u8, arg, \"--output\")) {\n            output_path = args.next();\n        }\n    }\n\n    const path = output_path orelse return error.MissingOutputPath;\n\n    const code =\n        \\\\// Auto-generated file - do not edit\n        \\\\pub const magic_number: u32 = 42;\n        \\\\pub const greeting = \"Hello from generated code!\";\n        \\\\\n    ;\n\n    const file = try std.fs.cwd().createFile(path, .{});\n    defer file.close();\n\n    try file.writeAll(code);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 32,
        "chars": 843
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 15,
        "end_line": 32,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 16,
        "chars": 436
      },
      {
        "index": 2,
        "start_line": 73,
        "end_line": 90,
        "code": "// Public module for library users\nconst lib_mod = b.addModule(\"mathlib\", .{\n    .root_source_file = b.path(\"src/lib.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\n\n// Internal module for executable\nconst exe_mod = b.createModule(.{\n    .root_source_file = b.path(\"src/main.zig\"),\n    .target = target,\n    .optimize = optimize,\n    .imports = &.{\n        .{ .name = \"mathlib\", .module = lib_mod },\n    },\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 16,
        "chars": 421
      },
      {
        "index": 3,
        "start_line": 110,
        "end_line": 114,
        "code": "const run_step = b.step(\"run\", \"Run the application\");\nconst run_cmd = b.addRunArtifact(exe);\nrun_step.dependOn(&run_cmd.step);",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 3,
        "chars": 127
      },
      {
        "index": 4,
        "start_line": 122,
        "end_line": 130,
        "code": "const enable_logging = b.option(bool, \"logging\", \"Enable debug logging\") orelse false;\n\nconst build_options = b.addOptions();\nbuild_options.addOption(bool, \"enable_logging\", enable_logging);\nbuild_options.addOption([]const u8, \"version\", \"1.0.0\");\n\nexe.root_module.addOptions(\"build_options\", build_options);",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 7,
        "chars": 308
      },
      {
        "index": 6,
        "start_line": 156,
        "end_line": 176,
        "code": "// Code generator executable (runs on host)\nconst gen_exe = b.addExecutable(.{\n    .name = \"codegen\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"tools/gen.zig\"),\n        .target = b.graph.host, // Build for host, not target\n        .optimize = .Debug,\n    }),\n});\n\n// Run the generator\nconst gen_run = b.addRunArtifact(gen_exe);\ngen_run.addArg(\"--output\");\nconst generated_file = gen_run.addOutputFileArg(\"generated.zig\");\n\n// Use generated file in main executable\nexe.root_module.addAnonymousImport(\"generated\", .{\n    .root_source_file = generated_file,\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 19,
        "chars": 589
      },
      {
        "index": 7,
        "start_line": 190,
        "end_line": 214,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const exe = b.addExecutable(.{\n        .name = \"hello\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n    b.installArtifact(exe);\n\n    const run_cmd = b.addRunArtifact(exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n    if (b.args) |args| run_cmd.addArgs(args);\n\n    const run_step = b.step(\"run\", \"Run the app\");\n    run_step.dependOn(&run_cmd.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 23,
        "chars": 663
      },
      {
        "index": 8,
        "start_line": 226,
        "end_line": 266,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Library module\n    const lib_mod = b.addModule(\"mathlib\", .{\n        .root_source_file = b.path(\"src/lib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Executable using library\n    const exe = b.addExecutable(.{\n        .name = \"calculator\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"mathlib\", .module = lib_mod },\n            },\n        }),\n    });\n    b.installArtifact(exe);\n\n    // Tests for library\n    const lib_tests = b.addTest(.{\n        .root_module = lib_mod,\n    });\n\n    const test_step = b.step(\"test\", \"Run library tests\");\n    test_step.dependOn(&b.addRunArtifact(lib_tests).step);\n\n    // Run step\n    const run_step = b.step(\"run\", \"Run the app\");\n    run_step.dependOn(&b.addRunArtifact(exe).step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 39,
        "chars": 1098
      },
      {
        "index": 9,
        "start_line": 286,
        "end_line": 319,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // User-configurable options\n    const enable_logging = b.option(bool, \"logging\", \"Enable debug logging\") orelse false;\n    const max_connections = b.option(u32, \"max-connections\", \"Maximum connections\") orelse 100;\n\n    // Build options module\n    const build_options = b.addOptions();\n    build_options.addOption(bool, \"enable_logging\", enable_logging);\n    build_options.addOption(u32, \"max_connections\", max_connections);\n    build_options.addOption([]const u8, \"version\", \"1.0.0\");\n\n    const exe = b.addExecutable(.{\n        .name = \"server\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"build_options\", .module = build_options.createModule() },\n            },\n        }),\n    });\n    b.installArtifact(exe);\n\n    const run_step = b.step(\"run\", \"Run the server\");\n    run_step.dependOn(&b.addRunArtifact(exe).step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 32,
        "chars": 1164
      },
      {
        "index": 11,
        "start_line": 355,
        "end_line": 394,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Code generator executable (runs on host)\n    const gen_exe = b.addExecutable(.{\n        .name = \"codegen\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"tools/gen.zig\"),\n            .target = b.graph.host, // Build for host system\n            .optimize = .Debug,\n        }),\n    });\n\n    // Run the generator\n    const gen_run = b.addRunArtifact(gen_exe);\n    gen_run.addArg(\"--output\");\n    const generated_file = gen_run.addOutputFileArg(\"generated.zig\");\n\n    // Main executable using generated code\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    // Add generated file as anonymous import\n    exe.root_module.addAnonymousImport(\"generated\", .{\n        .root_source_file = generated_file,\n    });\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 38,
        "chars": 1136
      },
      {
        "index": 13,
        "start_line": 444,
        "end_line": 498,
        "code": "const std = @import(\"std\");\n\nconst ReleaseTarget = struct {\n    arch: std.Target.Cpu.Arch,\n    os: std.Target.Os.Tag,\n};\n\npub fn build(b: *std.Build) void {\n    const optimize = b.standardOptimizeOption(.{});\n\n    const release_targets = [_]ReleaseTarget{\n        .{ .arch = .x86_64, .os = .linux },\n        .{ .arch = .x86_64, .os = .windows },\n        .{ .arch = .aarch64, .os = .linux },\n        .{ .arch = .aarch64, .os = .macos },\n    };\n\n    const release_step = b.step(\"release\", \"Build for all release targets\");\n\n    for (release_targets) |rt| {\n        const target = b.resolveTargetQuery(.{\n            .cpu_arch = rt.arch,\n            .os_tag = rt.os,\n        });\n\n        const exe = b.addExecutable(.{\n            .name = b.fmt(\"myapp-{s}-{s}\", .{\n                @tagName(rt.arch),\n                @tagName(rt.os),\n            }),\n            .root_module = b.createModule(.{\n                .root_source_file = b.path(\"src/main.zig\"),\n                .target = target,\n                .optimize = optimize,\n            }),\n        });\n\n        const install = b.addInstallArtifact(exe, .{});\n        release_step.dependOn(&install.step);\n    }\n\n    // Default single-target build\n    const target = b.standardTargetOptions(.{});\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 53,
        "chars": 1515
      },
      {
        "index": 14,
        "start_line": 529,
        "end_line": 586,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const test_filters = b.option(\n        []const []const u8,\n        \"test-filter\",\n        \"Skip tests that do not match filter\",\n    ) orelse &.{};\n\n    // Library module\n    const lib_mod = b.createModule(.{\n        .root_source_file = b.path(\"src/lib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Unit tests\n    const unit_tests = b.addTest(.{\n        .name = \"unit-tests\",\n        .root_module = lib_mod,\n        .filters = test_filters,\n    });\n\n    // Integration tests\n    const integration_tests = b.addTest(.{\n        .name = \"integration-tests\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"test/integration.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n        .filters = test_filters,\n    });\n\n    // Test steps\n    const test_step = b.step(\"test\", \"Run all tests\");\n    const unit_step = b.step(\"test:unit\", \"Run unit tests\");\n    const integration_step = b.step(\"test:integration\", \"Run integration tests\");\n\n    const run_unit = b.addRunArtifact(unit_tests);\n    const run_integration = b.addRunArtifact(integration_tests);\n\n    // Don't cache results when filtering\n    if (test_filters.len > 0) {\n        run_unit.has_side_effects = true;\n        run_integration.has_side_effects = true;\n    }\n\n    unit_step.dependOn(&run_unit.step);\n    integration_step.dependOn(&run_integration.step);\n    test_step.dependOn(&run_unit.step);\n    test_step.dependOn(&run_integration.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 56,
        "chars": 1669
      },
      {
        "index": 15,
        "start_line": 614,
        "end_line": 620,
        "code": "// \ud83d\udd50 0.14.x (DEPRECATED)\nconst exe = b.addExecutable(\"myapp\", \"src/main.zig\");\nexe.setTarget(target);\nexe.setBuildMode(mode);\nexe.addPackagePath(\"mylib\", \"lib/mylib.zig\");",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 5,
        "chars": 171
      },
      {
        "index": 16,
        "start_line": 624,
        "end_line": 637,
        "code": "// \u2705 0.15+\nconst exe = b.addExecutable(.{\n    .name = \"myapp\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n        .imports = &.{\n            .{ .name = \"mylib\", .module = mylib_mod },\n        },\n    }),\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 12,
        "chars": 308
      },
      {
        "index": 17,
        "start_line": 647,
        "end_line": 653,
        "code": "// \u274c Missing target/optimize\nconst mod = b.addModule(\"lib\", .{\n    .root_source_file = b.path(\"src/lib.zig\"),\n    // Tests using this module will fail!\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 5,
        "chars": 155
      },
      {
        "index": 18,
        "start_line": 657,
        "end_line": 664,
        "code": "// \u2705 Always specify target and optimize\nconst mod = b.addModule(\"lib\", .{\n    .root_source_file = b.path(\"src/lib.zig\"),\n    .target = target,\n    .optimize = optimize,\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 6,
        "chars": 172
      },
      {
        "index": 19,
        "start_line": 674,
        "end_line": 677,
        "code": "// \u274c Relative path\n.root_source_file = .{ .path = \"../src/main.zig\" },",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 2,
        "chars": 70
      },
      {
        "index": 20,
        "start_line": 681,
        "end_line": 684,
        "code": "// \u2705 Use b.path()\n.root_source_file = b.path(\"src/main.zig\"),",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 2,
        "chars": 61
      },
      {
        "index": 21,
        "start_line": 694,
        "end_line": 699,
        "code": "// \u274c No filter support\nconst tests = b.addTest(.{\n    .root_module = mod,\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 4,
        "chars": 77
      },
      {
        "index": 22,
        "start_line": 703,
        "end_line": 709,
        "code": "// \u2705 Support test filters\nconst tests = b.addTest(.{\n    .root_module = mod,\n    .filters = b.args orelse &.{},\n});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 5,
        "chars": 115
      },
      {
        "index": 23,
        "start_line": 719,
        "end_line": 723,
        "code": "// \u274c Circular dependency\nmod_a.addImport(\"b\", mod_b);\nmod_b.addImport(\"a\", mod_a); // Circular!",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 3,
        "chars": 95
      },
      {
        "index": 24,
        "start_line": 733,
        "end_line": 736,
        "code": "// \u274c Always fetches, even if not needed\nconst dep = b.dependency(\"heavy-lib\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 2,
        "chars": 83
      },
      {
        "index": 25,
        "start_line": 740,
        "end_line": 745,
        "code": "// \u2705 Only fetch when used\nif (b.lazyDependency(\"heavy-lib\", .{})) |dep| {\n    // Use dep only if it's in build.zig.zon\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 4,
        "chars": 120
      },
      {
        "index": 26,
        "start_line": 755,
        "end_line": 762,
        "code": "// tigerbeetle/build.zig:13-42\nfn resolve_target(b: *std.Build, target_requested: ?[]const u8) !std.Build.ResolvedTarget {\n    const triples = .{ \"aarch64-linux\", \"aarch64-macos\", \"x86_64-linux\", \"x86_64-windows\" };\n    const cpus = .{ \"baseline+aes+neon\", \"baseline+aes+neon\", \"x86_64_v3+aes\", \"x86_64_v3+aes\" };\n    // Enforces AES instructions for cryptographic operations\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 6,
        "chars": 377
      },
      {
        "index": 27,
        "start_line": 770,
        "end_line": 775,
        "code": "// ghostty/build.zig:17-34\nconst config = try buildpkg.Config.init(b, appVersion);\nconst deps = try buildpkg.SharedDeps.init(b, &config);\nconst mod = try buildpkg.GhosttyZig.init(b, &config, &deps);",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 4,
        "chars": 198
      },
      {
        "index": 28,
        "start_line": 783,
        "end_line": 794,
        "code": "// mach/build.zig:47-69\nconst want_mach = build_all or (build_mach orelse false);\nconst want_core = build_all or want_mach or (build_core orelse false);\n\nconst build_options = b.addOptions();\nbuild_options.addOption(bool, \"want_mach\", want_mach);\n\nif (b.lazyDependency(\"mach_freetype\", .{ ... })) |dep| {\n    module.addImport(\"mach-freetype\", dep.module(\"mach-freetype\"));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 10,
        "chars": 374
      },
      {
        "index": 29,
        "start_line": 802,
        "end_line": 812,
        "code": "// zls/build.zig:333-390\nfn getVersion(b: *Build) std.SemanticVersion {\n    const git_describe = b.runAllowFail(&.{ \"git\", \"describe\", \"--tags\" }, ...) catch null;\n    if (git_describe) |output| {\n        // Parse version from git tag\n        return std.SemanticVersion.parse(output) catch zls_version;\n    }\n    return zls_version; // Fallback to hardcoded version\n}",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 9,
        "chars": 367
      },
      {
        "index": 30,
        "start_line": 820,
        "end_line": 831,
        "code": "// zig/build.zig:381-621\nconst test_step = b.step(\"test\", \"Run all tests\");\n\nconst behavior_tests = b.addTest(.{ ... });\nconst stdlib_tests = b.addTest(.{ ... });\nconst standalone_tests = b.addTest(.{ ... });\n\ntest_step.dependOn(&behavior_tests.step);\ntest_step.dependOn(&stdlib_tests.step);\ntest_step.dependOn(&standalone_tests.step);",
        "file": "/home/jack/workspace/zig_guide/sections/08_build_system/content.md",
        "lines": 10,
        "chars": 335
      }
    ]
  },
  {
    "chapter": "09_packages_dependencies",
    "content_file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
    "total_blocks": 30,
    "runnable_blocks": 2,
    "snippet_blocks": 28,
    "runnable": [
      {
        "index": 14,
        "start_line": 374,
        "end_line": 392,
        "code": "// src/mathlib.zig\nconst std = @import(\"std\");\n\npub const version = \"2.0.0\";\n\npub fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\npub fn mul(a: i32, b: i32) i32 {\n    return a * b;\n}\n\ntest \"arithmetic operations\" {\n    try std.testing.expectEqual(@as(i32, 5), add(2, 3));\n    try std.testing.expectEqual(@as(i32, 6), mul(2, 3));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 17,
        "chars": 332
      },
      {
        "index": 17,
        "start_line": 500,
        "end_line": 516,
        "code": "// src/main.zig\nconst std = @import(\"std\");\nconst build_options = @import(\"build_options\");\nconst basic_math = @import(\"basic_math\");\n\npub fn main() void {\n    std.debug.print(\"Basic: add(10, 5) = {}\\n\", .{basic_math.add(10, 5)});\n\n    if (build_options.advanced_enabled) {\n        const advanced_math = @import(\"advanced_math\");\n        std.debug.print(\"Advanced: pow(2, 8) = {}\\n\", .{advanced_math.pow(2, 8)});\n    } else {\n        std.debug.print(\"Advanced features disabled (use -Dadvanced=true)\\n\", .{});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 15,
        "chars": 517
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 15,
        "end_line": 35,
        "code": ".{\n    .name = .mypackage,\n    .version = \"1.0.0\",\n    .minimum_zig_version = \"0.14.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n        \"README.md\",\n        \"LICENSE\",\n    },\n    .dependencies = .{\n        .known_folders = .{\n            .url = \"https://github.com/ziglibs/known-folders/archive/HASH.tar.gz\",\n            .hash = \"known_folders-0.0.0-BASE64HASH\",\n        },\n    },\n    .fingerprint = 0x1234567890abcdef,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 19,
        "chars": 458
      },
      {
        "index": 2,
        "start_line": 55,
        "end_line": 62,
        "code": ".dependencies = .{\n    .mylib = .{\n        .url = \"https://github.com/user/repo/archive/abc123.tar.gz\",\n        .hash = \"mylib-1.0.0-Fy-PJkfRAAAVdptXWXBspIIC7EkVgLgWozU5zIk5Zgcy\",\n    },\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 6,
        "chars": 188
      },
      {
        "index": 3,
        "start_line": 81,
        "end_line": 89,
        "code": ".dependencies = .{\n    .optional_feature = .{\n        .url = \"https://example.com/feature.tar.gz\",\n        .hash = \"feature-1.0.0-HASH\",\n        .lazy = true,  // Only fetched if used\n    },\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 7,
        "chars": 192
      },
      {
        "index": 4,
        "start_line": 93,
        "end_line": 98,
        "code": "if (b.lazyDependency(\"optional_feature\", .{})) |dep| {\n    // Use dep only if build needs it\n    exe.root_module.addImport(\"feature\", dep.module(\"feature\"));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 4,
        "chars": 159
      },
      {
        "index": 5,
        "start_line": 136,
        "end_line": 163,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Load dependency\n    const mylib_dep = b.dependency(\"mylib\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"app\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"mylib\", .module = mylib_dep.module(\"mylib\") },\n            },\n        }),\n    });\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 26,
        "chars": 687
      },
      {
        "index": 6,
        "start_line": 178,
        "end_line": 184,
        "code": ".dependencies = .{\n    .mylib = .{\n        .path = \"./lib\",  // Relative to build.zig.zon\n    },\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 5,
        "chars": 98
      },
      {
        "index": 7,
        "start_line": 199,
        "end_line": 201,
        "code": ".fingerprint = 0x1234567890abcdef,",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 1,
        "chars": 34
      },
      {
        "index": 8,
        "start_line": 221,
        "end_line": 238,
        "code": "// app/build.zig.zon\n.{\n    .name = .app,\n    .version = \"0.1.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n    },\n    .dependencies = .{\n        .mylib = .{\n            .path = \"./lib\",\n        },\n    },\n    .fingerprint = 0xc96e70cfa118c414,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 16,
        "chars": 280
      },
      {
        "index": 9,
        "start_line": 240,
        "end_line": 268,
        "code": "// app/build.zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Load local dependency\n    const mylib_dep = b.dependency(\"mylib\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"app\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"mylib\", .module = mylib_dep.module(\"mylib\") },\n            },\n        }),\n    });\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 27,
        "chars": 710
      },
      {
        "index": 10,
        "start_line": 270,
        "end_line": 282,
        "code": "// lib/build.zig.zon\n.{\n    .name = .mylib,\n    .version = \"1.0.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n    },\n    .fingerprint = 0xe7f94929cda3434e,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 11,
        "chars": 192
      },
      {
        "index": 11,
        "start_line": 284,
        "end_line": 299,
        "code": "// lib/build.zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Expose module for consumers\n    _ = b.addModule(\"mylib\", .{\n        .root_source_file = b.path(\"src/lib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 14,
        "chars": 366
      },
      {
        "index": 12,
        "start_line": 312,
        "end_line": 327,
        "code": "// build.zig.zon\n.{\n    .name = .mathlib,\n    .version = \"2.0.0\",\n    .minimum_zig_version = \"0.14.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n        \"README.md\",\n        \"LICENSE\",\n    },\n    .fingerprint = 0x102b5599e8da1422,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 14,
        "chars": 267
      },
      {
        "index": 13,
        "start_line": 329,
        "end_line": 372,
        "code": "// build.zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Expose module for package consumers\n    _ = b.addModule(\"mathlib\", .{\n        .root_source_file = b.path(\"src/mathlib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Tests for development\n    const lib_tests = b.addTest(.{\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/mathlib.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    const test_step = b.step(\"test\", \"Run library tests\");\n    test_step.dependOn(&b.addRunArtifact(lib_tests).step);\n\n    // Example executable (optional)\n    const example = b.addExecutable(.{\n        .name = \"example\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/example.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"mathlib\", .module = b.modules.get(\"mathlib\").? },\n            },\n        }),\n    });\n\n    const example_step = b.step(\"example\", \"Build example\");\n    example_step.dependOn(&b.addInstallArtifact(example, .{}).step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 42,
        "chars": 1283
      },
      {
        "index": 15,
        "start_line": 425,
        "end_line": 446,
        "code": "// build.zig.zon\n.{\n    .name = .app_with_features,\n    .version = \"0.1.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n    },\n    .dependencies = .{\n        .basic_math = .{\n            .path = \"./features/basic_math\",\n        },\n        .advanced_math = .{\n            .path = \"./features/advanced_math\",\n            .lazy = true,  // Only fetch if enabled\n        },\n    },\n    .fingerprint = 0x1cb7bf439c5b61ae,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 20,
        "chars": 450
      },
      {
        "index": 16,
        "start_line": 448,
        "end_line": 498,
        "code": "// build.zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // User option to enable advanced features\n    const enable_advanced = b.option(\n        bool,\n        \"advanced\",\n        \"Enable advanced math features\",\n    ) orelse false;\n\n    // Build options module\n    const build_options = b.addOptions();\n    build_options.addOption(bool, \"advanced_enabled\", enable_advanced);\n\n    // Basic dependency (always loaded)\n    const basic_dep = b.dependency(\"basic_math\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"app\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"build_options\", .module = build_options.createModule() },\n                .{ .name = \"basic_math\", .module = basic_dep.module(\"basic\") },\n            },\n        }),\n    });\n\n    // Advanced dependency (lazy - only if enabled)\n    if (enable_advanced) {\n        if (b.lazyDependency(\"advanced_math\", .{\n            .target = target,\n            .optimize = optimize,\n        })) |advanced_dep| {\n            exe.root_module.addImport(\"advanced_math\", advanced_dep.module(\"advanced\"));\n        }\n    }\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 49,
        "chars": 1464
      },
      {
        "index": 18,
        "start_line": 542,
        "end_line": 549,
        "code": "// \u274c Missing fingerprint\n.{\n    .name = .mypackage,\n    .version = \"1.0.0\",\n    .paths = .{\"\"},\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 6,
        "chars": 97
      },
      {
        "index": 19,
        "start_line": 560,
        "end_line": 568,
        "code": "// \u2705 With fingerprint\n.{\n    .name = .mypackage,\n    .version = \"1.0.0\",\n    .paths = .{\"\"},\n    .fingerprint = 0x1234567890abcdef,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 7,
        "chars": 133
      },
      {
        "index": 20,
        "start_line": 600,
        "end_line": 603,
        "code": "// \u274c Panic if not available\nconst dep = b.dependency(\"lazy_dep\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 2,
        "chars": 70
      },
      {
        "index": 21,
        "start_line": 607,
        "end_line": 612,
        "code": "// \u2705 Returns null if not available\nif (b.lazyDependency(\"lazy_dep\", .{})) |dep| {\n    // Use dep\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 4,
        "chars": 98
      },
      {
        "index": 22,
        "start_line": 622,
        "end_line": 625,
        "code": "// \u274c Dependency built for different target\nconst dep = b.dependency(\"mylib\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 2,
        "chars": 82
      },
      {
        "index": 23,
        "start_line": 629,
        "end_line": 635,
        "code": "// \u2705 Consistent target and optimize\nconst dep = b.dependency(\"mylib\", .{\n    .target = target,\n    .optimize = optimize,\n});",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 5,
        "chars": 124
      },
      {
        "index": 24,
        "start_line": 658,
        "end_line": 664,
        "code": "// \u274c Missing README, LICENSE\n.paths = .{\n    \"build.zig\",\n    \"src\",\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 5,
        "chars": 70
      },
      {
        "index": 25,
        "start_line": 668,
        "end_line": 677,
        "code": "// \u2705 Complete package\n.paths = .{\n    \"build.zig\",\n    \"build.zig.zon\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\",\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 8,
        "chars": 116
      },
      {
        "index": 26,
        "start_line": 687,
        "end_line": 701,
        "code": "// zls/build.zig.zon\n.dependencies = .{\n    .known_folders = .{\n        .url = \"https://github.com/ziglibs/known-folders/archive/HASH.tar.gz\",\n        .hash = \"known_folders-0.0.0-HASH\",\n        // Eager - always needed\n    },\n    .tracy = .{\n        .url = \"https://github.com/wolfpld/tracy/archive/v0.11.1.tar.gz\",\n        .hash = \"N-V-__8AAMeOlQEipHjcyu0TCftdAi9AQe7EXUDJOoVe0k-t\",\n        .lazy = true,  // Only for profiling builds\n    },\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 13,
        "chars": 445
      },
      {
        "index": 27,
        "start_line": 709,
        "end_line": 718,
        "code": "// ghostty/build.zig.zon\n.dependencies = .{\n    .libxev = .{ .url = \"...\", .hash = \"...\", .lazy = true },\n    .vaxis = .{ .url = \"...\", .hash = \"...\", .lazy = true },\n    .freetype = .{ .path = \"./pkg/freetype\", .lazy = true },\n    .fontconfig = .{ .path = \"./pkg/fontconfig\", .lazy = true },\n    // ~20 more lazy dependencies\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 8,
        "chars": 328
      },
      {
        "index": 28,
        "start_line": 732,
        "end_line": 746,
        "code": "// tigerbeetle/src/docs_website/build.zig.zon\n.dependencies = .{\n    .pandoc_macos_arm64 = .{\n        .url = \"https://github.com/jgm/pandoc/releases/download/3.4/pandoc-3.4-arm64-macOS.zip\",\n        .hash = \"1220c2506a07845d667e7c127fd0811e4f5f7591e38ccc7fb4376450f3435048d87a\",\n        .lazy = true,\n    },\n    .pandoc_linux_amd64 = .{\n        .url = \"https://github.com/jgm/pandoc/releases/download/3.4/pandoc-3.4-linux-amd64.tar.gz\",\n        .hash = \"1220139a44886509d8a61b44d8b8a79d03bad29ea95493dc97cd921d3f2eb208562c\",\n        .lazy = true,\n    },\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 13,
        "chars": 555
      },
      {
        "index": 29,
        "start_line": 748,
        "end_line": 763,
        "code": "// build.zig\nfn get_pandoc_bin(b: *std.Build) ?std.Build.LazyPath {\n    const host = b.graph.host.result;\n    const dep_name = switch (host.os.tag) {\n        .linux => \"pandoc_linux_amd64\",\n        .macos => \"pandoc_macos_arm64\",\n        else => return null,\n    };\n\n    if (b.lazyDependency(dep_name, .{})) |dep| {\n        return dep.path(\"bin/pandoc\");\n    }\n    return null;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 14,
        "chars": 379
      },
      {
        "index": 30,
        "start_line": 771,
        "end_line": 780,
        "code": "// mach/build.zig.zon\n.dependencies = .{\n    .mach_freetype = .{\n        .url = \"https://pkg.machengine.org/mach-freetype/d63efa5534c17f3a12ed3d327e0ad42a64adc20a.tar.gz\",\n        .hash = \"1220adfccce3dbc4e4fa8650fdaec110a676f6b8a1462ed6ef422815207f8288e9d2\",\n        .lazy = true,\n    },\n}",
        "file": "/home/jack/workspace/zig_guide/sections/09_packages_dependencies/content.md",
        "lines": 8,
        "chars": 290
      }
    ]
  },
  {
    "chapter": "10_project_layout_ci",
    "content_file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
    "total_blocks": 42,
    "runnable_blocks": 8,
    "snippet_blocks": 34,
    "runnable": [
      {
        "index": 1,
        "start_line": 61,
        "end_line": 68,
        "code": "// src/main.zig\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.print(\"Hello, world!\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 6,
        "chars": 112
      },
      {
        "index": 2,
        "start_line": 72,
        "end_line": 84,
        "code": "// src/root.zig\nconst std = @import(\"std\");\n\n/// Public API function\npub fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\ntest \"addition\" {\n    try std.testing.expectEqual(@as(i32, 5), add(2, 3));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 11,
        "chars": 199
      },
      {
        "index": 6,
        "start_line": 189,
        "end_line": 199,
        "code": "// tests/math_tests.zig\nconst std = @import(\"std\");\nconst math = @import(\"../src/math.zig\");\n\ntest \"comprehensive addition tests\" {\n    try std.testing.expectEqual(@as(i32, 0), math.add(0, 0));\n    try std.testing.expectEqual(@as(i32, 100), math.add(50, 50));\n    try std.testing.expectEqual(@as(i32, -10), math.add(-5, -5));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 9,
        "chars": 327
      },
      {
        "index": 22,
        "start_line": 610,
        "end_line": 635,
        "code": "//! Root module for myproject library.\n//! This file exposes the public API for consumers.\n\nconst std = @import(\"std\");\n\n/// Adds two integers.\npub fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\n/// Multiplies two integers.\npub fn multiply(a: i32, b: i32) i32 {\n    return a * b;\n}\n\ntest \"add function\" {\n    try std.testing.expectEqual(@as(i32, 5), add(2, 3));\n    try std.testing.expectEqual(@as(i32, 0), add(-1, 1));\n}\n\ntest \"multiply function\" {\n    try std.testing.expectEqual(@as(i32, 6), multiply(2, 3));\n    try std.testing.expectEqual(@as(i32, -6), multiply(-2, 3));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 24,
        "chars": 580
      },
      {
        "index": 23,
        "start_line": 639,
        "end_line": 657,
        "code": "const std = @import(\"std\");\nconst myproject = @import(\"myproject\");\n\npub fn main() void {\n    std.debug.print(\"My Project Demo\\n\", .{});\n\n    const result = myproject.add(10, 32);\n    std.debug.print(\"10 + 32 = {d}\\n\", .{result});\n\n    const product = myproject.multiply(6, 7);\n    std.debug.print(\"6 * 7 = {d}\\n\", .{product});\n}\n\ntest \"main functionality\" {\n    const result = myproject.add(10, 32);\n    try std.testing.expectEqual(@as(i32, 42), result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 17,
        "chars": 457
      },
      {
        "index": 25,
        "start_line": 770,
        "end_line": 800,
        "code": "const std = @import(\"std\");\nconst builtin = @import(\"builtin\");\n\npub fn main() void {\n    std.debug.print(\"Cross-compilation demo\\n\", .{});\n    std.debug.print(\"Architecture: {s}\\n\", .{@tagName(builtin.cpu.arch)});\n    std.debug.print(\"OS: {s}\\n\", .{@tagName(builtin.os.tag)});\n    std.debug.print(\"ABI: {s}\\n\", .{@tagName(builtin.abi)});\n    std.debug.print(\"Optimize mode: {s}\\n\", .{@tagName(builtin.mode)});\n\n    // Platform-specific code example\n    if (builtin.os.tag == .windows) {\n        std.debug.print(\"Running on Windows\\n\", .{});\n    } else if (builtin.os.tag == .linux) {\n        std.debug.print(\"Running on Linux\\n\", .{});\n    } else if (builtin.os.tag == .macos) {\n        std.debug.print(\"Running on macOS\\n\", .{});\n    } else if (builtin.os.tag == .wasi) {\n        std.debug.print(\"Running on WASI\\n\", .{});\n    }\n}\n\ntest \"platform detection\" {\n    const is_valid = switch (builtin.os.tag) {\n        .windows, .linux, .macos, .wasi => true,\n        else => false,\n    };\n    try std.testing.expect(is_valid or true);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 29,
        "chars": 1035
      },
      {
        "index": 30,
        "start_line": 1325,
        "end_line": 1366,
        "code": "//! Core library providing shared functionality.\n\nconst std = @import(\"std\");\n\npub const Version = struct {\n    major: u32,\n    minor: u32,\n    patch: u32,\n\n    pub fn format(\n        self: Version,\n        comptime fmt: []const u8,\n        options: std.fmt.FormatOptions,\n        writer: anytype,\n    ) !void {\n        _ = fmt;\n        _ = options;\n        try writer.print(\"{d}.{d}.{d}\", .{ self.major, self.minor, self.patch });\n    }\n};\n\npub const version = Version{ .major = 1, .minor = 0, .patch = 0 };\n\npub fn greet(writer: anytype, name: []const u8) !void {\n    try writer.print(\"Hello from core, {s}!\\n\", .{name});\n}\n\npub fn calculate(a: i32, b: i32) i32 {\n    return a * 2 + b;\n}\n\ntest \"calculate\" {\n    try std.testing.expectEqual(@as(i32, 7), calculate(2, 3));\n}\n\ntest \"version format\" {\n    var buf: [100]u8 = undefined;\n    const result = try std.fmt.bufPrint(&buf, \"{}\", .{version});\n    try std.testing.expectEqualStrings(\"1.0.0\", result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 40,
        "chars": 957
      },
      {
        "index": 31,
        "start_line": 1370,
        "end_line": 1388,
        "code": "const std = @import(\"std\");\nconst core = @import(\"core\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    try stdout.print(\"Workspace App v{}\\n\", .{core.version});\n    try core.greet(stdout, \"Workspace\");\n\n    const result = core.calculate(10, 5);\n    try stdout.print(\"Calculate(10, 5) = {d}\\n\", .{result});\n}\n\ntest \"app uses core correctly\" {\n    const result = core.calculate(10, 5);\n    try std.testing.expectEqual(@as(i32, 25), result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 17,
        "chars": 471
      }
    ],
    "snippets": [
      {
        "index": 3,
        "start_line": 88,
        "end_line": 118,
        "code": "// build.zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Library module for external consumption\n    const lib_module = b.addModule(\"myproject\", .{\n        .root_source_file = b.path(\"src/root.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Executable using the library\n    const exe = b.addExecutable(.{\n        .name = \"myproject\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"myproject\", .module = lib_module },\n            },\n        }),\n    });\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 29,
        "chars": 811
      },
      {
        "index": 4,
        "start_line": 149,
        "end_line": 154,
        "code": "// src/main.zig\nconst parser = @import(\"parser/parser.zig\");\nconst codegen = @import(\"codegen/llvm.zig\");\nconst util = @import(\"util/buffer.zig\");",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 4,
        "chars": 146
      },
      {
        "index": 5,
        "start_line": 164,
        "end_line": 177,
        "code": "// src/math.zig\npub fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\ntest \"add basic\" {\n    try std.testing.expectEqual(@as(i32, 5), add(2, 3));\n}\n\ntest \"add negative\" {\n    try std.testing.expectEqual(@as(i32, -1), add(-3, 2));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 12,
        "chars": 231
      },
      {
        "index": 7,
        "start_line": 250,
        "end_line": 262,
        "code": "const std = @import(\"std\");\nconst Query = std.Target.Query;\n\n// Parse from string\nconst query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux-musl\",\n    .cpu_features = \"baseline\",\n});\n\n// Resolve to concrete target\nconst target = b.resolveTargetQuery(query);",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 11,
        "chars": 265
      },
      {
        "index": 8,
        "start_line": 273,
        "end_line": 281,
        "code": "const query = Query{\n    .cpu_arch = .x86_64,\n    .os_tag = .linux,\n    .abi = .musl,\n};\n\nconst target = b.resolveTargetQuery(query);",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 7,
        "chars": 133
      },
      {
        "index": 9,
        "start_line": 291,
        "end_line": 293,
        "code": ".cpu_features = \"baseline\"",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 26
      },
      {
        "index": 10,
        "start_line": 299,
        "end_line": 305,
        "code": "// ARM64 with cryptography extensions\n.cpu_features = \"baseline+aes+neon\"\n\n// x86_64 with AES-NI\n.cpu_features = \"baseline+aes+sse4_2\"",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 5,
        "chars": 134
      },
      {
        "index": 11,
        "start_line": 309,
        "end_line": 313,
        "code": ".cpu_features = \"x86_64_v2\"  // +CMPXCHG16B, POPCNT, SSE3, SSE4.2, SSSE3\n.cpu_features = \"x86_64_v3\"  // v2 + AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE\n.cpu_features = \"x86_64_v4\"  // v3 + AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 241
      },
      {
        "index": 12,
        "start_line": 319,
        "end_line": 321,
        "code": ".cpu_features = \"native\"",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 24
      },
      {
        "index": 13,
        "start_line": 331,
        "end_line": 333,
        "code": ".abi = .musl",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 12
      },
      {
        "index": 14,
        "start_line": 342,
        "end_line": 344,
        "code": ".abi = .gnu",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 11
      },
      {
        "index": 15,
        "start_line": 353,
        "end_line": 355,
        "code": ".abi = .none",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 12
      },
      {
        "index": 16,
        "start_line": 363,
        "end_line": 366,
        "code": ".abi = .gnu   // MinGW (mingw-w64)\n.abi = .msvc  // Microsoft Visual C++ runtime",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 2,
        "chars": 80
      },
      {
        "index": 17,
        "start_line": 387,
        "end_line": 391,
        "code": "const query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux-musl\",\n});",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 76
      },
      {
        "index": 18,
        "start_line": 395,
        "end_line": 399,
        "code": "const query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux-gnu\",\n});",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 75
      },
      {
        "index": 19,
        "start_line": 501,
        "end_line": 503,
        "code": "exe.strip = true;",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 17
      },
      {
        "index": 20,
        "start_line": 541,
        "end_line": 556,
        "code": ".{\n    .name = .myproject,\n    .version = \"1.0.0\",\n    .minimum_zig_version = \"0.15.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n        \"README.md\",\n        \"LICENSE\",\n    },\n    .dependencies = .{},\n    .fingerprint = 0x4ae5f776026022c7,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 14,
        "chars": 277
      },
      {
        "index": 21,
        "start_line": 560,
        "end_line": 606,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Library module (for reusable code)\n    const lib_module = b.addModule(\"myproject\", .{\n        .root_source_file = b.path(\"src/root.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Executable\n    const exe = b.addExecutable(.{\n        .name = \"myproject\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"myproject\", .module = lib_module },\n            },\n        }),\n    });\n    b.installArtifact(exe);\n\n    // Run step\n    const run_cmd = b.addRunArtifact(exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n    if (b.args) |args| {\n        run_cmd.addArgs(args);\n    }\n    const run_step = b.step(\"run\", \"Run the application\");\n    run_step.dependOn(&run_cmd.step);\n\n    // Tests\n    const exe_tests = b.addTest(.{\n        .root_module = exe.root_module,\n    });\n    const run_exe_tests = b.addRunArtifact(exe_tests);\n\n    const test_step = b.step(\"test\", \"Run all tests\");\n    test_step.dependOn(&run_exe_tests.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 45,
        "chars": 1293
      },
      {
        "index": 24,
        "start_line": 689,
        "end_line": 766,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    // Define target platforms for cross-compilation\n    const targets = [_]std.Target.Query{\n        .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .musl },\n        .{ .cpu_arch = .aarch64, .os_tag = .linux, .abi = .musl },\n        .{ .cpu_arch = .x86_64, .os_tag = .windows },\n        .{ .cpu_arch = .x86_64, .os_tag = .macos },\n        .{ .cpu_arch = .aarch64, .os_tag = .macos },\n        .{ .cpu_arch = .wasm32, .os_tag = .wasi },\n    };\n\n    const optimize = b.standardOptimizeOption(.{\n        .preferred_optimize_mode = .ReleaseSafe,\n    });\n\n    // Build for all targets\n    inline for (targets) |target_query| {\n        const target = b.resolveTargetQuery(target_query);\n\n        const exe = b.addExecutable(.{\n            .name = \"crossapp\",\n            .root_module = b.createModule(.{\n                .root_source_file = b.path(\"main.zig\"),\n                .target = target,\n                .optimize = optimize,\n            }),\n        });\n\n        // Generate target-specific binary names\n        const target_output = b.fmt(\n            \"crossapp-{s}-{s}{s}\",\n            .{\n                @tagName(target.result.cpu.arch),\n                @tagName(target.result.os.tag),\n                if (target.result.os.tag == .windows) \".exe\" else \"\",\n            },\n        );\n\n        // Install with target-specific name\n        const install_step = b.addInstallArtifact(exe, .{\n            .dest_sub_path = target_output,\n        });\n        b.getInstallStep().dependOn(&install_step.step);\n    }\n\n    // Native build for local testing\n    const native_target = b.standardTargetOptions(.{});\n    const native_exe = b.addExecutable(.{\n        .name = \"crossapp\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"main.zig\"),\n            .target = native_target,\n            .optimize = optimize,\n        }),\n    });\n\n    // Run step for native binary\n    const run_cmd = b.addRunArtifact(native_exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n    if (b.args) |args| {\n        run_cmd.addArgs(args);\n    }\n\n    const run_step = b.step(\"run\", \"Run the native app\");\n    run_step.dependOn(&run_cmd.step);\n\n    // Tests\n    const tests = b.addTest(.{\n        .root_module = native_exe.root_module,\n    });\n    const run_tests = b.addRunArtifact(tests);\n    const test_step = b.step(\"test\", \"Run tests\");\n    test_step.dependOn(&run_tests.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 76,
        "chars": 2453
      },
      {
        "index": 26,
        "start_line": 1197,
        "end_line": 1216,
        "code": ".{\n    .name = .workspace,\n    .version = \"1.0.0\",\n    .minimum_zig_version = \"0.15.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"packages\",\n        \"shared\",\n        \"README.md\",\n    },\n    .dependencies = .{\n        .core = .{\n            .path = \"packages/core\",\n        },\n    },\n    .fingerprint = 0x8d9400192b062fca,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 18,
        "chars": 353
      },
      {
        "index": 27,
        "start_line": 1220,
        "end_line": 1274,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Load core library dependency\n    const core_dep = b.dependency(\"core\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    const core_mod = core_dep.module(\"core\");\n\n    // Build app using core\n    const app_exe = b.addExecutable(.{\n        .name = \"workspace-app\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"packages/app/src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"core\", .module = core_mod },\n            },\n        }),\n    });\n    b.installArtifact(app_exe);\n\n    // Run step\n    const run_cmd = b.addRunArtifact(app_exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n    if (b.args) |args| {\n        run_cmd.addArgs(args);\n    }\n    const run_step = b.step(\"run\", \"Run the app\");\n    run_step.dependOn(&run_cmd.step);\n\n    // Test step for all packages\n    const test_step = b.step(\"test\", \"Run all tests\");\n\n    // Test core\n    const core_tests = b.addTest(.{\n        .root_module = core_mod,\n    });\n    const run_core_tests = b.addRunArtifact(core_tests);\n    test_step.dependOn(&run_core_tests.step);\n\n    // Test app\n    const app_tests = b.addTest(.{\n        .root_module = app_exe.root_module,\n    });\n    const run_app_tests = b.addRunArtifact(app_tests);\n    test_step.dependOn(&run_app_tests.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 53,
        "chars": 1538
      },
      {
        "index": 28,
        "start_line": 1278,
        "end_line": 1291,
        "code": ".{\n    .name = .core,\n    .version = \"1.0.0\",\n    .minimum_zig_version = \"0.15.0\",\n    .paths = .{\n        \"build.zig\",\n        \"build.zig.zon\",\n        \"src\",\n    },\n    .dependencies = .{},\n    .fingerprint = 0x6b8d854fd9e12954,\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 12,
        "chars": 232
      },
      {
        "index": 29,
        "start_line": 1295,
        "end_line": 1321,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Core library module\n    _ = b.addModule(\"core\", .{\n        .root_source_file = b.path(\"src/lib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Shared library artifact (optional)\n    const lib = b.addSharedLibrary(.{\n        .name = \"core\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/lib.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n        .version = .{ .major = 1, .minor = 0, .patch = 0 },\n    });\n    b.installArtifact(lib);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 25,
        "chars": 713
      },
      {
        "index": 32,
        "start_line": 1447,
        "end_line": 1451,
        "code": ".paths = .{\n    \"src\",\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 24
      },
      {
        "index": 33,
        "start_line": 1455,
        "end_line": 1463,
        "code": ".paths = .{\n    \"build.zig\",\n    \"build.zig.zon\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\",\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 7,
        "chars": 94
      },
      {
        "index": 34,
        "start_line": 1535,
        "end_line": 1539,
        "code": "const query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux\",  // Defaults to gnu (glibc)\n});",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 99
      },
      {
        "index": 35,
        "start_line": 1543,
        "end_line": 1547,
        "code": "const query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux-musl\",  // Explicit static linking\n});",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 104
      },
      {
        "index": 36,
        "start_line": 1586,
        "end_line": 1591,
        "code": "const query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux-musl\",\n    .cpu_features = \"native\",  // Optimizes for build host\n});",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 4,
        "chars": 135
      },
      {
        "index": 37,
        "start_line": 1601,
        "end_line": 1606,
        "code": "const query = try Query.parse(.{\n    .arch_os_abi = \"x86_64-linux-musl\",\n    .cpu_features = \"baseline\",  // Compatible with all x86_64\n});",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 4,
        "chars": 139
      },
      {
        "index": 38,
        "start_line": 1610,
        "end_line": 1612,
        "code": ".cpu_features = \"x86_64_v3\"  // Clearly states AVX2 requirement",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 1,
        "chars": 63
      },
      {
        "index": 39,
        "start_line": 1622,
        "end_line": 1626,
        "code": "exe.linkSystemLibrary(\"ssl\");\nexe.linkSystemLibrary(\"crypto\");\n// Cross-compiling to system without OpenSSL",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 3,
        "chars": 107
      },
      {
        "index": 40,
        "start_line": 1632,
        "end_line": 1640,
        "code": "// Option 1: Static linking\nexe.linkSystemLibrary(\"ssl\");\nexe.linkage = .static;\n\n// Option 2: Vendor the library\nconst ssl_dep = b.dependency(\"openssl\", .{});\nexe.linkLibrary(ssl_dep.artifact(\"ssl\"));",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 7,
        "chars": 201
      },
      {
        "index": 41,
        "start_line": 1770,
        "end_line": 1799,
        "code": "// tigerbeetle/build.zig\nfn resolve_target(b: *std.Build, target_requested: ?[]const u8) !std.Build.ResolvedTarget {\n    const triples = .{\n        \"aarch64-linux\",\n        \"aarch64-macos\",\n        \"x86_64-linux\",\n        \"x86_64-macos\",\n        \"x86_64-windows\",\n    };\n    const cpus = .{\n        \"baseline+aes+neon\",\n        \"baseline+aes+neon\",\n        \"x86_64_v3+aes\",\n        \"x86_64_v3+aes\",\n        \"x86_64_v3+aes\",\n    };\n\n    // Match target to CPU requirements\n    const arch_os, const cpu = inline for (triples, cpus) |triple, cpu_feat| {\n        if (std.mem.eql(u8, target, triple)) break .{ triple, cpu_feat };\n    } else return error.UnsupportedTarget;\n\n    const query = try Query.parse(.{\n        .arch_os_abi = arch_os,\n        .cpu_features = cpu,\n    });\n    return b.resolveTargetQuery(query);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 28,
        "chars": 816
      },
      {
        "index": 42,
        "start_line": 1829,
        "end_line": 1838,
        "code": "const buildpkg = @import(\"src/build/main.zig\");\n\npub fn build(b: *std.Build) !void {\n    const config = try buildpkg.Config.init(b, appVersion);\n    const deps = try buildpkg.SharedDeps.init(b, &config);\n    const exe = try buildpkg.GhosttyExe.init(b, &config, &deps);\n    // Clean root build.zig focuses on coordination\n}",
        "file": "/home/jack/workspace/zig_guide/sections/10_project_layout_ci/content.md",
        "lines": 8,
        "chars": 322
      }
    ]
  },
  {
    "chapter": "11_interoperability",
    "content_file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
    "total_blocks": 86,
    "runnable_blocks": 3,
    "snippet_blocks": 83,
    "runnable": [
      {
        "index": 40,
        "start_line": 1216,
        "end_line": 1247,
        "code": "const std = @import(\"std\");\n\nconst c = @cImport({\n    @cInclude(\"stdio.h\");\n    @cInclude(\"stdlib.h\");\n    @cInclude(\"string.h\");\n});\n\npub fn main() !void {\n    // Call C's printf\n    _ = c.printf(\"Hello from C's printf!\\n\");\n\n    // Work with C integers\n    const value: c.c_int = 42;\n    _ = c.printf(\"C int value: %d\\n\", value);\n\n    // C string handling with null termination\n    const c_string: [*:0]const u8 = \"C-style string\";\n    const len = c.strlen(c_string);\n    _ = c.printf(\"String length: %zu\\n\", len);\n\n    // C memory allocation with defer cleanup\n    const size: usize = 100;\n    const ptr = c.malloc(size);\n    if (ptr == null) return error.OutOfMemory;\n    defer c.free(ptr);\n\n    _ = c.memset(ptr, 0, size);\n    _ = c.printf(\"Allocated and zeroed %zu bytes\\n\", size);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 30,
        "chars": 789
      },
      {
        "index": 41,
        "start_line": 1266,
        "end_line": 1303,
        "code": "const std = @import(\"std\");\n\nconst c = @cImport({\n    @cInclude(\"sqlite3.h\");\n});\n\npub fn main() !void {\n    var db: ?*c.sqlite3 = null;\n    defer _ = c.sqlite3_close(db);\n\n    // Open in-memory database\n    const rc = c.sqlite3_open(\":memory:\", &db);\n    if (rc != c.SQLITE_OK) {\n        std.debug.print(\"Cannot open database: {s}\\n\", .{c.sqlite3_errmsg(db)});\n        return error.DatabaseError;\n    }\n\n    // Create table\n    const create_sql = \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\";\n    var errmsg: [*c]u8 = null;\n    defer c.sqlite3_free(errmsg);\n\n    _ = c.sqlite3_exec(db, create_sql, null, null, &errmsg);\n\n    // Insert data using prepared statement\n    const insert_sql = \"INSERT INTO users (name, age) VALUES (?, ?)\";\n    var stmt: ?*c.sqlite3_stmt = null;\n    defer _ = c.sqlite3_finalize(stmt);\n\n    _ = c.sqlite3_prepare_v2(db, insert_sql, -1, &stmt, null);\n    _ = c.sqlite3_bind_text(stmt, 1, \"Alice\", -1, c.SQLITE_TRANSIENT);\n    _ = c.sqlite3_bind_int(stmt, 2, 30);\n    _ = c.sqlite3_step(stmt);\n\n    std.debug.print(\"Inserted user successfully\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 36,
        "chars": 1106
      },
      {
        "index": 46,
        "start_line": 1573,
        "end_line": 1626,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n    const stdout = std.io.getStdOut().writer();\n\n    // Command-line arguments\n    try stdout.print(\"=== Command-line arguments ===\\n\", .{});\n    var args = try std.process.argsWithAllocator(allocator);\n    defer args.deinit();\n\n    var i: usize = 0;\n    while (args.next()) |arg| {\n        try stdout.print(\"arg[{d}]: {s}\\n\", .{ i, arg });\n        i += 1;\n    }\n\n    // Environment variables\n    try stdout.print(\"\\n=== Environment variables ===\\n\", .{});\n    const env_map = try std.process.getEnvMap(allocator);\n    defer env_map.deinit();\n\n    var iter = env_map.iterator();\n    while (iter.next()) |entry| {\n        try stdout.print(\"{s}={s}\\n\", .{\n            entry.key_ptr.*,\n            entry.value_ptr.*\n        });\n    }\n\n    // Filesystem operations (requires --dir capability)\n    try stdout.print(\"\\n=== Filesystem operations ===\\n\", .{});\n    const cwd = std.fs.cwd();\n\n    // Create file\n    const file = try cwd.createFile(\"wasi_test.txt\", .{});\n    defer file.close();\n\n    try file.writeAll(\"Hello from WASI!\\n\");\n    try stdout.print(\"Created file: wasi_test.txt\\n\", .{});\n\n    // Read file\n    try file.seekTo(0);\n    const contents = try file.readToEndAlloc(allocator, 1024);\n    defer allocator.free(contents);\n\n    try stdout.print(\"Contents: {s}\\n\", .{contents});\n\n    // Create directory\n    try cwd.makeDir(\"wasi_dir\");\n    try stdout.print(\"Created directory: wasi_dir\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 52,
        "chars": 1505
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 25,
        "end_line": 35,
        "code": "const c = @cImport({\n    @cInclude(\"stdio.h\");\n    @cInclude(\"stdlib.h\");\n    @cInclude(\"string.h\");\n});\n\npub fn main() !void {\n    _ = c.printf(\"Hello from C!\\n\");\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 9,
        "chars": 166
      },
      {
        "index": 2,
        "start_line": 55,
        "end_line": 72,
        "code": "pub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    exe.addIncludePath(b.path(\"c_headers\"));\n    exe.addIncludePath(b.path(\"vendor/library/include\"));\n    exe.linkLibC();\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 16,
        "chars": 430
      },
      {
        "index": 3,
        "start_line": 86,
        "end_line": 90,
        "code": "// Accessible in Zig as:\nconst max_size = c.MAX_SIZE;  // 1024\nconst pi = c.PI;              // 3.14159",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 103
      },
      {
        "index": 4,
        "start_line": 109,
        "end_line": 118,
        "code": "const builtin = @import(\"builtin\");\nconst build_options = @import(\"build_options\");\n\npub const c = @cImport({\n    @cInclude(\"hb.h\");\n    if (build_options.freetype) @cInclude(\"hb-ft.h\");\n    if (builtin.os.tag.isDarwin()) @cInclude(\"hb-coretext.h\");\n});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 8,
        "chars": 253
      },
      {
        "index": 5,
        "start_line": 126,
        "end_line": 139,
        "code": "// Separate import blocks for different subsystems\nconst graphics_c = @cImport({\n    @cInclude(\"vulkan/vulkan.h\");\n});\n\nconst audio_c = @cImport({\n    @cInclude(\"portaudio.h\");\n});\n\nconst db_c = @cImport({\n    @cInclude(\"sqlite3.h\");\n});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 12,
        "chars": 237
      },
      {
        "index": 6,
        "start_line": 149,
        "end_line": 160,
        "code": "// Declare C function to call from Zig\nextern \"c\" fn malloc(size: usize) ?*anyopaque;\nextern \"c\" fn free(ptr: ?*anyopaque) void;\nextern \"c\" fn strlen(s: [*:0]const u8) usize;\n\npub fn allocateBuffer(size: usize) ![]u8 {\n    const ptr = malloc(size) orelse return error.OutOfMemory;\n    const bytes = @as([*]u8, @ptrCast(ptr));\n    return bytes[0..size];\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 10,
        "chars": 354
      },
      {
        "index": 7,
        "start_line": 166,
        "end_line": 176,
        "code": "// Make Zig function callable from C\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nexport fn processData(data: [*]const u8, len: usize) i32 {\n    // Process data...\n    return 0; // Success code\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 9,
        "chars": 207
      },
      {
        "index": 8,
        "start_line": 192,
        "end_line": 204,
        "code": "fn standardC() callconv(.C) void {\n    // C calling convention (cdecl on x86)\n}\n\nfn windowsStdcall() callconv(.Stdcall) void {\n    // Windows stdcall convention\n}\n\nfn alwaysInline() callconv(.Inline) void {\n    // Always inlined at call site\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 11,
        "chars": 243
      },
      {
        "index": 9,
        "start_line": 212,
        "end_line": 224,
        "code": "extern var _mh_execute_header: mach_hdr;\nvar dummy_execute_header: mach_hdr = undefined;\n\ncomptime {\n    if (builtin.os.tag.isDarwin()) {\n        @export(&dummy_execute_header, .{\n            .name = \"_mh_execute_header\",\n            .linkage = .weak,\n        });\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 11,
        "chars": 271
      },
      {
        "index": 10,
        "start_line": 232,
        "end_line": 245,
        "code": "const CallbackFn = ?*const fn (ctx: ?*anyopaque, event: i32) callconv(.C) void;\n\nextern \"c\" fn register_callback(ctx: ?*anyopaque, callback: CallbackFn) void;\n\nfn myCallback(ctx: ?*anyopaque, event: i32) callconv(.C) void {\n    _ = ctx;\n    std.debug.print(\"Event: {d}\\n\", .{event});\n}\n\npub fn setupCallback() void {\n    register_callback(null, myCallback);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 12,
        "chars": 359
      },
      {
        "index": 11,
        "start_line": 253,
        "end_line": 260,
        "code": "pub extern \"c\" fn printf(format: [*:0]const u8, ...) c_int;\npub extern \"c\" fn scanf(format: [*:0]const u8, ...) c_int;\n\npub fn example() void {\n    _ = printf(\"Number: %d, String: %s\\n\", 42, \"test\");\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 6,
        "chars": 201
      },
      {
        "index": 12,
        "start_line": 273,
        "end_line": 276,
        "code": "// Assumes int is 32-bit everywhere\nextern fn process_value(value: i32) void;",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 77
      },
      {
        "index": 13,
        "start_line": 279,
        "end_line": 282,
        "code": "// Adapts to platform's int size\nextern fn process_value(value: c_int) void;",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 76
      },
      {
        "index": 14,
        "start_line": 330,
        "end_line": 345,
        "code": "pub const ino_t = switch (native_os) {\n    .linux => linux.ino_t,\n    .emscripten => emscripten.ino_t,\n    .wasi => wasi.inode_t,\n    .windows => windows.LARGE_INTEGER,\n    .haiku => i64,\n    else => u64,\n};\n\npub const time_t = switch (native_os) {\n    .linux => linux.time_t,\n    .windows => c_longlong,\n    else => isize,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 14,
        "chars": 326
      },
      {
        "index": 15,
        "start_line": 364,
        "end_line": 378,
        "code": "const ptr: [*c]u8 = malloc(100);\nif (ptr == null) return error.OutOfMemory;\n\n// Can use as single-item pointer\nptr[0] = 42;\n\n// Can use as many-item pointer\nptr[10] = 43;\n\n// Can compare with null\nif (ptr == null) {\n    // Handle error\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 13,
        "chars": 237
      },
      {
        "index": 16,
        "start_line": 386,
        "end_line": 398,
        "code": "// Zig may reorder fields for optimization\nconst BadPoint = struct {\n    x: f32,\n    y: f32,\n};\n\n// C-compatible layout, fields not reordered\nconst GoodPoint = extern struct {\n    x: f32,\n    y: f32,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 11,
        "chars": 202
      },
      {
        "index": 17,
        "start_line": 406,
        "end_line": 418,
        "code": "const MixedStruct = extern struct {\n    a: u8,     // 1 byte\n    // 3 bytes padding\n    b: u32,    // 4 bytes (requires 4-byte alignment)\n    c: u16,    // 2 bytes\n    // 2 bytes padding (to make struct size multiple of 4)\n};\n\ncomptime {\n    assert(@sizeOf(MixedStruct) == 12); // Not 7\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 11,
        "chars": 288
      },
      {
        "index": 18,
        "start_line": 426,
        "end_line": 437,
        "code": "const BitFlags = packed struct {\n    flag_a: bool,\n    flag_b: bool,\n    flag_c: bool,\n    unused: u5,\n};\n\ncomptime {\n    assert(@sizeOf(BitFlags) == 1); // Exactly 1 byte\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 10,
        "chars": 173
      },
      {
        "index": 19,
        "start_line": 453,
        "end_line": 458,
        "code": "const sqlite3 = opaque {};\n\nvar db: ?*sqlite3 = null;\nextern fn sqlite3_open(filename: [*:0]const u8, db: *?*sqlite3) c_int;",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 124
      },
      {
        "index": 20,
        "start_line": 466,
        "end_line": 476,
        "code": "const zig_str: []const u8 = \"Hello\";         // Not null-terminated\nconst c_str: [*:0]const u8 = \"Hello\";        // Null-terminated\n\n// Convert Zig string to C string\nconst allocator = std.heap.c_allocator;\nconst c_allocated = try allocator.dupeZ(u8, zig_str);\ndefer allocator.free(c_allocated);\n\n_ = c.printf(\"%s\\n\", c_allocated.ptr);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 9,
        "chars": 335
      },
      {
        "index": 21,
        "start_line": 484,
        "end_line": 495,
        "code": "// For C99/C11 code with stdbool.h\nextern fn modern_c_func(flag: c_bool) void;\n\n// For pre-C99 code\nextern fn legacy_c_func(flag: c_int) void;\n\npub fn example() void {\n    modern_c_func(true);   // Zig bool converts to c_bool\n    legacy_c_func(1);      // Use 1/0 for legacy code\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 10,
        "chars": 281
      },
      {
        "index": 22,
        "start_line": 505,
        "end_line": 535,
        "code": "pub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    exe.addCSourceFiles(.{\n        .files = &.{\n            \"c_src/helper.c\",\n            \"c_src/platform.c\",\n            \"c_src/wrapper.c\",\n        },\n        .flags = &.{\n            \"-Wall\",\n            \"-Wextra\",\n            \"-std=c99\",\n            \"-pedantic\",\n        },\n    });\n\n    exe.addIncludePath(b.path(\"c_src\"));\n    exe.linkLibC();\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 29,
        "chars": 654
      },
      {
        "index": 23,
        "start_line": 543,
        "end_line": 548,
        "code": "exe.linkLibC();                    // C standard library\nexe.linkSystemLibrary(\"sqlite3\");  // SQLite3\nexe.linkSystemLibrary(\"pthread\");  // POSIX threads\nexe.linkSystemLibrary(\"m\");        // Math library (Unix)",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 212
      },
      {
        "index": 24,
        "start_line": 556,
        "end_line": 562,
        "code": "if (target.result.os.tag.isDarwin()) {\n    exe.linkFramework(\"Cocoa\");\n    exe.linkFramework(\"Metal\");\n    exe.linkFramework(\"QuartzCore\");\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 5,
        "chars": 141
      },
      {
        "index": 25,
        "start_line": 570,
        "end_line": 608,
        "code": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const exe = b.addExecutable(.{\n        .name = \"app\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    var c_sources = std.ArrayList([]const u8).init(b.allocator);\n    defer c_sources.deinit();\n\n    // Common files\n    c_sources.append(\"src/common.c\") catch unreachable;\n\n    // Platform-specific files\n    if (target.result.os.tag == .windows) {\n        c_sources.append(\"src/windows.c\") catch unreachable;\n        exe.linkSystemLibrary(\"user32\");\n    } else if (target.result.os.tag.isDarwin()) {\n        c_sources.append(\"src/macos.c\") catch unreachable;\n        exe.linkFramework(\"Cocoa\");\n    } else {\n        c_sources.append(\"src/linux.c\") catch unreachable;\n        exe.linkSystemLibrary(\"X11\");\n    }\n\n    exe.addCSourceFiles(.{\n        .files = c_sources.items,\n        .flags = &.{\"-Wall\", \"-Wextra\"},\n    });\n    exe.linkLibC();\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 37,
        "chars": 1096
      },
      {
        "index": 26,
        "start_line": 616,
        "end_line": 646,
        "code": "const targets = &.{\n    .{ .cpu_arch = .x86_64, .os_tag = .linux },\n    .{ .cpu_arch = .aarch64, .os_tag = .macos },\n    .{ .cpu_arch = .x86_64, .os_tag = .windows },\n};\n\nfor (targets) |t| {\n    const resolved_target = b.resolveTargetQuery(t);\n\n    const exe = b.addExecutable(.{\n        .name = b.fmt(\"myapp-{s}-{s}\", .{\n            @tagName(t.cpu_arch.?),\n            @tagName(t.os_tag.?),\n        }),\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = resolved_target,\n            .optimize = optimize,\n        }),\n    });\n\n    exe.addCSourceFiles(.{\n        .files = &.{\"src/helper.c\"},\n        .flags = &.{\"-Wall\"},\n    });\n    exe.linkLibC();\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 29,
        "chars": 747
      },
      {
        "index": 27,
        "start_line": 756,
        "end_line": 770,
        "code": "const c = @cImport({\n    @cInclude(\"c_bridge.h\");\n});\n\npub fn example() !void {\n    const obj = c.MyCppClass_create(42) orelse return error.CreateFailed;\n    defer c.MyCppClass_destroy(obj);\n\n    const value = c.MyCppClass_getValue(obj);\n    std.debug.print(\"Value: {d}\\n\", .{value});\n\n    c.MyCppClass_setValue(obj, 100);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 13,
        "chars": 324
      },
      {
        "index": 28,
        "start_line": 805,
        "end_line": 811,
        "code": "const str = c.MyCppClass_getString(obj);\nif (str != null) {\n    defer c.MyCppClass_freeString(str);\n    std.debug.print(\"{s}\\n\", .{str});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 5,
        "chars": 139
      },
      {
        "index": 29,
        "start_line": 817,
        "end_line": 835,
        "code": "exe.addCSourceFiles(.{\n    .files = &.{\n        \"cpp/MyCppClass.cpp\",\n        \"cpp/c_bridge.cpp\",\n    },\n    .flags = &.{\n        \"-Wall\",\n        \"-Wextra\",\n        \"-std=c++17\",\n        \"-fno-exceptions\",  // Optional: disable exceptions\n        \"-fno-rtti\",        // Optional: disable RTTI\n    },\n});\n\nexe.addIncludePath(b.path(\"cpp\"));\nexe.linkLibC();\nexe.linkLibCpp();  // Link C++ standard library",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 17,
        "chars": 404
      },
      {
        "index": 30,
        "start_line": 845,
        "end_line": 863,
        "code": "// build.zig\nconst target = b.resolveTargetQuery(.{\n    .cpu_arch = .wasm32,\n    .os_tag = .freestanding,\n});\n\nconst lib = b.addExecutable(.{\n    .name = \"app\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    }),\n});\n\nlib.entry = .disabled;  // No main() needed for library\nlib.rdynamic = true;    // Export all public symbols",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 17,
        "chars": 427
      },
      {
        "index": 31,
        "start_line": 886,
        "end_line": 904,
        "code": "export fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nexport fn fibonacci(n: i32) i32 {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nexport fn processArray(ptr: [*]i32, len: i32) i32 {\n    var sum: i32 = 0;\n    var i: usize = 0;\n    while (i < len) : (i += 1) {\n        sum += ptr[i];\n    }\n    return sum;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 17,
        "chars": 343
      },
      {
        "index": 32,
        "start_line": 926,
        "end_line": 935,
        "code": "extern \"c\" fn consoleLog(ptr: [*]const u8, len: usize) void;\nextern \"c\" fn alert(ptr: [*]const u8, len: usize) void;\n\nexport fn greet(name_ptr: [*]const u8, name_len: usize) void {\n    const greeting = \"Hello, \";\n    consoleLog(greeting.ptr, greeting.len);\n    consoleLog(name_ptr, name_len);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 8,
        "chars": 294
      },
      {
        "index": 33,
        "start_line": 966,
        "end_line": 974,
        "code": "export fn getMessage() [*]const u8 {\n    return \"Hello from WASM\".ptr;\n}\n\nexport fn getMessageLength() usize {\n    return \"Hello from WASM\".len;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 7,
        "chars": 146
      },
      {
        "index": 34,
        "start_line": 1009,
        "end_line": 1021,
        "code": "const allocator = std.heap.wasm_allocator;\n\nexport fn allocate(size: usize) [*]u8 {\n    const slice = allocator.alloc(u8, size) catch return undefined;\n    return slice.ptr;\n}\n\nexport fn deallocate(ptr: [*]u8, size: usize) void {\n    const slice = ptr[0..size];\n    allocator.free(slice);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 11,
        "chars": 290
      },
      {
        "index": 35,
        "start_line": 1027,
        "end_line": 1043,
        "code": "export fn needMoreMemory() bool {\n    const pages_before = @wasmMemorySize(0);\n    const result = @wasmMemoryGrow(0, 10);  // Request 10 pages (640KB)\n\n    if (result < 0) {\n        return false;  // Growth failed\n    }\n\n    const pages_after = @wasmMemorySize(0);\n    std.debug.print(\"Grew from {d} to {d} pages\\n\", .{\n        pages_before, pages_after\n    });\n\n    return true;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 15,
        "chars": 381
      },
      {
        "index": 36,
        "start_line": 1065,
        "end_line": 1070,
        "code": "const target = b.resolveTargetQuery(.{\n    .cpu_arch = .wasm32,\n    .os_tag = .wasi,\n});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 88
      },
      {
        "index": 37,
        "start_line": 1104,
        "end_line": 1132,
        "code": "pub fn main() !void {\n    const allocator = std.heap.page_allocator;\n    const cwd = std.fs.cwd();\n\n    // Create file\n    const file = try cwd.createFile(\"output.txt\", .{});\n    defer file.close();\n\n    try file.writeAll(\"Hello from WASI\\n\");\n\n    // Read file\n    try file.seekTo(0);\n    const contents = try file.readToEndAlloc(allocator, 1024 * 1024);\n    defer allocator.free(contents);\n\n    std.debug.print(\"Contents: {s}\\n\", .{contents});\n\n    // Directory operations\n    try cwd.makeDir(\"test_dir\");\n    var dir = try cwd.openDir(\"test_dir\", .{ .iterate = true });\n    defer dir.close();\n\n    var iter = dir.iterate();\n    while (try iter.next()) |entry| {\n        std.debug.print(\"Found: {s}\\n\", .{entry.name});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 27,
        "chars": 728
      },
      {
        "index": 38,
        "start_line": 1136,
        "end_line": 1149,
        "code": "pub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var args = try std.process.argsWithAllocator(allocator);\n    defer args.deinit();\n\n    var i: usize = 0;\n    while (args.next()) |arg| {\n        std.debug.print(\"arg[{d}]: {s}\\n\", .{ i, arg });\n        i += 1;\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 12,
        "chars": 291
      },
      {
        "index": 39,
        "start_line": 1159,
        "end_line": 1174,
        "code": "pub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    const env_map = try std.process.getEnvMap(allocator);\n    defer env_map.deinit();\n\n    var iter = env_map.iterator();\n    while (iter.next()) |entry| {\n        std.debug.print(\"{s}={s}\\n\", .{\n            entry.key_ptr.*,\n            entry.value_ptr.*\n        });\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 14,
        "chars": 344
      },
      {
        "index": 42,
        "start_line": 1323,
        "end_line": 1352,
        "code": "pub fn build(b: *std.Build) void {\n    const exe = b.addExecutable(.{\n        .name = \"build_integration\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    // Compile C source files\n    exe.addCSourceFiles(.{\n        .files = &.{\n            \"c_lib/mylib.c\",\n        },\n        .flags = &.{\n            \"-Wall\",\n            \"-Wextra\",\n            \"-std=c99\",\n        },\n    });\n\n    // Add include path for C headers\n    exe.addIncludePath(b.path(\"c_lib\"));\n    exe.linkLibC();\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 28,
        "chars": 645
      },
      {
        "index": 43,
        "start_line": 1356,
        "end_line": 1378,
        "code": "const std = @import(\"std\");\n\nconst c = @cImport({\n    @cInclude(\"mylib.h\");\n});\n\npub fn addNumbers(a: i32, b: i32) i32 {\n    return c.add_numbers(a, b);\n}\n\npub fn printMessage(message: []const u8) !void {\n    const allocator = std.heap.c_allocator;\n    const c_message = try allocator.dupeZ(u8, message);\n    defer allocator.free(c_message);\n\n    c.print_message(c_message);\n}\n\npub fn calculateAverage(values: []const f64) f64 {\n    return c.calculate_average(values.ptr, values.len);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 21,
        "chars": 486
      },
      {
        "index": 44,
        "start_line": 1451,
        "end_line": 1466,
        "code": "const c = @cImport({\n    @cInclude(\"c_bridge.h\");\n});\n\npub fn main() !void {\n    const obj = c.MyCppClass_create(42) orelse return error.CreateFailed;\n    defer c.MyCppClass_destroy(obj);\n\n    const value = c.MyCppClass_getValue(obj);\n    std.debug.print(\"Initial value: {d}\\n\", .{value});\n\n    c.MyCppClass_increment(obj);\n    std.debug.print(\"After increment: {d}\\n\", .{c.MyCppClass_getValue(obj)});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 14,
        "chars": 403
      },
      {
        "index": 45,
        "start_line": 1485,
        "end_line": 1516,
        "code": "const std = @import(\"std\");\n\nexport fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\nexport fn fibonacci(n: i32) i32 {\n    if (n <= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nextern \"c\" fn consoleLog(ptr: [*]const u8, len: usize) void;\n\nexport fn greet(name_ptr: [*]const u8, name_len: usize) void {\n    const greeting = \"Hello, \";\n    consoleLog(greeting.ptr, greeting.len);\n    consoleLog(name_ptr, name_len);\n}\n\nconst allocator = std.heap.wasm_allocator;\n\nexport fn allocate(size: usize) [*]u8 {\n    const slice = allocator.alloc(u8, size) catch return undefined;\n    return slice.ptr;\n}\n\nexport fn deallocate(ptr: [*]u8, size: usize) void {\n    const slice = ptr[0..size];\n    allocator.free(slice);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 30,
        "chars": 727
      },
      {
        "index": 47,
        "start_line": 1663,
        "end_line": 1668,
        "code": "const ptr = c.malloc(1024);\nif (ptr == null) return error.OutOfMemory;\ndoSomething(ptr);\n// Memory leak - forgot to free!",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 121
      },
      {
        "index": 48,
        "start_line": 1671,
        "end_line": 1677,
        "code": "const ptr = c.malloc(1024);\nif (ptr == null) return error.OutOfMemory;\ndefer c.free(ptr);\ndoSomething(ptr);\n// ptr freed when scope exits",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 5,
        "chars": 137
      },
      {
        "index": 49,
        "start_line": 1690,
        "end_line": 1695,
        "code": "const ptr = c.malloc(100);\ndefer c.free(ptr);\nprocessData(ptr);\nc.free(ptr);  // Double free!",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 93
      },
      {
        "index": 50,
        "start_line": 1698,
        "end_line": 1703,
        "code": "const ptr = c.malloc(100);\ndefer c.free(ptr);\nprocessData(ptr);\n// Only freed once by defer",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 91
      },
      {
        "index": 51,
        "start_line": 1716,
        "end_line": 1721,
        "code": "const ptr = c.malloc(100);\nif (ptr == null) return error.OutOfMemory;\nc.free(ptr);\nuseData(ptr);  // Use-after-free!",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 116
      },
      {
        "index": 52,
        "start_line": 1724,
        "end_line": 1730,
        "code": "const ptr = c.malloc(100);\nif (ptr == null) return error.OutOfMemory;\ndefer c.free(ptr);\nuseData(ptr);\n// Free happens after use",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 5,
        "chars": 128
      },
      {
        "index": 53,
        "start_line": 1742,
        "end_line": 1746,
        "code": "const allocator = std.heap.page_allocator;\nconst ptr = try allocator.alloc(u8, 100);\nc.free(@ptrCast(ptr.ptr));  // Wrong allocator!",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 132
      },
      {
        "index": 54,
        "start_line": 1749,
        "end_line": 1753,
        "code": "const ptr = c.malloc(100);\nif (ptr == null) return error.OutOfMemory;\ndefer c.free(ptr);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 88
      },
      {
        "index": 55,
        "start_line": 1756,
        "end_line": 1760,
        "code": "const allocator = std.heap.c_allocator;  // C-compatible allocator\nconst ptr = try allocator.alloc(u8, 100);\ndefer allocator.free(ptr);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 135
      },
      {
        "index": 56,
        "start_line": 1771,
        "end_line": 1774,
        "code": "const zig_str = \"Hello\";\n_ = c.printf(zig_str.ptr);  // Undefined behavior - not null-terminated!",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 97
      },
      {
        "index": 57,
        "start_line": 1777,
        "end_line": 1780,
        "code": "const c_str: [*:0]const u8 = \"Hello\";\n_ = c.printf(c_str);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 58
      },
      {
        "index": 58,
        "start_line": 1789,
        "end_line": 1795,
        "code": "fn getBadString() [*:0]const u8 {\n    var buffer: [100]u8 = undefined;\n    _ = c.snprintf(@ptrCast(&buffer), 100, \"temp %d\", 42);\n    return @ptrCast(&buffer);  // Dangling pointer!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 5,
        "chars": 183
      },
      {
        "index": 59,
        "start_line": 1798,
        "end_line": 1802,
        "code": "fn getGoodString() [*:0]const u8 {\n    return \"constant string\";  // Static lifetime\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 86
      },
      {
        "index": 60,
        "start_line": 1805,
        "end_line": 1809,
        "code": "fn getAllocatedString(allocator: std.mem.Allocator) ![*:0]u8 {\n    return try std.fmt.allocPrintZ(allocator, \"temp {d}\", .{42});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 130
      },
      {
        "index": 61,
        "start_line": 1818,
        "end_line": 1822,
        "code": "var buf: [10]u8 = undefined;\n_ = c.sprintf(@ptrCast(&buf), \"Very long string %d\", 12345);\n// Buffer overflow!",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 109
      },
      {
        "index": 62,
        "start_line": 1825,
        "end_line": 1828,
        "code": "var buf: [100]u8 = undefined;\n_ = c.snprintf(@ptrCast(&buf), buf.len, \"Very long string %d\", 12345);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 100
      },
      {
        "index": 63,
        "start_line": 1831,
        "end_line": 1834,
        "code": "var buf: [100]u8 = undefined;\nconst result = try std.fmt.bufPrint(&buf, \"Very long string {d}\", .{12345});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 106
      },
      {
        "index": 64,
        "start_line": 1845,
        "end_line": 1847,
        "code": "extern fn process_value(x: i32) void;  // Assumes int is 32-bit",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 1,
        "chars": 63
      },
      {
        "index": 65,
        "start_line": 1850,
        "end_line": 1852,
        "code": "extern fn process_value(x: c_int) void;  // Platform-adaptive",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 1,
        "chars": 61
      },
      {
        "index": 66,
        "start_line": 1861,
        "end_line": 1865,
        "code": "extern fn c_function(ptr: [*]u8) void;  // Non-nullable\nconst ptr: ?[*]u8 = c.malloc(100);\nc_function(ptr);  // Type error",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 122
      },
      {
        "index": 67,
        "start_line": 1868,
        "end_line": 1873,
        "code": "extern fn c_function(ptr: [*c]u8) void;  // C pointer (nullable)\nconst ptr = c.malloc(100);\nif (ptr == null) return error.OutOfMemory;\nc_function(ptr);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 151
      },
      {
        "index": 68,
        "start_line": 1882,
        "end_line": 1887,
        "code": "const Point = struct {  // Zig may reorder\n    x: f32,\n    y: f32,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 69
      },
      {
        "index": 69,
        "start_line": 1890,
        "end_line": 1895,
        "code": "const Point = extern struct {  // C-compatible layout\n    x: f32,\n    y: f32,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 80
      },
      {
        "index": 70,
        "start_line": 1906,
        "end_line": 1909,
        "code": "exe.addCSourceFiles(.{ .files = &.{\"lib.c\"} });\n// Link error - undefined references",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 84
      },
      {
        "index": 71,
        "start_line": 1912,
        "end_line": 1915,
        "code": "exe.addCSourceFiles(.{ .files = &.{\"lib.c\"} });\nexe.linkLibC();",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 63
      },
      {
        "index": 72,
        "start_line": 1924,
        "end_line": 1929,
        "code": "// build.zig missing addIncludePath\nconst c = @cImport({\n    @cInclude(\"myheader.h\");  // Error: file not found\n});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 115
      },
      {
        "index": 73,
        "start_line": 1932,
        "end_line": 1941,
        "code": "// build.zig\nexe.addIncludePath(b.path(\"c_headers\"));\nexe.linkLibC();\n\n// main.zig\nconst c = @cImport({\n    @cInclude(\"myheader.h\");  // Found\n});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 8,
        "chars": 146
      },
      {
        "index": 74,
        "start_line": 1950,
        "end_line": 1953,
        "code": "exe.linkLibC();\n// Undefined references to pthread_create, etc.",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 63
      },
      {
        "index": 75,
        "start_line": 1956,
        "end_line": 1960,
        "code": "exe.linkLibC();\nexe.linkSystemLibrary(\"pthread\");\nexe.linkSystemLibrary(\"m\");  // Math library on Unix",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 3,
        "chars": 102
      },
      {
        "index": 76,
        "start_line": 2016,
        "end_line": 2019,
        "code": "const huge = allocator.alloc(u8, 5_000_000_000) catch unreachable;\n// OutOfMemory or trap",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 2,
        "chars": 89
      },
      {
        "index": 77,
        "start_line": 2022,
        "end_line": 2027,
        "code": "const max_size = 1_000_000_000;  // 1GB limit\nif (size > max_size) return error.TooLarge;\n\nconst result = allocator.alloc(u8, size) catch return error.OutOfMemory;",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 4,
        "chars": 163
      },
      {
        "index": 78,
        "start_line": 2041,
        "end_line": 2072,
        "code": "// ghostty/src/os/passwd.zig\nconst builtin = @import(\"builtin\");\n\nconst c = if (builtin.os.tag != .windows) @cImport({\n    @cInclude(\"sys/types.h\");\n    @cInclude(\"unistd.h\");\n    @cInclude(\"pwd.h\");\n}) else {};\n\ncomptime {\n    if (builtin.target.cpu.arch.isWasm()) {\n        @compileError(\"passwd is not available for wasm\");\n    }\n}\n\npub fn get(alloc: std.mem.Allocator) !Entry {\n    if (builtin.os.tag == .windows)\n        @compileError(\"passwd is not available on windows\");\n\n    var buf: [1024]u8 = undefined;\n    var pw: c.struct_passwd = undefined;\n    var pw_ptr: ?*c.struct_passwd = null;\n\n    const res = c.getpwuid_r(c.getuid(), &pw, &buf, buf.len, &pw_ptr);\n    if (res != 0) {\n        log.warn(\"error retrieving pw entry code={d}\", .{res});\n        return Entry{};\n    }\n    // Convert C strings to Zig strings...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 30,
        "chars": 828
      },
      {
        "index": 79,
        "start_line": 2084,
        "end_line": 2091,
        "code": "// ghostty/pkg/harfbuzz/c.zig\npub const c = @cImport({\n    @cInclude(\"hb.h\");\n    if (build_options.freetype) @cInclude(\"hb-ft.h\");\n    if (build_options.coretext) @cInclude(\"hb-coretext.h\");\n});",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 6,
        "chars": 195
      },
      {
        "index": 80,
        "start_line": 2101,
        "end_line": 2116,
        "code": "// tigerbeetle/src/clients/c/tb_client_exports.zig\npub const tb_client_t = extern struct {\n    @\"opaque\": [4]u64,\n\n    pub inline fn cast(self: *tb_client_t) *tb.ClientInterface {\n        return @ptrCast(self);\n    }\n\n    comptime {\n        assert(@sizeOf(tb_client_t) == @sizeOf(tb.ClientInterface));\n        assert(@bitSizeOf(tb_client_t) == @bitSizeOf(tb.ClientInterface));\n        assert(@alignOf(tb_client_t) == @alignOf(tb.ClientInterface));\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 14,
        "chars": 456
      },
      {
        "index": 81,
        "start_line": 2120,
        "end_line": 2141,
        "code": "pub const tb_init_status = enum(c_int) {\n    success = 0,\n    unexpected,\n    out_of_memory,\n    address_invalid,\n    address_limit_exceeded,\n    system_resources,\n    network_subsystem,\n};\n\npub fn init_error_to_status(err: tb.InitError) tb_init_status {\n    return switch (err) {\n        error.Unexpected => .unexpected,\n        error.OutOfMemory => .out_of_memory,\n        error.AddressInvalid => .address_invalid,\n        error.AddressLimitExceeded => .address_limit_exceeded,\n        error.SystemResources => .system_resources,\n        error.NetworkSubsystemFailed => .network_subsystem,\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 20,
        "chars": 600
      },
      {
        "index": 82,
        "start_line": 2145,
        "end_line": 2168,
        "code": "pub fn init(\n    tb_client_out: *tb_client_t,\n    cluster_id_ptr: *const [16]u8,\n    addresses_ptr: [*:0]const u8,\n    addresses_len: u32,\n    completion_ctx: usize,\n    completion_callback: tb_completion_t,\n) callconv(.c) tb_init_status {\n    const addresses = @as([*]const u8, @ptrCast(addresses_ptr))[0..addresses_len];\n\n    const client = tb_client_out.cast();\n    client.init(\n        cluster_id_ptr.*,\n        addresses,\n        @ptrFromInt(completion_ctx),\n        completion_callback,\n    ) catch |err| {\n        return init_error_to_status(err);\n    };\n\n    return .success;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 22,
        "chars": 585
      },
      {
        "index": 83,
        "start_line": 2182,
        "end_line": 2194,
        "code": "fn processResource() !void {\n    const resource = try allocateResource();\n    defer deallocateResource(resource);\n    errdefer logErrorState(resource);\n\n    try resource.initialize();\n    errdefer resource.deinitialize();\n\n    try resource.processData();\n    // Cleanup happens in reverse order\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 11,
        "chars": 296
      },
      {
        "index": 84,
        "start_line": 2202,
        "end_line": 2239,
        "code": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n\n    var c_sources = std.ArrayList([]const u8).init(b.allocator);\n    defer c_sources.deinit();\n\n    // Common cross-platform code\n    c_sources.append(\"src/common.c\") catch unreachable;\n\n    // Platform-specific sources\n    switch (target.result.os.tag) {\n        .windows => {\n            c_sources.append(\"src/platform/windows.c\") catch unreachable;\n            exe.linkSystemLibrary(\"user32\");\n            exe.linkSystemLibrary(\"gdi32\");\n        },\n        .macos, .ios => {\n            c_sources.append(\"src/platform/darwin.c\") catch unreachable;\n            exe.linkFramework(\"Cocoa\");\n            exe.linkFramework(\"Metal\");\n        },\n        .linux => {\n            c_sources.append(\"src/platform/linux.c\") catch unreachable;\n            exe.linkSystemLibrary(\"X11\");\n            exe.linkSystemLibrary(\"pthread\");\n        },\n        else => {\n            c_sources.append(\"src/platform/fallback.c\") catch unreachable;\n        },\n    }\n\n    exe.addCSourceFiles(.{\n        .files = c_sources.items,\n        .flags = common_flags,\n    });\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 36,
        "chars": 1130
      },
      {
        "index": 85,
        "start_line": 2245,
        "end_line": 2263,
        "code": "test \"C allocation and deallocation\" {\n    const ptr = c.malloc(1024);\n    try testing.expect(ptr != null);\n    defer c.free(ptr);\n\n    const bytes = @as([*]u8, @ptrCast(ptr));\n    bytes[0] = 42;\n    try testing.expectEqual(@as(u8, 42), bytes[0]);\n}\n\ntest \"C function error handling\" {\n    const result = c.risky_function();\n    if (result < 0) {\n        // Expected error path\n        try testing.expect(result == c.ERROR_CODE);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 17,
        "chars": 437
      },
      {
        "index": 86,
        "start_line": 2276,
        "end_line": 2284,
        "code": "// \u274c Inefficient: Multiple C calls\nfor (items) |item| {\n    c.process_item(&item);\n}\n\n// \u2705 Efficient: Single batched call\nc.process_items(items.ptr, items.len);",
        "file": "/home/jack/workspace/zig_guide/sections/11_interoperability/content.md",
        "lines": 7,
        "chars": 160
      }
    ]
  },
  {
    "chapter": "12_testing_benchmarking",
    "content_file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
    "total_blocks": 84,
    "runnable_blocks": 11,
    "snippet_blocks": 73,
    "runnable": [
      {
        "index": 1,
        "start_line": 49,
        "end_line": 63,
        "code": "const std = @import(\"std\");\nconst testing = std.testing;\n\n// Named test - appears in output\ntest \"arithmetic operations\" {\n    const result = 2 + 2;\n    try testing.expectEqual(4, result);\n}\n\n// Anonymous test - identified by file and line\ntest {\n    try testing.expect(true);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 13,
        "chars": 278
      },
      {
        "index": 2,
        "start_line": 86,
        "end_line": 112,
        "code": "const builtin = @import(\"builtin\");\n\npub const Database = struct {\n    data: []u8,\n\n    pub fn query(self: *Database, sql: []const u8) !Result {\n        // Production implementation\n    }\n\n    // Test-only helper - not compiled in release builds\n    pub fn seedTestData(self: *Database) !void {\n        if (!builtin.is_test) @compileError(\"seedTestData is test-only\");\n        // Insert test fixtures\n    }\n};\n\ntest \"database with test data\" {\n    var db = try Database.init(testing.allocator);\n    defer db.deinit();\n\n    try db.seedTestData(); // OK in tests\n\n    const result = try db.query(\"SELECT * FROM users\");\n    try testing.expect(result.rows.len > 0);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 25,
        "chars": 664
      },
      {
        "index": 13,
        "start_line": 277,
        "end_line": 295,
        "code": "const std = @import(\"std\");\nconst testing = std.testing;\n\ntest \"handle allocation failure\" {\n    var failing = testing.FailingAllocator.init(testing.allocator, .{ .fail_index = 3 });\n    const allocator = failing.allocator();\n\n    // First 2 allocations succeed, 3rd fails\n    const a1 = try allocator.alloc(u8, 10);\n    defer allocator.free(a1);\n\n    const a2 = try allocator.alloc(u8, 10);\n    defer allocator.free(a2);\n\n    const a3 = allocator.alloc(u8, 10);\n    try testing.expectError(error.OutOfMemory, a3);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 516
      },
      {
        "index": 33,
        "start_line": 775,
        "end_line": 787,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var timer = try std.time.Timer.start();\n\n    // Code to measure\n    expensiveOperation();\n\n    const elapsed_ns = timer.read();\n    std.debug.print(\"Elapsed: {d} ns\\n\", .{elapsed_ns});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 11,
        "chars": 241
      },
      {
        "index": 47,
        "start_line": 1261,
        "end_line": 1312,
        "code": "const std = @import(\"std\");\nconst testing = std.testing;\n\n/// Divide two integers, returning an error on division by zero.\npub fn divide(a: i32, b: i32) !i32 {\n    if (b == 0) return error.DivisionByZero;\n    return @divTrunc(a, b);\n}\n\n/// Calculate factorial (iterative version).\n/// Returns error on negative input or overflow.\npub fn factorial(n: i32) !i64 {\n    if (n < 0) return error.NegativeInput;\n    if (n == 0 or n == 1) return 1;\n\n    var result: i64 = 1;\n    var i: i32 = 2;\n    while (i <= n) : (i += 1) {\n        const old_result = result;\n        result = @as(i64, @intCast(i)) * result;\n        if (@divTrunc(result, @as(i64, @intCast(i))) != old_result) {\n            return error.Overflow;\n        }\n    }\n    return result;\n}\n\ntest \"divide: successful division\" {\n    try testing.expectEqual(@as(i32, 5), try divide(10, 2));\n    try testing.expectEqual(@as(i32, 1), try divide(7, 5));\n    try testing.expectEqual(@as(i32, -2), try divide(-10, 5));\n}\n\ntest \"divide: division by zero\" {\n    try testing.expectError(error.DivisionByZero, divide(10, 0));\n    try testing.expectError(error.DivisionByZero, divide(0, 0));\n    try testing.expectError(error.DivisionByZero, divide(-10, 0));\n}\n\ntest \"factorial: basic cases\" {\n    try testing.expectEqual(@as(i64, 1), try factorial(0));\n    try testing.expectEqual(@as(i64, 1), try factorial(1));\n    try testing.expectEqual(@as(i64, 6), try factorial(3));\n    try testing.expectEqual(@as(i64, 120), try factorial(5));\n}\n\ntest \"factorial: error cases\" {\n    try testing.expectError(error.NegativeInput, factorial(-1));\n    try testing.expectError(error.NegativeInput, factorial(-10));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 50,
        "chars": 1646
      },
      {
        "index": 48,
        "start_line": 1343,
        "end_line": 1376,
        "code": "const std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst testing = std.testing;\n\n// Only compile this module in test mode\ncomptime {\n    if (!builtin.is_test) {\n        @compileError(\"test_helpers module is only for tests\");\n    }\n}\n\n/// Helper to create a test allocator with tracking\npub fn TestAllocator() type {\n    return struct {\n        gpa: std.heap.GeneralPurposeAllocator(.{}),\n\n        pub fn init() @This() {\n            return .{ .gpa = .{} };\n        }\n\n        pub fn allocator(self: *@This()) std.mem.Allocator {\n            return self.gpa.allocator();\n        }\n\n        pub fn deinit(self: *@This()) !void {\n            const leaked = self.gpa.deinit();\n            if (leaked == .leak) {\n                return error.MemoryLeak;\n            }\n        }\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 32,
        "chars": 794
      },
      {
        "index": 49,
        "start_line": 1380,
        "end_line": 1399,
        "code": "const std = @import(\"std\");\n\n/// Standard test data for numeric operations\npub const test_numbers = [_]i32{ 1, 2, 3, 4, 5, 10, 42, 100, 1000 };\n\n/// Standard test strings\npub const test_strings = [_][]const u8{\n    \"\",\n    \"a\",\n    \"hello\",\n    \"Hello, World!\",\n    \"The quick brown fox jumps over the lazy dog\",\n};\n\n/// Create a test arena allocator\npub fn createTestArena(backing: std.mem.Allocator) std.heap.ArenaAllocator {\n    return std.heap.ArenaAllocator.init(backing);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 18,
        "chars": 479
      },
      {
        "index": 50,
        "start_line": 1419,
        "end_line": 1487,
        "code": "const std = @import(\"std\");\nconst testing = std.testing;\n\n/// Test arithmetic operations with multiple test cases\ntest \"add: parameterized cases\" {\n    const TestCase = struct {\n        a: i32,\n        b: i32,\n        expected: i32,\n    };\n\n    const cases = [_]TestCase{\n        .{ .a = 0, .b = 0, .expected = 0 },\n        .{ .a = 1, .b = 2, .expected = 3 },\n        .{ .a = -5, .b = 5, .expected = 0 },\n        .{ .a = 100, .b = -50, .expected = 50 },\n        .{ .a = 2147483647, .b = 0, .expected = 2147483647 },\n    };\n\n    inline for (cases) |case| {\n        const result = case.a + case.b;\n        try testing.expectEqual(case.expected, result);\n    }\n}\n\n/// Test string operations across multiple inputs\ntest \"string length: table-driven\" {\n    const cases = [_]struct {\n        input: []const u8,\n        expected: usize,\n    }{\n        .{ .input = \"\", .expected = 0 },\n        .{ .input = \"a\", .expected = 1 },\n        .{ .input = \"hello\", .expected = 5 },\n        .{ .input = \"Hello, World!\", .expected = 13 },\n    };\n\n    inline for (cases) |case| {\n        try testing.expectEqual(case.expected, case.input.len);\n    }\n}\n\n/// Test generic operations across multiple types\ntest \"ArrayList: generic type testing\" {\n    const types = [_]type{ u8, u16, u32, u64, i8, i16, i32, i64 };\n\n    inline for (types) |T| {\n        var list = std.ArrayList(T).init(testing.allocator);\n        defer list.deinit();\n\n        const test_value: T = 42;\n        try list.append(test_value);\n\n        try testing.expectEqual(@as(usize, 1), list.items.len);\n        try testing.expectEqual(test_value, list.items[0]);\n    }\n}\n\n/// Comptime test generation for powers of two\ntest \"powers of two: comptime generation\" {\n    const powers = [_]u32{ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 };\n\n    inline for (powers, 0..) |expected, i| {\n        const result = std.math.pow(u32, 2, i);\n        try testing.expectEqual(expected, result);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 67,
        "chars": 1935
      },
      {
        "index": 51,
        "start_line": 1507,
        "end_line": 1606,
        "code": "const std = @import(\"std\");\nconst testing = std.testing;\n\ntest \"memory leak detection\" {\n    var list = try std.ArrayList(u32).initCapacity(testing.allocator, 10);\n    defer list.deinit(); // Required - test fails without this\n\n    try list.append(42);\n    try list.append(43);\n\n    try testing.expectEqual(@as(usize, 2), list.items.len);\n    // testing.allocator automatically checks for leaks when test completes\n}\n\ntest \"allocation failure handling\" {\n    var failing = testing.FailingAllocator.init(testing.allocator, .{ .fail_index = 0 });\n    const allocator = failing.allocator();\n\n    // This allocation should fail immediately\n    const result = allocator.alloc(u8, 100);\n    try testing.expectError(error.OutOfMemory, result);\n}\n\ntest \"robust error path testing\" {\n    // Test allocation failure at different points\n    var fail_index: u32 = 0;\n    while (fail_index < 5) : (fail_index += 1) {\n        var failing = testing.FailingAllocator.init(testing.allocator, .{\n            .fail_index = fail_index\n        });\n        const allocator = failing.allocator();\n\n        const result = createDataStructure(allocator);\n\n        if (result) |structure| {\n            defer structure.deinit(allocator);\n            // Verify structure is valid\n            try testing.expect(structure.isValid());\n        } else |err| {\n            // Should only fail with OutOfMemory\n            try testing.expectEqual(error.OutOfMemory, err);\n        }\n    }\n}\n\nfn createDataStructure(allocator: std.mem.Allocator) !DataStructure {\n    var ds = DataStructure{};\n\n    // Multiple allocations - test failure at each point\n    ds.buffer1 = try allocator.alloc(u8, 100);\n    errdefer allocator.free(ds.buffer1);\n\n    ds.buffer2 = try allocator.alloc(u32, 50);\n    errdefer allocator.free(ds.buffer2);\n\n    ds.buffer3 = try allocator.alloc(i64, 25);\n    errdefer allocator.free(ds.buffer3);\n\n    return ds;\n}\n\nconst DataStructure = struct {\n    buffer1: []u8 = undefined,\n    buffer2: []u32 = undefined,\n    buffer3: []i64 = undefined,\n\n    pub fn isValid(self: DataStructure) bool {\n        return self.buffer1.len == 100 and\n               self.buffer2.len == 50 and\n               self.buffer3.len == 25;\n    }\n\n    pub fn deinit(self: DataStructure, allocator: std.mem.Allocator) void {\n        allocator.free(self.buffer1);\n        allocator.free(self.buffer2);\n        allocator.free(self.buffer3);\n    }\n};\n\ntest \"arena allocator pattern\" {\n    // Arena simplifies cleanup for multiple allocations\n    var arena = std.heap.ArenaAllocator.init(testing.allocator);\n    defer arena.deinit();\n\n    const allocator = arena.allocator();\n\n    // Multiple allocations\n    const data1 = try allocator.alloc(u8, 100);\n    const data2 = try allocator.alloc(u32, 50);\n    const data3 = try allocator.alloc(i64, 25);\n\n    // Use the data\n    data1[0] = 42;\n    data2[0] = 100;\n    data3[0] = -50;\n\n    // No individual free() needed - arena.deinit() frees everything\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 98,
        "chars": 2953
      },
      {
        "index": 53,
        "start_line": 1708,
        "end_line": 1757,
        "code": "const std = @import(\"std\");\nconst benchmark_mod = @import(\"benchmark.zig\");\n\nfn sumIterative(n: u64) u64 {\n    var sum: u64 = 0;\n    var i: u64 = 1;\n    while (i <= n) : (i += 1) {\n        sum += i;\n    }\n    return sum;\n}\n\nfn sumFormula(n: u64) u64 {\n    return (n * (n + 1)) / 2;\n}\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    const iterations = 1_000_000;\n    const n = 1000;\n\n    try stdout.print(\"Benchmarking sum algorithms ({d} iterations)...\\n\\n\", .{iterations});\n\n    // Benchmark iterative approach\n    const iterative_result = try benchmark_mod.benchmarkWithArg(\n        @TypeOf(sumIterative),\n        sumIterative,\n        n,\n        iterations,\n    );\n\n    // Benchmark formula approach\n    const formula_result = try benchmark_mod.benchmarkWithArg(\n        @TypeOf(sumFormula),\n        sumFormula,\n        n,\n        iterations,\n    );\n\n    // Compare results\n    try benchmark_mod.compareBenchmarks(\n        stdout,\n        \"Formula\",\n        formula_result,\n        \"Iterative\",\n        iterative_result,\n    );\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 48,
        "chars": 1059
      },
      {
        "index": 77,
        "start_line": 2349,
        "end_line": 2360,
        "code": "const Snap = @import(\"snaptest.zig\").Snap;\nconst snap = Snap.snap_fn(\"src\");\n\ntest \"complex output\" {\n    const result = complexComputation();\n    try snap(@src(),\n        \\\\Expected output line 1\n        \\\\Expected output line 2\n    ).diff_fmt(\"{}\", .{result});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 10,
        "chars": 264
      }
    ],
    "snippets": [
      {
        "index": 3,
        "start_line": 116,
        "end_line": 123,
        "code": "pub const Snap = struct {\n    comptime {\n        assert(builtin.is_test);\n    }\n    // Snapshot testing implementation\n};",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 6,
        "chars": 121
      },
      {
        "index": 4,
        "start_line": 168,
        "end_line": 171,
        "code": "try testing.expect(value > 0);\ntry testing.expect(list.items.len == 5);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 2,
        "chars": 71
      },
      {
        "index": 5,
        "start_line": 179,
        "end_line": 182,
        "code": "try testing.expectEqual(42, computeAnswer());\ntry testing.expectEqual(@as(u32, 100), counter);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 2,
        "chars": 94
      },
      {
        "index": 6,
        "start_line": 190,
        "end_line": 193,
        "code": "const result = parseNumber(\"invalid\");\ntry testing.expectError(error.InvalidFormat, result);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 2,
        "chars": 92
      },
      {
        "index": 7,
        "start_line": 205,
        "end_line": 209,
        "code": "const expected = [_]u8{ 1, 2, 3 };\nconst actual = list.items;\ntry testing.expectEqualSlices(u8, &expected, actual);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 3,
        "chars": 115
      },
      {
        "index": 8,
        "start_line": 215,
        "end_line": 217,
        "code": "try testing.expectEqualStrings(\"hello\", result);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 1,
        "chars": 48
      },
      {
        "index": 9,
        "start_line": 225,
        "end_line": 228,
        "code": "const result = computeCircleArea(5.0);\ntry testing.expectApproxEqAbs(78.54, result, 0.01);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 2,
        "chars": 90
      },
      {
        "index": 10,
        "start_line": 234,
        "end_line": 236,
        "code": "try testing.expectApproxEqRel(1000000.0, result, 0.0001); // 0.01% tolerance",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 1,
        "chars": 76
      },
      {
        "index": 11,
        "start_line": 249,
        "end_line": 257,
        "code": "test \"allocator usage\" {\n    const list = try std.ArrayList(u32).initCapacity(testing.allocator, 10);\n    defer list.deinit(); // Essential - test fails without this\n\n    try list.append(42);\n    try testing.expectEqual(1, list.items.len);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 7,
        "chars": 241
      },
      {
        "index": 12,
        "start_line": 263,
        "end_line": 269,
        "code": "pub var allocator_instance: std.heap.GeneralPurposeAllocator(.{\n    .stack_trace_frames = if (std.debug.sys_can_stack_trace) 10 else 0,\n    .resize_stack_traces = true,\n    .canary = @truncate(0x2731e675c3a701ba),\n}) = .init;",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 5,
        "chars": 225
      },
      {
        "index": 14,
        "start_line": 299,
        "end_line": 317,
        "code": "pub const FailingAllocator = struct {\n    likelihood: u32,\n\n    /// Chance of failure is 1/likelihood\n    pub fn init(internal_allocator: std.mem.Allocator, likelihood: u32) FailingAllocator {\n        return .{\n            .internal_allocator = internal_allocator,\n            .random = .init(std.crypto.random.int(u64)),\n            .likelihood = likelihood,\n        };\n    }\n\n    fn shouldFail(self: *FailingAllocator) bool {\n        if (self.likelihood == std.math.maxInt(u32)) return false;\n        return 0 == self.random.random().intRangeAtMostBiased(u32, 0, self.likelihood);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 591
      },
      {
        "index": 15,
        "start_line": 327,
        "end_line": 331,
        "code": "var prng = std.Random.DefaultPrng.init(testing.random_seed);\nconst random = prng.random();\nconst value = random.int(u32);",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 3,
        "chars": 121
      },
      {
        "index": 16,
        "start_line": 339,
        "end_line": 341,
        "code": "try testing.expectFmt(\"value: 42\", \"value: {d}\", .{42});",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 1,
        "chars": 56
      },
      {
        "index": 17,
        "start_line": 353,
        "end_line": 374,
        "code": "// src/queue.zig\npub const Queue = struct {\n    items: []i32,\n\n    pub fn push(self: *Queue, value: i32) !void {\n        // Implementation\n    }\n};\n\ntest \"Queue: basic operations\" {\n    var queue = Queue.init(testing.allocator);\n    defer queue.deinit();\n\n    try queue.push(42);\n    try testing.expectEqual(1, queue.len());\n}\n\ntest \"Queue: edge cases\" {\n    // More tests\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 20,
        "chars": 374
      },
      {
        "index": 18,
        "start_line": 433,
        "end_line": 442,
        "code": "// testing/fixtures.zig\npub fn initStorage(allocator: std.mem.Allocator, options: StorageOptions) !Storage {\n    return try Storage.init(allocator, options);\n}\n\npub fn initGrid(allocator: std.mem.Allocator, superblock: *SuperBlock) !Grid {\n    return try Grid.init(allocator, .{ .superblock = superblock });\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 8,
        "chars": 309
      },
      {
        "index": 19,
        "start_line": 446,
        "end_line": 464,
        "code": "pub const cluster: u128 = 0;\npub const replica: u8 = 0;\npub const replica_count: u8 = 6;\n\npub fn initTime(options: struct {\n    resolution: u64 = constants.tick_ms * std.time.ns_per_ms,\n    offset_type: OffsetType = .linear,\n    offset_coefficient_A: i64 = 0,\n    offset_coefficient_B: i64 = 0,\n}) TimeSim {\n    return .{\n        .resolution = options.resolution,\n        .offset_type = options.offset_type,\n        .offset_coefficient_A = options.offset_coefficient_A,\n        .offset_coefficient_B = options.offset_coefficient_B,\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 540
      },
      {
        "index": 20,
        "start_line": 476,
        "end_line": 491,
        "code": "test \"with setup and teardown\" {\n    // Setup\n    var arena = std.heap.ArenaAllocator.init(testing.allocator);\n    defer arena.deinit(); // Teardown\n\n    const allocator = arena.allocator();\n\n    // Test body\n    const list = try std.ArrayList(u32).initCapacity(allocator, 10);\n    try list.append(42);\n    try testing.expectEqual(1, list.items.len);\n\n    // Arena deinit handles cleanup automatically\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 14,
        "chars": 403
      },
      {
        "index": 21,
        "start_line": 495,
        "end_line": 505,
        "code": "test \"complex test with multiple allocations\" {\n    var arena = std.heap.ArenaAllocator.init(testing.allocator);\n    defer arena.deinit();\n\n    // All allocations from arena freed at once\n    const data1 = try arena.allocator().alloc(u8, 100);\n    const data2 = try arena.allocator().alloc(u32, 50);\n    // No individual free() needed\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 9,
        "chars": 336
      },
      {
        "index": 22,
        "start_line": 513,
        "end_line": 541,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Main executable\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    b.installArtifact(exe);\n\n    // Test executable\n    const tests = b.addTest(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const run_tests = b.addRunArtifact(tests);\n\n    const test_step = b.step(\"test\", \"Run unit tests\");\n    test_step.dependOn(&run_tests.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 27,
        "chars": 711
      },
      {
        "index": 23,
        "start_line": 549,
        "end_line": 566,
        "code": "test \"ArrayList: append increases length\" {\n    var list = std.ArrayList(u32).init(testing.allocator);\n    defer list.deinit();\n\n    try list.append(42);\n    try testing.expectEqual(1, list.items.len);\n}\n\ntest \"HashMap: remove decrements count\" {\n    var map = std.AutoHashMap(u32, u32).init(testing.allocator);\n    defer map.deinit();\n\n    try map.put(1, 100);\n    _ = map.remove(1);\n    try testing.expectEqual(0, map.count());\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 16,
        "chars": 431
      },
      {
        "index": 24,
        "start_line": 578,
        "end_line": 597,
        "code": "test \"integer parsing: multiple cases\" {\n    const TestCase = struct {\n        input: []const u8,\n        expected: i32,\n    };\n\n    const cases = [_]TestCase{\n        .{ .input = \"0\", .expected = 0 },\n        .{ .input = \"42\", .expected = 42 },\n        .{ .input = \"-10\", .expected = -10 },\n        .{ .input = \"2147483647\", .expected = 2147483647 },\n    };\n\n    inline for (cases) |case| {\n        const result = try std.fmt.parseInt(i32, case.input, 10);\n        try testing.expectEqual(case.expected, result);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 18,
        "chars": 521
      },
      {
        "index": 25,
        "start_line": 603,
        "end_line": 615,
        "code": "test \"generic list operations\" {\n    const types = [_]type{ u8, u16, u32, u64 };\n\n    inline for (types) |T| {\n        var list = std.ArrayList(T).init(testing.allocator);\n        defer list.deinit();\n\n        try list.append(1);\n        try testing.expectEqual(@as(T, 1), list.items[0]);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 11,
        "chars": 296
      },
      {
        "index": 26,
        "start_line": 623,
        "end_line": 637,
        "code": "fn makeTest(comptime value: i32) type {\n    return struct {\n        test {\n            try testing.expectEqual(value, value);\n        }\n    };\n}\n\ntest {\n    _ = makeTest(1);\n    _ = makeTest(2);\n    _ = makeTest(3);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 13,
        "chars": 217
      },
      {
        "index": 27,
        "start_line": 645,
        "end_line": 653,
        "code": "test \"no memory leaks\" {\n    var list = try std.ArrayList(u32).initCapacity(testing.allocator, 10);\n    defer list.deinit(); // Required - test fails without this\n\n    try list.append(42);\n    try testing.expectEqual(1, list.items.len);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 7,
        "chars": 238
      },
      {
        "index": 28,
        "start_line": 664,
        "end_line": 672,
        "code": "test \"handle allocation failure gracefully\" {\n    var failing = testing.FailingAllocator.init(testing.allocator, .{ .fail_index = 0 });\n    const allocator = failing.allocator();\n\n    const result = std.ArrayList(u32).initCapacity(allocator, 100);\n    try testing.expectError(error.OutOfMemory, result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 7,
        "chars": 305
      },
      {
        "index": 29,
        "start_line": 676,
        "end_line": 694,
        "code": "test \"robustness under allocation failures\" {\n    var i: u32 = 0;\n    while (i < 10) : (i += 1) {\n        var failing = testing.FailingAllocator.init(testing.allocator, .{ .fail_index = i });\n        const allocator = failing.allocator();\n\n        const result = createComplexStructure(allocator);\n\n        // Either succeeds or fails with OutOfMemory\n        if (result) |value| {\n            defer value.deinit(allocator);\n            try testing.expect(value.isValid());\n        } else |err| {\n            try testing.expectEqual(error.OutOfMemory, err);\n        }\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 575
      },
      {
        "index": 30,
        "start_line": 702,
        "end_line": 712,
        "code": "test \"parseNumber: handles invalid input\" {\n    const result = parseNumber(\"not a number\");\n    try testing.expectError(error.InvalidFormat, result);\n}\n\ntest \"File.open: handles missing file\" {\n    const result = std.fs.cwd().openFile(\"nonexistent.txt\", .{});\n    try testing.expectError(error.FileNotFound, result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 9,
        "chars": 318
      },
      {
        "index": 31,
        "start_line": 720,
        "end_line": 741,
        "code": "test \"concurrent atomic counter\" {\n    var counter = std.atomic.Value(u32).init(0);\n\n    var threads: [4]std.Thread = undefined;\n    for (&threads) |*t| {\n        t.* = try std.Thread.spawn(.{}, struct {\n            fn run(c: *std.atomic.Value(u32)) void {\n                for (0..1000) |_| {\n                    _ = c.fetchAdd(1, .monotonic);\n                }\n            }\n        }.run, .{&counter});\n    }\n\n    for (threads) |t| {\n        t.join();\n    }\n\n    try testing.expectEqual(4000, counter.load(.monotonic));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 20,
        "chars": 523
      },
      {
        "index": 32,
        "start_line": 749,
        "end_line": 763,
        "code": "pub const TimeSim = struct {\n    resolution: u64,\n    ticks: u64 = 0,\n\n    pub fn tick(self: *TimeSim) void {\n        self.ticks += 1;\n    }\n\n    fn monotonic(context: *anyopaque) u64 {\n        const self: *TimeSim = @ptrCast(@alignCast(context));\n        return self.ticks * self.resolution;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 13,
        "chars": 301
      },
      {
        "index": 34,
        "start_line": 804,
        "end_line": 808,
        "code": "pub fn doNotOptimizeAway(value: anytype) void {\n    asm volatile (\"\" :: [_]\"r,m\" (value));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 3,
        "chars": 92
      },
      {
        "index": 35,
        "start_line": 813,
        "end_line": 819,
        "code": "// \u274c Compiler may optimize away the entire loop\nfor (0..1000) |_| {\n    const result = expensiveFunction();\n    // result unused - dead code elimination\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 5,
        "chars": 154
      },
      {
        "index": 36,
        "start_line": 822,
        "end_line": 828,
        "code": "// \u2705 Compiler must keep the function call\nfor (0..1000) |_| {\n    const result = expensiveFunction();\n    std.mem.doNotOptimizeAway(&result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 5,
        "chars": 143
      },
      {
        "index": 37,
        "start_line": 839,
        "end_line": 854,
        "code": "// Warm-up: 10% of iterations or max 100\nconst warmup_iterations = @min(iterations / 10, 100);\nfor (0..warmup_iterations) |_| {\n    const result = func();\n    std.mem.doNotOptimizeAway(&result);\n}\n\n// Now measure with warm caches and stable CPU frequency\nvar timer = try std.time.Timer.start();\nfor (0..iterations) |_| {\n    const result = func();\n    std.mem.doNotOptimizeAway(&result);\n}\nconst elapsed = timer.read();",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 14,
        "chars": 419
      },
      {
        "index": 38,
        "start_line": 866,
        "end_line": 903,
        "code": "const num_samples = 10;\nconst iterations_per_sample = iterations / num_samples;\n\nvar samples: [10]u64 = undefined;\n\nfor (0..num_samples) |i| {\n    var timer = try std.time.Timer.start();\n\n    for (0..iterations_per_sample) |_| {\n        const result = func();\n        std.mem.doNotOptimizeAway(&result);\n    }\n\n    samples[i] = timer.read();\n}\n\n// Compute min, max, mean, variance\nvar min_ns: u64 = std.math.maxInt(u64);\nvar max_ns: u64 = 0;\nvar total_ns: u64 = 0;\n\nfor (samples) |sample| {\n    min_ns = @min(min_ns, sample);\n    max_ns = @max(max_ns, sample);\n    total_ns += sample;\n}\n\nconst avg_ns = total_ns / num_samples;\n\n// Variance\nvar variance_sum: u128 = 0;\nfor (samples) |sample| {\n    const diff = if (sample > avg_ns) sample - avg_ns else avg_ns - sample;\n    variance_sum += @as(u128, diff) * @as(u128, diff);\n}\nconst variance = variance_sum / num_samples;",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 36,
        "chars": 870
      },
      {
        "index": 39,
        "start_line": 932,
        "end_line": 939,
        "code": "const benchmark = b.addExecutable(.{\n    .name = \"benchmark\",\n    .root_source_file = b.path(\"src/benchmark.zig\"),\n    .target = target,\n    .optimize = .ReleaseFast,  // Force release mode\n});",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 6,
        "chars": 193
      },
      {
        "index": 40,
        "start_line": 944,
        "end_line": 949,
        "code": "// Entire loop may be optimized away\nfor (0..1000) |_| {\n    const result = compute();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 4,
        "chars": 88
      },
      {
        "index": 41,
        "start_line": 952,
        "end_line": 957,
        "code": "for (0..1000) |_| {\n    const result = compute();\n    std.mem.doNotOptimizeAway(&result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 4,
        "chars": 91
      },
      {
        "index": 42,
        "start_line": 960,
        "end_line": 966,
        "code": "// First iterations will be slow (cold cache)\nvar timer = try std.time.Timer.start();\nfor (0..1000) |_| {\n    compute();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 5,
        "chars": 122
      },
      {
        "index": 43,
        "start_line": 969,
        "end_line": 982,
        "code": "// Warm up first\nfor (0..100) |_| {\n    const result = compute();\n    std.mem.doNotOptimizeAway(&result);\n}\n\n// Then measure\nvar timer = try std.time.Timer.start();\nfor (0..1000) |_| {\n    const result = compute();\n    std.mem.doNotOptimizeAway(&result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 12,
        "chars": 256
      },
      {
        "index": 44,
        "start_line": 985,
        "end_line": 990,
        "code": "var timer = try std.time.Timer.start();\ncompute();\nconst elapsed = timer.read();\n// Unreliable - could be affected by context switch",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 4,
        "chars": 132
      },
      {
        "index": 45,
        "start_line": 993,
        "end_line": 1003,
        "code": "// Take multiple samples\nconst samples = 10;\nvar times: [10]u64 = undefined;\nfor (&times) |*t| {\n    var timer = try std.time.Timer.start();\n    compute();\n    t.* = timer.read();\n}\n// Compute statistics from samples",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 9,
        "chars": 216
      },
      {
        "index": 46,
        "start_line": 1038,
        "end_line": 1053,
        "code": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n        .strip = false,  // Keep symbols for profiling\n    });\n\n    b.installArtifact(exe);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 14,
        "chars": 398
      },
      {
        "index": 52,
        "start_line": 1626,
        "end_line": 1704,
        "code": "const std = @import(\"std\");\n\npub const BenchmarkResult = struct {\n    iterations: u64,\n    total_ns: u64,\n    avg_ns: u64,\n    min_ns: u64,\n    max_ns: u64,\n    variance_ns: u64,\n\n    pub fn speedupVs(self: BenchmarkResult, other: BenchmarkResult) f64 {\n        return @as(f64, @floatFromInt(other.avg_ns)) / @as(f64, @floatFromInt(self.avg_ns));\n    }\n};\n\npub fn benchmark(\n    comptime Func: type,\n    func: Func,\n    iterations: u64,\n) !BenchmarkResult {\n    // Warm-up phase: stabilizes CPU frequency, cache, branch predictor\n    const warmup_iterations = @min(iterations / 10, 100);\n    for (0..warmup_iterations) |_| {\n        const result = func();\n        std.mem.doNotOptimizeAway(&result);\n    }\n\n    // Collect multiple samples for statistical analysis\n    const num_samples = @min(10, @max(1, iterations / 100));\n    const iterations_per_sample = iterations / num_samples;\n\n    var samples: [10]u64 = undefined;\n    var sample_idx: usize = 0;\n\n    while (sample_idx < num_samples) : (sample_idx += 1) {\n        var timer = try std.time.Timer.start();\n\n        var iter: u64 = 0;\n        while (iter < iterations_per_sample) : (iter += 1) {\n            const result = func();\n            // Critical: doNotOptimizeAway prevents dead code elimination\n            std.mem.doNotOptimizeAway(&result);\n        }\n\n        samples[sample_idx] = timer.read();\n    }\n\n    // Calculate statistics: min, max, mean, variance\n    var min_ns: u64 = std.math.maxInt(u64);\n    var max_ns: u64 = 0;\n    var total_ns: u64 = 0;\n\n    for (samples[0..num_samples]) |sample| {\n        min_ns = @min(min_ns, sample);\n        max_ns = @max(max_ns, sample);\n        total_ns += sample;\n    }\n\n    const avg_ns = total_ns / num_samples;\n\n    // Variance: sum of squared differences from mean\n    var variance_sum: u128 = 0;\n    for (samples[0..num_samples]) |sample| {\n        const diff = if (sample > avg_ns) sample - avg_ns else avg_ns - sample;\n        variance_sum += @as(u128, diff) * @as(u128, diff);\n    }\n    const variance_ns = @as(u64, @intCast(variance_sum / num_samples));\n\n    return BenchmarkResult{\n        .iterations = iterations,\n        .total_ns = total_ns,\n        .avg_ns = avg_ns / iterations_per_sample,\n        .min_ns = min_ns / iterations_per_sample,\n        .max_ns = max_ns / iterations_per_sample,\n        .variance_ns = variance_ns / (iterations_per_sample * iterations_per_sample),\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 77,
        "chars": 2409
      },
      {
        "index": 54,
        "start_line": 1778,
        "end_line": 1801,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const exe = b.addExecutable(.{\n        .name = \"profiling-demo\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n        .strip = false,  // Keep symbols for profiling\n    });\n\n    b.installArtifact(exe);\n\n    const run_cmd = b.addRunArtifact(exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n\n    const run_step = b.step(\"run\", \"Run the profiling demo\");\n    run_step.dependOn(&run_cmd.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 22,
        "chars": 628
      },
      {
        "index": 55,
        "start_line": 1896,
        "end_line": 1905,
        "code": "test \"memory leak\" {\n    var list = try std.ArrayList(u32).initCapacity(testing.allocator, 10);\n    // Forgot list.deinit()\n\n    try list.append(42);\n    try testing.expectEqual(1, list.items.len);\n}\n// Test fails: memory leak detected",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 8,
        "chars": 235
      },
      {
        "index": 56,
        "start_line": 1908,
        "end_line": 1916,
        "code": "test \"no memory leak\" {\n    var list = try std.ArrayList(u32).initCapacity(testing.allocator, 10);\n    defer list.deinit();  // Always defer cleanup\n\n    try list.append(42);\n    try testing.expectEqual(1, list.items.len);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 7,
        "chars": 224
      },
      {
        "index": 57,
        "start_line": 1925,
        "end_line": 1932,
        "code": "// Only tests happy path\ntest \"parseNumber works\" {\n    const result = try parseNumber(\"42\");\n    try testing.expectEqual(42, result);\n}\n// What if input is invalid? Untested!",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 6,
        "chars": 175
      },
      {
        "index": 58,
        "start_line": 1935,
        "end_line": 1950,
        "code": "test \"parseNumber: valid input\" {\n    const result = try parseNumber(\"42\");\n    try testing.expectEqual(42, result);\n}\n\ntest \"parseNumber: invalid input\" {\n    const result = parseNumber(\"not a number\");\n    try testing.expectError(error.InvalidFormat, result);\n}\n\ntest \"parseNumber: overflow\" {\n    const result = parseNumber(\"999999999999999999999\");\n    try testing.expectError(error.Overflow, result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 14,
        "chars": 407
      },
      {
        "index": 59,
        "start_line": 1959,
        "end_line": 1967,
        "code": "// Compiler may optimize away the entire loop\nvar timer = try std.time.Timer.start();\nfor (0..1000) |_| {\n    const result = expensiveFunction();\n    // result unused - dead code elimination\n}\nconst elapsed = timer.read();",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 7,
        "chars": 222
      },
      {
        "index": 60,
        "start_line": 1970,
        "end_line": 1977,
        "code": "var timer = try std.time.Timer.start();\nfor (0..1000) |_| {\n    const result = expensiveFunction();\n    std.mem.doNotOptimizeAway(&result);  // Force compiler to keep it\n}\nconst elapsed = timer.read();",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 6,
        "chars": 201
      },
      {
        "index": 61,
        "start_line": 1986,
        "end_line": 1992,
        "code": "// Unreliable - affected by context switches\nvar timer = try std.time.Timer.start();\nexpensiveOperation();\nconst elapsed = timer.read();\nstd.debug.print(\"Took {d} ns\\n\", .{elapsed});",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 5,
        "chars": 182
      },
      {
        "index": 62,
        "start_line": 1995,
        "end_line": 2019,
        "code": "// Take multiple samples and compute statistics\nconst num_samples = 10;\nvar samples: [10]u64 = undefined;\n\nfor (&samples) |*sample| {\n    var timer = try std.time.Timer.start();\n    expensiveOperation();\n    sample.* = timer.read();\n}\n\n// Compute min, max, mean\nvar min: u64 = std.math.maxInt(u64);\nvar max: u64 = 0;\nvar sum: u64 = 0;\n\nfor (samples) |s| {\n    min = @min(min, s);\n    max = @max(max, s);\n    sum += s;\n}\n\nconst avg = sum / num_samples;\nstd.debug.print(\"Min: {d} ns, Max: {d} ns, Avg: {d} ns\\n\", .{min, max, avg});",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 23,
        "chars": 529
      },
      {
        "index": 63,
        "start_line": 2046,
        "end_line": 2053,
        "code": "// First iterations are slow (cold cache, CPU throttled)\nvar timer = try std.time.Timer.start();\nfor (0..1000) |_| {\n    compute();\n}\nconst elapsed = timer.read();",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 6,
        "chars": 163
      },
      {
        "index": 64,
        "start_line": 2056,
        "end_line": 2070,
        "code": "// Warm-up phase\nfor (0..100) |_| {\n    const result = compute();\n    std.mem.doNotOptimizeAway(&result);\n}\n\n// Now measure with warm cache and stable CPU\nvar timer = try std.time.Timer.start();\nfor (0..1000) |_| {\n    const result = compute();\n    std.mem.doNotOptimizeAway(&result);\n}\nconst elapsed = timer.read();",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 13,
        "chars": 316
      },
      {
        "index": 65,
        "start_line": 2103,
        "end_line": 2113,
        "code": "test \"ArrayList internal capacity\" {\n    var list = std.ArrayList(u32).init(testing.allocator);\n    defer list.deinit();\n\n    // Testing internal implementation detail\n    try testing.expect(list.capacity == 0);\n    try list.append(1);\n    try testing.expect(list.capacity >= 1);  // Fragile\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 9,
        "chars": 293
      },
      {
        "index": 66,
        "start_line": 2116,
        "end_line": 2126,
        "code": "test \"ArrayList: append increases length\" {\n    var list = std.ArrayList(u32).init(testing.allocator);\n    defer list.deinit();\n\n    try testing.expectEqual(@as(usize, 0), list.items.len);\n    try list.append(1);\n    try testing.expectEqual(@as(usize, 1), list.items.len);\n    try testing.expectEqual(@as(u32, 1), list.items[0]);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 9,
        "chars": 331
      },
      {
        "index": 67,
        "start_line": 2135,
        "end_line": 2154,
        "code": "test \"concurrent counter\" {\n    var counter: u32 = 0;  // No synchronization\n\n    var threads: [4]std.Thread = undefined;\n    for (&threads) |*t| {\n        t.* = try std.Thread.spawn(.{}, struct {\n            fn run(c: *u32) void {\n                for (0..1000) |_| {\n                    c.* += 1;  // Race condition\n                }\n            }\n        }.run, .{&counter});\n    }\n\n    for (threads) |t| t.join();\n\n    try testing.expectEqual(@as(u32, 4000), counter);  // May fail randomly\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 18,
        "chars": 495
      },
      {
        "index": 68,
        "start_line": 2157,
        "end_line": 2176,
        "code": "test \"concurrent atomic counter\" {\n    var counter = std.atomic.Value(u32).init(0);\n\n    var threads: [4]std.Thread = undefined;\n    for (&threads) |*t| {\n        t.* = try std.Thread.spawn(.{}, struct {\n            fn run(c: *std.atomic.Value(u32)) void {\n                for (0..1000) |_| {\n                    _ = c.fetchAdd(1, .monotonic);  // Atomic operation\n                }\n            }\n        }.run, .{&counter});\n    }\n\n    for (threads) |t| t.join();\n\n    try testing.expectEqual(@as(u32, 4000), counter.load(.monotonic));\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 18,
        "chars": 538
      },
      {
        "index": 69,
        "start_line": 2185,
        "end_line": 2190,
        "code": "test \"float equality\" {\n    const result = std.math.sqrt(2.0) * std.math.sqrt(2.0);\n    try testing.expectEqual(@as(f64, 2.0), result);  // May fail\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 4,
        "chars": 150
      },
      {
        "index": 70,
        "start_line": 2193,
        "end_line": 2198,
        "code": "test \"float approximate equality\" {\n    const result = std.math.sqrt(2.0) * std.math.sqrt(2.0);\n    try testing.expectApproxEqAbs(@as(f64, 2.0), result, 1e-10);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 4,
        "chars": 162
      },
      {
        "index": 71,
        "start_line": 2207,
        "end_line": 2212,
        "code": "test \"load config file\" {\n    const config = try loadConfig(\"/home/user/test/config.json\");  // Hardcoded\n    try testing.expect(config.valid);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 4,
        "chars": 145
      },
      {
        "index": 72,
        "start_line": 2215,
        "end_line": 2235,
        "code": "test \"load config file\" {\n    const config_content =\n        \\\\{ \"setting\": \"value\" }\n    ;\n\n    var tmp = testing.tmpDir(.{});\n    defer tmp.cleanup();\n\n    try tmp.dir.writeFile(.{ .sub_path = \"config.json\", .data = config_content });\n\n    const path = try tmp.dir.realpathAlloc(testing.allocator, \".\");\n    defer testing.allocator.free(path);\n\n    const file_path = try std.fs.path.join(testing.allocator, &.{path, \"config.json\"});\n    defer testing.allocator.free(file_path);\n\n    const config = try loadConfig(file_path);\n    try testing.expect(config.valid);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 19,
        "chars": 566
      },
      {
        "index": 73,
        "start_line": 2244,
        "end_line": 2253,
        "code": "test \"random behavior\" {\n    var prng = std.Random.DefaultPrng.init(@intCast(std.time.timestamp()));\n    const random = prng.random();\n\n    const value = random.int(u32);\n    // Test logic based on random value...\n    // Hard to reproduce failures\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 8,
        "chars": 249
      },
      {
        "index": 74,
        "start_line": 2256,
        "end_line": 2265,
        "code": "test \"deterministic random behavior\" {\n    var prng = std.Random.DefaultPrng.init(testing.random_seed);  // Deterministic\n    const random = prng.random();\n\n    const value = random.int(u32);\n    // Test logic...\n    // Failures are reproducible with same seed\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 8,
        "chars": 262
      },
      {
        "index": 75,
        "start_line": 2281,
        "end_line": 2311,
        "code": "pub const TimeSim = struct {\n    resolution: u64,\n    offset_type: OffsetType,\n    offset_coefficient_A: i64,\n    offset_coefficient_B: i64,\n    ticks: u64 = 0,\n    epoch: i64 = 0,\n\n    pub fn time(self: *TimeSim) Time {\n        return .{\n            .context = self,\n            .vtable = &.{\n                .monotonic = monotonic,\n                .realtime = realtime,\n                .tick = tick,\n            },\n        };\n    }\n\n    fn monotonic(context: *anyopaque) u64 {\n        const self: *TimeSim = @ptrCast(@alignCast(context));\n        return self.ticks * self.resolution;\n    }\n\n    fn tick(context: *anyopaque) void {\n        const self: *TimeSim = @ptrCast(@alignCast(context));\n        self.ticks += 1;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 29,
        "chars": 728
      },
      {
        "index": 76,
        "start_line": 2323,
        "end_line": 2335,
        "code": "pub const PacketSimulatorOptions = struct {\n    one_way_delay_mean: Duration,\n    one_way_delay_min: Duration,\n    packet_loss_probability: Ratio = Ratio.zero(),\n    packet_replay_probability: Ratio = Ratio.zero(),\n    partition_mode: PartitionMode = .none,\n    partition_probability: Ratio = Ratio.zero(),\n    path_maximum_capacity: u8,\n    path_clog_duration_mean: Duration,\n    path_clog_probability: Ratio,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 11,
        "chars": 413
      },
      {
        "index": 78,
        "start_line": 2368,
        "end_line": 2388,
        "code": "pub const cluster: u128 = 0;\npub const replica: u8 = 0;\npub const replica_count: u8 = 6;\n\npub fn initStorage(allocator: std.mem.Allocator, options: Storage.Options) !Storage {\n    return try Storage.init(allocator, options);\n}\n\npub fn storageFormat(\n    allocator: std.mem.Allocator,\n    storage: *Storage,\n    options: struct {\n        cluster: u128 = cluster,\n        replica: u8 = replica,\n        replica_count: u8 = replica_count,\n    },\n) !void {\n    // Complex initialization logic centralized\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 19,
        "chars": 502
      },
      {
        "index": 79,
        "start_line": 2401,
        "end_line": 2417,
        "code": "test \"fc-list\" {\n    const testing = std.testing;\n\n    var cfg = fontconfig.initLoadConfigAndFonts();\n    defer cfg.destroy();\n\n    var pat = fontconfig.Pattern.create();\n    defer pat.destroy();\n\n    var fs = cfg.fontList(pat, os);\n    defer fs.destroy();\n\n    // Environmental check: expect at least one font\n    try testing.expect(fs.fonts().len > 0);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 15,
        "chars": 356
      },
      {
        "index": 80,
        "start_line": 2423,
        "end_line": 2441,
        "code": "test \"fc-match\" {\n    var cfg = fontconfig.initLoadConfigAndFonts();\n    defer cfg.destroy();\n\n    var pat = fontconfig.Pattern.create();\n    errdefer pat.destroy();  // Cleanup on error\n\n    try testing.expect(cfg.substituteWithPat(pat, .pattern));\n    pat.defaultSubstitute();\n\n    const result = cfg.fontSort(pat, false, null);\n    errdefer result.fs.destroy();  // Cleanup on error\n\n    // Success path cleanup\n    result.fs.destroy();\n    pat.destroy();\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 460
      },
      {
        "index": 81,
        "start_line": 2451,
        "end_line": 2469,
        "code": "pub fn expectEqual(expected: anytype, actual: anytype) error{TestExpectedEqual}!void {\n    const expected_json = std.json.Stringify.valueAlloc(allocator, expected, .{\n        .whitespace = .indent_2,\n        .emit_null_optional_fields = false,\n    }) catch @panic(\"OOM\");\n    defer allocator.free(expected_json);\n\n    const actual_json = std.json.Stringify.valueAlloc(allocator, actual, .{\n        .whitespace = .indent_2,\n        .emit_null_optional_fields = false,\n    }) catch @panic(\"OOM\");\n    defer allocator.free(actual_json);\n\n    if (std.mem.eql(u8, expected_json, actual_json)) return;\n    renderLineDiff(allocator, expected_json, actual_json);\n    return error.TestExpectedEqual;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 692
      },
      {
        "index": 82,
        "start_line": 2480,
        "end_line": 2498,
        "code": "pub const FailingAllocator = struct {\n    likelihood: u32,\n\n    /// Chance of failure is 1/likelihood\n    pub fn init(internal_allocator: std.mem.Allocator, likelihood: u32) FailingAllocator {\n        return .{\n            .internal_allocator = internal_allocator,\n            .random = .init(std.crypto.random.int(u64)),\n            .likelihood = likelihood,\n        };\n    }\n\n    fn shouldFail(self: *FailingAllocator) bool {\n        if (self.likelihood == std.math.maxInt(u32)) return false;\n        return 0 == self.random.random().intRangeAtMostBiased(u32, 0, self.likelihood);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 591
      },
      {
        "index": 83,
        "start_line": 2508,
        "end_line": 2526,
        "code": "// std/array_list.zig\npub const ArrayList = struct {\n    // Implementation...\n};\n\ntest \"init\" {\n    const list = ArrayList(u32).init(testing.allocator);\n    defer list.deinit();\n    try testing.expectEqual(@as(usize, 0), list.items.len);\n}\n\ntest \"basic\" {\n    var list = ArrayList(i32).init(testing.allocator);\n    defer list.deinit();\n\n    // Test basic operations...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 17,
        "chars": 370
      },
      {
        "index": 84,
        "start_line": 2530,
        "end_line": 2541,
        "code": "test \"HashMap: basic usage\" {\n    inline for ([_]type{ u32, i32, u64 }) |K| {\n        inline for ([_]type{ u32, []const u8 }) |V| {\n            var map = std.AutoHashMap(K, V).init(testing.allocator);\n            defer map.deinit();\n\n            // Test operations with K, V\n        }\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/12_testing_benchmarking/content.md",
        "lines": 10,
        "chars": 292
      }
    ]
  },
  {
    "chapter": "13_logging_diagnostics",
    "content_file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
    "total_blocks": 45,
    "runnable_blocks": 4,
    "snippet_blocks": 41,
    "runnable": [
      {
        "index": 1,
        "start_line": 50,
        "end_line": 60,
        "code": "const std = @import(\"std\");\nconst log = std.log;\n\npub fn main() void {\n    log.err(\"Error: critical failure\", .{});\n    log.warn(\"Warning: approaching limit\", .{});\n    log.info(\"Info: request completed\", .{});\n    log.debug(\"Debug: cache hit\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 9,
        "chars": 252
      },
      {
        "index": 20,
        "start_line": 496,
        "end_line": 525,
        "code": "const std = @import(\"std\");\nconst database = @import(\"database.zig\");\nconst network = @import(\"network.zig\");\n\npub fn main() !void {\n    const log = std.log;\n\n    // Default scope logging\n    log.info(\"Application started\", .{});\n    log.debug(\"Debug mode enabled\", .{});\n\n    const port: u16 = 8080;\n    log.info(\"Server listening on port {d}\", .{port});\n\n    // Demonstrate all log levels\n    log.err(\"This is an error message\", .{});\n    log.warn(\"This is a warning message\", .{});\n    log.info(\"This is an info message\", .{});\n    log.debug(\"This is a debug message\", .{});\n\n    // Use scoped logging from other modules\n    try database.connect();\n    try database.query(\"SELECT * FROM users\");\n\n    try network.sendRequest(\"https://api.example.com/data\");\n\n    log.info(\"Application shutting down\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 28,
        "chars": 811
      },
      {
        "index": 23,
        "start_line": 613,
        "end_line": 696,
        "code": "const std = @import(\"std\");\n\npub const LogContext = struct {\n    correlation_id: []const u8,\n    user_id: ?u32 = null,\n    request_path: ?[]const u8 = null,\n\n    pub fn logInfo(\n        self: LogContext,\n        comptime format: []const u8,\n        args: anytype,\n    ) void {\n        self.logWithLevel(.info, format, args);\n    }\n\n    pub fn logError(\n        self: LogContext,\n        comptime format: []const u8,\n        args: anytype,\n    ) void {\n        self.logWithLevel(.err, format, args);\n    }\n\n    fn logWithLevel(\n        self: LogContext,\n        level: std.log.Level,\n        comptime format: []const u8,\n        args: anytype,\n    ) void {\n        const stderr = std.io.getStdErr().writer();\n        std.debug.lockStdErr();\n        defer std.debug.unlockStdErr();\n\n        var buf: [4096]u8 = undefined;\n        const message = std.fmt.bufPrint(&buf, format, args) catch \"format error\";\n\n        nosuspend {\n            stderr.writeAll(\"{\") catch return;\n\n            stderr.writeAll(\"\\\"timestamp\\\":\") catch return;\n            stderr.print(\"{d}\", .{std.time.milliTimestamp()}) catch return;\n\n            stderr.writeAll(\",\\\"level\\\":\\\"\") catch return;\n            stderr.writeAll(level.asText()) catch return;\n            stderr.writeAll(\"\\\"\") catch return;\n\n            stderr.writeAll(\",\\\"correlation_id\\\":\\\"\") catch return;\n            stderr.writeAll(self.correlation_id) catch return;\n            stderr.writeAll(\"\\\"\") catch return;\n\n            if (self.user_id) |uid| {\n                stderr.writeAll(\",\\\"user_id\\\":\") catch return;\n                stderr.print(\"{d}\", .{uid}) catch return;\n            }\n\n            if (self.request_path) |path| {\n                stderr.writeAll(\",\\\"path\\\":\\\"\") catch return;\n                stderr.writeAll(path) catch return;\n                stderr.writeAll(\"\\\"\") catch return;\n            }\n\n            stderr.writeAll(\",\\\"message\\\":\\\"\") catch return;\n            stderr.writeAll(message) catch return;\n            stderr.writeAll(\"\\\"\") catch return;\n\n            stderr.writeAll(\"}\\n\") catch return;\n        };\n    }\n};\n\npub fn main() !void {\n    // Simulate HTTP request handling\n    const ctx = LogContext{\n        .correlation_id = \"req-12345-abcde\",\n        .user_id = 42,\n        .request_path = \"/api/users/42\",\n    };\n\n    ctx.logInfo(\"Request started\", .{});\n    ctx.logInfo(\"Querying database for user {d}\", .{42});\n    ctx.logInfo(\"Request completed in {d}ms\", .{123});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 82,
        "chars": 2445
      },
      {
        "index": 24,
        "start_line": 716,
        "end_line": 763,
        "code": "const std = @import(\"std\");\n\nconst SampledLogger = struct {\n    counter: std.atomic.Value(u64),\n    sample_rate: u64,\n\n    pub fn init(sample_rate: u64) SampledLogger {\n        return .{\n            .counter = std.atomic.Value(u64).init(0),\n            .sample_rate = sample_rate,\n        };\n    }\n\n    pub fn shouldLog(self: *SampledLogger) bool {\n        const count = self.counter.fetchAdd(1, .monotonic);\n        return count % self.sample_rate == 0;\n    }\n\n    pub fn logInfo(\n        self: *SampledLogger,\n        comptime format: []const u8,\n        args: anytype,\n    ) void {\n        if (self.shouldLog()) {\n            std.log.info(format, args);\n        }\n    }\n};\n\npub fn main() !void {\n    var sampled = SampledLogger.init(100); // Log 1/100 events\n\n    // High-frequency loop\n    var i: u64 = 0;\n    while (i < 10000) : (i += 1) {\n        // Only logs 100 times (1/100)\n        sampled.logInfo(\"Processing item {d}\", .{i});\n\n        processItem(i);\n    }\n}\n\nfn processItem(id: u64) void {\n    // Process the item...\n    _ = id;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 46,
        "chars": 1043
      }
    ],
    "snippets": [
      {
        "index": 2,
        "start_line": 73,
        "end_line": 85,
        "code": "fn log(\n    comptime message_level: Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    // Compile-time check - filtered logs are completely removed\n    if (comptime !logEnabled(message_level, scope)) return;\n\n    std.options.logFn(message_level, scope, format, args);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 11,
        "chars": 334
      },
      {
        "index": 3,
        "start_line": 93,
        "end_line": 100,
        "code": "pub const Level = enum {\n    err,    // 0 - Highest priority\n    warn,   // 1\n    info,   // 2\n    debug,  // 3 - Lowest priority\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 6,
        "chars": 132
      },
      {
        "index": 4,
        "start_line": 108,
        "end_line": 113,
        "code": "pub const default_level: Level = switch (builtin.mode) {\n    .Debug => .debug,                              // All logs enabled\n    .ReleaseSafe, .ReleaseFast, .ReleaseSmall => .info,  // Debug logs filtered out\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 4,
        "chars": 214
      },
      {
        "index": 5,
        "start_line": 130,
        "end_line": 134,
        "code": "pub const std_options: std.Options = .{\n    .log_level = .info,  // Filter out debug logs\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 3,
        "chars": 92
      },
      {
        "index": 6,
        "start_line": 138,
        "end_line": 146,
        "code": "pub const std_options: std.Options = .{\n    .log_level = .info,  // Global default\n    .log_scope_levels = &[_]std.log.ScopeLevel{\n        .{ .scope = .network, .level = .debug },  // Verbose network logs\n        .{ .scope = .cache, .level = .warn },     // Only cache warnings\n    },\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 7,
        "chars": 287
      },
      {
        "index": 7,
        "start_line": 156,
        "end_line": 173,
        "code": "const database_log = std.log.scoped(.database);\nconst network_log = std.log.scoped(.network);\nconst auth_log = std.log.scoped(.auth);\n\npub fn connectDatabase() !void {\n    database_log.info(\"Connecting to database...\", .{});\n    database_log.debug(\"Connection string: {s}\", .{conn_str});\n}\n\npub fn handleRequest(req: Request) !void {\n    network_log.info(\"GET {s}\", .{req.path});\n\n    if (req.needsAuth()) {\n        auth_log.debug(\"Validating credentials\", .{});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 16,
        "chars": 470
      },
      {
        "index": 8,
        "start_line": 193,
        "end_line": 205,
        "code": "// In src/vsr.zig\nconst log = std.log.scoped(.vsr);\n\n// In src/vsr/superblock.zig\nconst log = std.log.scoped(.superblock);\n\n// In src/vsr/journal.zig\nconst log = std.log.scoped(.journal);\n\n// In src/io/linux.zig\nconst log = std.log.scoped(.io);",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 11,
        "chars": 244
      },
      {
        "index": 9,
        "start_line": 224,
        "end_line": 233,
        "code": "pub fn customLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    // Custom handler implementation\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 8,
        "chars": 198
      },
      {
        "index": 10,
        "start_line": 241,
        "end_line": 257,
        "code": "pub fn defaultLog(\n    comptime message_level: Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    const level_txt = comptime message_level.asText();\n    const prefix2 = if (scope == .default) \": \" else \"(\" ++ @tagName(scope) ++ \"): \";\n\n    var buffer: [64]u8 = undefined;\n    const stderr = std.debug.lockStderrWriter(&buffer);\n    defer std.debug.unlockStderrWriter();\n\n    nosuspend stderr.print(level_txt ++ prefix2 ++ format ++ \"\\n\", args) catch return;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 15,
        "chars": 524
      },
      {
        "index": 11,
        "start_line": 269,
        "end_line": 285,
        "code": "pub fn threadSafeLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n\n    const stderr = std.io.getStdErr().writer();\n    // Safe to write to stderr while locked\n    stderr.print(\"[{s}] ({s}): \" ++ format ++ \"\\n\", .{\n        level.asText(), @tagName(scope),\n    } ++ args) catch return;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 15,
        "chars": 447
      },
      {
        "index": 12,
        "start_line": 291,
        "end_line": 314,
        "code": "pub fn timestampedLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n\n    const stderr = std.io.getStdErr().writer();\n    const timestamp = std.time.timestamp();\n\n    nosuspend stderr.print(\"[{d}] {s}({s}): \" ++ format ++ \"\\n\", .{\n        timestamp,\n        level.asText(),\n        @tagName(scope),\n    } ++ args) catch return;\n}\n\npub const std_options: std.Options = .{\n    .logFn = timestampedLogFn,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 22,
        "chars": 564
      },
      {
        "index": 13,
        "start_line": 326,
        "end_line": 364,
        "code": "pub fn jsonLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    const stderr = std.io.getStdErr().writer();\n\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n\n    // Format message into buffer\n    var buf: [4096]u8 = undefined;\n    const message = std.fmt.bufPrint(&buf, format, args) catch \"format error\";\n\n    nosuspend {\n        stderr.writeAll(\"{\\\"timestamp\\\":\") catch return;\n        stderr.print(\"{d}\", .{std.time.timestamp()}) catch return;\n        stderr.writeAll(\",\\\"level\\\":\\\"\") catch return;\n        stderr.writeAll(level.asText()) catch return;\n        stderr.writeAll(\"\\\",\\\"scope\\\":\\\"\") catch return;\n        stderr.writeAll(@tagName(scope)) catch return;\n        stderr.writeAll(\"\\\",\\\"message\\\":\\\"\") catch return;\n\n        // Escape special characters for valid JSON\n        for (message) |c| {\n            switch (c) {\n                '\"' => stderr.writeAll(\"\\\\\\\"\") catch return,\n                '\\\\' => stderr.writeAll(\"\\\\\\\\\") catch return,\n                '\\n' => stderr.writeAll(\"\\\\n\") catch return,\n                else => stderr.writeByte(c) catch return,\n            }\n        }\n\n        stderr.writeAll(\"\\\"}\\n\") catch return;\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 37,
        "chars": 1269
      },
      {
        "index": 14,
        "start_line": 378,
        "end_line": 409,
        "code": "fn logFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.EnumLiteral),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n\n    if (builtin.target.os.tag.isDarwin()) {\n        // Map Zig levels to macOS levels\n        const mac_level: macos.os.LogType = switch (level) {\n            .debug => .debug,\n            .info => .info,\n            .warn => .err,\n            .err => .fault,\n        };\n\n        const logger = macos.os.Log.create(bundle_id, @tagName(scope));\n        defer logger.release();\n        logger.log(std.heap.c_allocator, mac_level, format, args);\n    }\n\n    // Also output to stderr\n    var buffer: [1024]u8 = undefined;\n    var stderr = std.fs.File.stderr().writer(&buffer);\n    nosuspend stderr.print(\"{s}({s}): \" ++ format ++ \"\\n\", .{\n        level.asText(), @tagName(scope),\n    } ++ args) catch return;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 30,
        "chars": 919
      },
      {
        "index": 15,
        "start_line": 421,
        "end_line": 428,
        "code": "const std = @import(\"std\");\n\npub fn debugExample() void {\n    const value = 42;\n    std.debug.print(\"Value: {d}\\n\", .{value});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 6,
        "chars": 128
      },
      {
        "index": 16,
        "start_line": 436,
        "end_line": 441,
        "code": "pub fn diagnoseError() void {\n    std.log.err(\"Error occurred, dumping stack trace:\", .{});\n    std.debug.dumpCurrentStackTrace(null);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 4,
        "chars": 136
      },
      {
        "index": 17,
        "start_line": 454,
        "end_line": 457,
        "code": "const data = [_]u8{ 0x48, 0x65, 0x6c, 0x6c, 0x6f };\nstd.debug.dumpHex(&data);",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 2,
        "chars": 77
      },
      {
        "index": 18,
        "start_line": 470,
        "end_line": 473,
        "code": "const assert = std.debug.assert;\nassert(value > 0);  // Panics if false (in Debug/ReleaseSafe)",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 2,
        "chars": 94
      },
      {
        "index": 19,
        "start_line": 477,
        "end_line": 482,
        "code": "if (value <= 0) {\n    log.err(\"Invalid value: {d}\", .{value});\n    return error.InvalidValue;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 4,
        "chars": 95
      },
      {
        "index": 21,
        "start_line": 529,
        "end_line": 549,
        "code": "const std = @import(\"std\");\nconst log = std.log.scoped(.database);\n\npub fn connect() !void {\n    log.info(\"Connecting to database...\", .{});\n    log.debug(\"Connection parameters: host=localhost port=5432\", .{});\n    log.info(\"Database connection established\", .{});\n}\n\npub fn query(sql: []const u8) !void {\n    log.debug(\"Executing query: {s}\", .{sql});\n\n    if (std.mem.indexOf(u8, sql, \"INVALID\") != null) {\n        log.err(\"Invalid SQL syntax detected\", .{});\n        return error.InvalidSQL;\n    }\n\n    log.debug(\"Query completed successfully\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 19,
        "chars": 556
      },
      {
        "index": 22,
        "start_line": 553,
        "end_line": 563,
        "code": "const std = @import(\"std\");\nconst log = std.log.scoped(.network);\n\npub fn sendRequest(url: []const u8) !void {\n    log.info(\"Sending HTTP request to {s}\", .{url});\n    log.debug(\"Request headers: User-Agent=ZigHTTP/1.0\", .{});\n    log.debug(\"Received response: 200 OK\", .{});\n    log.info(\"Request completed successfully\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 9,
        "chars": 330
      },
      {
        "index": 25,
        "start_line": 771,
        "end_line": 795,
        "code": "const ErrorRateTracker = struct {\n    error_count: std.atomic.Value(u64),\n    total_count: std.atomic.Value(u64),\n\n    pub fn recordSuccess(self: *ErrorRateTracker) void {\n        _ = self.total_count.fetchAdd(1, .monotonic);\n    }\n\n    pub fn recordError(self: *ErrorRateTracker, err: anyerror) void {\n        _ = self.error_count.fetchAdd(1, .monotonic);\n        _ = self.total_count.fetchAdd(1, .monotonic);\n\n        // Always log errors (no sampling)\n        std.log.err(\"Operation failed: {s}\", .{@errorName(err)});\n    }\n\n    pub fn getErrorRate(self: *ErrorRateTracker) f64 {\n        const errors = self.error_count.load(.monotonic);\n        const total = self.total_count.load(.monotonic);\n        if (total == 0) return 0.0;\n        return @as(f64, @floatFromInt(errors)) / @as(f64, @floatFromInt(total));\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 23,
        "chars": 823
      },
      {
        "index": 26,
        "start_line": 807,
        "end_line": 810,
        "code": "// \u274c Incorrect - expensiveFunction() always runs\nlog.debug(\"Result: {}\", .{expensiveFunction()});",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 2,
        "chars": 97
      },
      {
        "index": 27,
        "start_line": 816,
        "end_line": 821,
        "code": "// \u2705 Correct - only compute if logging enabled\nif (std.log.defaultLogEnabled(.debug)) {\n    log.debug(\"Result: {}\", .{expensiveFunction()});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 4,
        "chars": 142
      },
      {
        "index": 28,
        "start_line": 825,
        "end_line": 830,
        "code": "// \u2705 Best - compile-time eliminated if debug disabled globally\nif (comptime std.log.defaultLogEnabled(.debug)) {\n    log.debug(\"Result: {}\", .{expensiveFunction()});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 4,
        "chars": 167
      },
      {
        "index": 29,
        "start_line": 836,
        "end_line": 840,
        "code": "// \u274c NEVER DO THIS\nlog.info(\"User login: user={s} password={s}\", .{username, password});\nlog.debug(\"API request with token: {s}\", .{api_token});",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 3,
        "chars": 144
      },
      {
        "index": 30,
        "start_line": 846,
        "end_line": 850,
        "code": "// \u2705 Correct - only log non-sensitive information\nlog.info(\"User login: user={s}\", .{username});\nlog.debug(\"API request sent\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 3,
        "chars": 132
      },
      {
        "index": 31,
        "start_line": 854,
        "end_line": 858,
        "code": "// \u2705 For debugging - hash sensitive data\nconst hash = std.crypto.hash.sha256.hash(password);\nlog.debug(\"Password hash: {x}\", .{std.fmt.fmtSliceHexLower(&hash)});",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 3,
        "chars": 161
      },
      {
        "index": 32,
        "start_line": 864,
        "end_line": 874,
        "code": "// \u274c Incorrect - NOT thread-safe\nvar log_buffer: [4096]u8 = undefined;\nvar log_len: usize = 0;\n\npub fn unsafeLogFn(...) void {\n    // Multiple threads can corrupt log_buffer\n    const msg = std.fmt.bufPrint(log_buffer[log_len..], ...) catch return;\n    log_len += msg.len;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 9,
        "chars": 274
      },
      {
        "index": 33,
        "start_line": 878,
        "end_line": 894,
        "code": "// \u2705 Correct - thread-safe with locking\npub fn safeLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n\n    const stderr = std.io.getStdErr().writer();\n    stderr.print(\"[{s}]({s}): \" ++ format ++ \"\\n\", .{\n        level.asText(), @tagName(scope),\n    } ++ args) catch return;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 15,
        "chars": 436
      },
      {
        "index": 34,
        "start_line": 900,
        "end_line": 906,
        "code": "// \u274c Incorrect - logs millions of times\nfor (items) |item| {\n    log.debug(\"Processing {d}\", .{item.id});\n    processItem(item);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 5,
        "chars": 130
      },
      {
        "index": 35,
        "start_line": 910,
        "end_line": 924,
        "code": "// \u2705 Correct - sample every 100th item\nvar sampler = SampledLogger.init(100);\nfor (items) |item| {\n    sampler.logDebug(\"Processing {d}\", .{item.id});\n    processItem(item);\n}\n\n// \u2705 Alternative - log summary\nlog.info(\"Processing {d} items\", .{items.len});\nfor (items) |item| {\n    processItem(item);\n}\nlog.info(\"Completed processing {d} items\", .{items.len});",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 13,
        "chars": 359
      },
      {
        "index": 36,
        "start_line": 930,
        "end_line": 936,
        "code": "// \u274c Incorrect - breaks if msg contains quotes\npub fn badJsonLog(msg: []const u8) void {\n    stderr.print(\"{{\\\"message\\\":\\\"{s}\\\"}}\\n\", .{msg});\n    // If msg = \"He said \\\"hello\\\"\", output is invalid JSON\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 5,
        "chars": 205
      },
      {
        "index": 37,
        "start_line": 940,
        "end_line": 956,
        "code": "// \u2705 Correct - escape special characters\npub fn goodJsonLog(msg: []const u8) void {\n    stderr.writeAll(\"{\\\"message\\\":\\\"\") catch return;\n    for (msg) |c| {\n        switch (c) {\n            '\"' => stderr.writeAll(\"\\\\\\\"\") catch return,\n            '\\\\' => stderr.writeAll(\"\\\\\\\\\") catch return,\n            '\\n' => stderr.writeAll(\"\\\\n\") catch return,\n            '\\r' => stderr.writeAll(\"\\\\r\") catch return,\n            '\\t' => stderr.writeAll(\"\\\\t\") catch return,\n            else => stderr.writeByte(c) catch return,\n        }\n    }\n    stderr.writeAll(\"\\\"}\\n\") catch return;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 15,
        "chars": 578
      },
      {
        "index": 38,
        "start_line": 962,
        "end_line": 969,
        "code": "// \u274c Incorrect - blocks on network I/O\npub fn slowLogFn(...) void {\n    const socket = connectToLogServer() catch return; // Blocks!\n    defer socket.close();\n    socket.send(...) catch return;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 6,
        "chars": 195
      },
      {
        "index": 39,
        "start_line": 973,
        "end_line": 999,
        "code": "// \u2705 Correct - buffer logs, ship asynchronously\nconst AsyncLogBuffer = struct {\n    buffer: std.ArrayList(u8),\n    mutex: std.Thread.Mutex,\n\n    pub fn append(self: *AsyncLogBuffer, msg: []const u8) !void {\n        self.mutex.lock();\n        defer self.mutex.unlock();\n        try self.buffer.appendSlice(msg);\n    }\n\n    // Called periodically by background thread\n    pub fn flush(self: *AsyncLogBuffer) !void {\n        self.mutex.lock();\n        defer self.mutex.unlock();\n\n        if (self.buffer.items.len == 0) return;\n\n        const socket = try connectToLogServer();\n        defer socket.close();\n        try socket.writeAll(self.buffer.items);\n\n        self.buffer.clearRetainingCapacity();\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 25,
        "chars": 708
      },
      {
        "index": 40,
        "start_line": 1011,
        "end_line": 1018,
        "code": "// One scoped logger per module\nconst log = std.log.scoped(.vsr);          // Viewstamped Replication\nconst log = std.log.scoped(.superblock);   // Storage metadata\nconst log = std.log.scoped(.journal);      // Write-ahead log\nconst log = std.log.scoped(.grid_scrubber); // Data verification\nconst log = std.log.scoped(.compaction);    // LSM compaction",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 6,
        "chars": 353
      },
      {
        "index": 41,
        "start_line": 1022,
        "end_line": 1041,
        "code": "pub const Tracer = struct {\n    time: Time,\n    process_id: ProcessID,\n    options: Options,\n\n    pub const Options = struct {\n        writer: ?std.io.AnyWriter = null,\n        statsd_options: union(enum) {\n            log,\n            udp: struct {\n                io: *IO,\n                address: std.net.Address,\n            },\n        } = .log,\n    };\n\n    // Event tracking for deterministic replay...\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 18,
        "chars": 410
      },
      {
        "index": 42,
        "start_line": 1055,
        "end_line": 1079,
        "code": "fn logFn(\n    comptime level: std.log.Level,\n    comptime scope: @TypeOf(.EnumLiteral),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    if (builtin.target.os.tag.isDarwin()) {\n        // Use macOS Unified Logging\n        const mac_level: macos.os.LogType = switch (level) {\n            .debug => .debug,\n            .info => .info,\n            .warn => .err,\n            .err => .fault,\n        };\n\n        const logger = macos.os.Log.create(build_config.bundle_id, @tagName(scope));\n        defer logger.release();\n        logger.log(std.heap.c_allocator, mac_level, format, args);\n    }\n\n    // Also output to stderr\n    // ... stderr output code ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 23,
        "chars": 671
      },
      {
        "index": 43,
        "start_line": 1088,
        "end_line": 1096,
        "code": "pub const std_options: std.Options = .{\n    .log_level = switch (builtin.mode) {\n        .Debug => .debug,\n        else => .info,\n    },\n    .logFn = logFn,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 7,
        "chars": 159
      },
      {
        "index": 44,
        "start_line": 1102,
        "end_line": 1106,
        "code": "pub const std_options = std.Options{\n    .log_level = if (builtin.mode == .Debug) .debug else .warn,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 3,
        "chars": 103
      },
      {
        "index": 45,
        "start_line": 1116,
        "end_line": 1123,
        "code": "pub const std_options: std.Options = .{\n    .log_level = switch (builtin.mode) {\n        .Debug => .debug,\n        else => .info,\n    },\n};",
        "file": "/home/jack/workspace/zig_guide/sections/13_logging_diagnostics/content.md",
        "lines": 6,
        "chars": 139
      }
    ]
  },
  {
    "chapter": "14_migration_guide",
    "content_file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
    "total_blocks": 52,
    "runnable_blocks": 6,
    "snippet_blocks": 46,
    "runnable": [
      {
        "index": 19,
        "start_line": 384,
        "end_line": 396,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n    const stderr = std.io.getStdErr().writer();\n\n    try stdout.print(\"Regular output\\n\", .{});\n    try stdout.print(\"Value: {d}\\n\", .{42});\n\n    try stderr.print(\"Error message\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 11,
        "chars": 288
      },
      {
        "index": 20,
        "start_line": 399,
        "end_line": 416,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    // Buffered stdout for better performance\n    var stdout_buf: [256]u8 = undefined;\n    var stdout = std.fs.File.stdout().writer(&stdout_buf);\n\n    // Unbuffered stderr for immediate error visibility\n    var stderr = std.fs.File.stderr().writer(&.{});\n\n    try stdout.interface.print(\"Regular output\\n\", .{});\n    try stdout.interface.print(\"Value: {d}\\n\", .{42});\n    try stdout.interface.flush();  // Ensure output is visible\n\n    try stderr.interface.print(\"Error message\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 16,
        "chars": 540
      },
      {
        "index": 21,
        "start_line": 435,
        "end_line": 455,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    var list = std.ArrayList(u32).init(allocator);\n    defer list.deinit();\n\n    try list.append(10);\n    try list.append(20);\n    try list.appendSlice(&[_]u32{30, 40});\n\n    for (list.items) |item| {\n        std.debug.print(\"{d} \", .{item});\n    }\n    std.debug.print(\"\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 19,
        "chars": 456
      },
      {
        "index": 22,
        "start_line": 458,
        "end_line": 478,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    var list = std.ArrayList(u32).empty;\n    defer list.deinit(allocator);\n\n    try list.append(allocator, 10);\n    try list.append(allocator, 20);\n    try list.appendSlice(allocator, &[_]u32{30, 40});\n\n    for (list.items) |item| {\n        std.debug.print(\"{d} \", .{item});\n    }\n    std.debug.print(\"\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 19,
        "chars": 488
      },
      {
        "index": 23,
        "start_line": 493,
        "end_line": 507,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const file = try std.fs.cwd().createFile(\"output.txt\", .{});\n    defer file.close();\n\n    const writer = file.writer();\n\n    try writer.print(\"Writing to file\\n\", .{});\n    for (0..100) |i| {\n        try writer.print(\"Line {d}\\n\", .{i});\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 13,
        "chars": 300
      },
      {
        "index": 24,
        "start_line": 510,
        "end_line": 526,
        "code": "const std = @import(\"std\");\n\npub fn main() !void {\n    const file = try std.fs.cwd().createFile(\"output.txt\", .{});\n    defer file.close();\n\n    var buf: [4096]u8 = undefined;  // 4KB buffer for file I/O\n    var writer = file.writer(&buf);\n\n    try writer.interface.print(\"Writing to file\\n\", .{});\n    for (0..100) |i| {\n        try writer.interface.print(\"Line {d}\\n\", .{i});\n    }\n    try writer.interface.flush();  // CRITICAL: flush before close\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 15,
        "chars": 452
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 64,
        "end_line": 71,
        "code": "const exe = b.addExecutable(.{\n    .name = \"app\",\n    .root_source_file = b.path(\"src/main.zig\"),\n    .target = target,      // Accepted directly\n    .optimize = optimize,  // Accepted directly\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 6,
        "chars": 197
      },
      {
        "index": 2,
        "start_line": 74,
        "end_line": 83,
        "code": "const exe = b.addExecutable(.{\n    .name = \"app\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,      // Inside createModule\n        .optimize = optimize,  // Inside createModule\n    }),\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 8,
        "chars": 258
      },
      {
        "index": 3,
        "start_line": 101,
        "end_line": 104,
        "code": "const lib = b.addStaticLibrary(.{...});\n// Or: b.addSharedLibrary(.{...});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 74
      },
      {
        "index": 4,
        "start_line": 107,
        "end_line": 113,
        "code": "const lib = b.addLibrary(.{\n    .name = \"mylib\",\n    .linkage = .static,  // or .dynamic\n    .root_module = b.createModule(.{...}),\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 5,
        "chars": 135
      },
      {
        "index": 5,
        "start_line": 126,
        "end_line": 129,
        "code": "const stdout = std.io.getStdOut().writer();\nconst stderr = std.io.getStdErr().writer();",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 87
      },
      {
        "index": 6,
        "start_line": 132,
        "end_line": 135,
        "code": "const stdout = std.fs.File.stdout();\nconst stderr = std.fs.File.stderr();",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 73
      },
      {
        "index": 7,
        "start_line": 142,
        "end_line": 145,
        "code": "const writer = file.writer();  // No parameters\ntry writer.print(\"Data\\n\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 80
      },
      {
        "index": 8,
        "start_line": 148,
        "end_line": 158,
        "code": "// Buffered (recommended for files)\nvar buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Data\\n\", .{});\ntry writer.interface.flush();  // CRITICAL\n\n// Unbuffered (for immediate writes)\nvar writer = file.writer(&.{});  // Empty slice\ntry writer.interface.print(\"Data\\n\", .{});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 9,
        "chars": 313
      },
      {
        "index": 9,
        "start_line": 190,
        "end_line": 196,
        "code": "var buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Important data\\n\", .{});\ntry writer.interface.flush();  // \u2705 CRITICAL - ensures data written\nfile.close();",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 5,
        "chars": 197
      },
      {
        "index": 10,
        "start_line": 207,
        "end_line": 213,
        "code": "var list = std.ArrayList(u32).init(allocator);  // Stores allocator\ndefer list.deinit();  // Uses stored allocator\n\ntry list.append(42);  // Uses stored allocator\ntry list.appendSlice(&[_]u32{1, 2, 3});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 5,
        "chars": 202
      },
      {
        "index": 11,
        "start_line": 216,
        "end_line": 222,
        "code": "var list = std.ArrayList(u32).empty;  // Or: .{}\ndefer list.deinit(allocator);  // Must pass allocator\n\ntry list.append(allocator, 42);  // Must pass allocator\ntry list.appendSlice(allocator, &[_]u32{1, 2, 3});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 5,
        "chars": 210
      },
      {
        "index": 12,
        "start_line": 233,
        "end_line": 240,
        "code": "const Container = struct {\n    items: ArrayList(u32),    // 8 bytes allocator overhead\n    names: ArrayList([]u8),   // 8 bytes allocator overhead\n    allocator: Allocator,     // 8 bytes\n    // Total: 24 bytes in allocator pointers\n};",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 6,
        "chars": 235
      },
      {
        "index": 13,
        "start_line": 243,
        "end_line": 250,
        "code": "const Container = struct {\n    items: ArrayList(u32),    // NO allocator stored\n    names: ArrayList([]u8),   // NO allocator stored\n    allocator: Allocator,     // 8 bytes\n    // Total: 8 bytes in allocator pointers (saves 16 bytes)\n};",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 6,
        "chars": 237
      },
      {
        "index": 14,
        "start_line": 253,
        "end_line": 256,
        "code": "try list.append(allocator, item);  // Clear: may allocate\nconst item = list.pop();  // Clear: won't allocate (no allocator parameter)",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 133
      },
      {
        "index": 15,
        "start_line": 264,
        "end_line": 268,
        "code": "var list = std.array_list.AlignedManaged(u32, null).init(allocator);\ndefer list.deinit();\ntry list.append(42);  // Old API still works",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 3,
        "chars": 134
      },
      {
        "index": 16,
        "start_line": 274,
        "end_line": 278,
        "code": "var list = std.ArrayList(u32).empty;\ndefer list.deinit(allocator);\ntry list.append(allocator, 42);",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 3,
        "chars": 98
      },
      {
        "index": 17,
        "start_line": 312,
        "end_line": 334,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const exe = b.addExecutable(.{\n        .name = \"simple\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    b.installArtifact(exe);\n\n    const run_cmd = b.addRunArtifact(exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n\n    const run_step = b.step(\"run\", \"Run the app\");\n    run_step.dependOn(&run_cmd.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 21,
        "chars": 554
      },
      {
        "index": 18,
        "start_line": 337,
        "end_line": 361,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const exe = b.addExecutable(.{\n        .name = \"simple\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    b.installArtifact(exe);\n\n    const run_cmd = b.addRunArtifact(exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n\n    const run_step = b.step(\"run\", \"Run the app\");\n    run_step.dependOn(&run_cmd.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 23,
        "chars": 619
      },
      {
        "index": 25,
        "start_line": 550,
        "end_line": 574,
        "code": "pub const Config = struct {\n    patterns: std.ArrayList([]const u8),\n    allocator: std.mem.Allocator,\n\n    pub fn init(allocator: std.mem.Allocator) !Config {\n        return Config{\n            .patterns = std.ArrayList([]const u8).init(allocator),\n            .allocator = allocator,\n        };\n    }\n\n    pub fn deinit(self: *Config) void {\n        for (self.patterns.items) |pattern| {\n            self.allocator.free(pattern);\n        }\n        self.patterns.deinit();\n    }\n\n    pub fn addPattern(self: *Config, pattern: []const u8) !void {\n        const owned = try self.allocator.dupe(u8, pattern);\n        try self.patterns.append(owned);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 23,
        "chars": 656
      },
      {
        "index": 26,
        "start_line": 577,
        "end_line": 601,
        "code": "pub const Config = struct {\n    patterns: std.ArrayList([]const u8),\n    allocator: std.mem.Allocator,\n\n    pub fn init(allocator: std.mem.Allocator) !Config {\n        return Config{\n            .patterns = std.ArrayList([]const u8).empty,\n            .allocator = allocator,\n        };\n    }\n\n    pub fn deinit(self: *Config) void {\n        for (self.patterns.items) |pattern| {\n            self.allocator.free(pattern);\n        }\n        self.patterns.deinit(self.allocator);\n    }\n\n    pub fn addPattern(self: *Config, pattern: []const u8) !void {\n        const owned = try self.allocator.dupe(u8, pattern);\n        try self.patterns.append(self.allocator, owned);\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 23,
        "chars": 676
      },
      {
        "index": 27,
        "start_line": 617,
        "end_line": 646,
        "code": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Export library module\n    _ = b.addModule(\"mathlib\", .{\n        .root_source_file = b.path(\"src/mathlib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Example executable\n    const example = b.addExecutable(.{\n        .name = \"mathlib_example\",\n        .root_source_file = b.path(\"examples/usage.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const mathlib_mod = b.createModule(.{\n        .root_source_file = b.path(\"src/mathlib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    example.root_module.addImport(\"mathlib\", mathlib_mod);\n\n    b.installArtifact(example);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 28,
        "chars": 797
      },
      {
        "index": 28,
        "start_line": 649,
        "end_line": 682,
        "code": "pub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Export library module (unchanged)\n    _ = b.addModule(\"mathlib\", .{\n        .root_source_file = b.path(\"src/mathlib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Example executable - requires .root_module\n    const mathlib_mod = b.createModule(.{\n        .root_source_file = b.path(\"src/mathlib.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const example = b.addExecutable(.{\n        .name = \"mathlib_example\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"examples/usage.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{ .name = \"mathlib\", .module = mathlib_mod },\n            },\n        }),\n    });\n\n    b.installArtifact(example);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 32,
        "chars": 944
      },
      {
        "index": 29,
        "start_line": 709,
        "end_line": 716,
        "code": "const exe = b.addExecutable(.{\n    .name = \"app\",\n    .root_source_file = b.path(\"src/main.zig\"),\n    .target = target,\n    .optimize = optimize,\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 6,
        "chars": 149
      },
      {
        "index": 30,
        "start_line": 719,
        "end_line": 728,
        "code": "const exe = b.addExecutable(.{\n    .name = \"app\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    }),\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 8,
        "chars": 206
      },
      {
        "index": 31,
        "start_line": 742,
        "end_line": 751,
        "code": "const exe = b.addExecutable(.{\n    .name = \"app\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n    }),\n    .target = target,     // WRONG: belongs in createModule\n    .optimize = optimize, // WRONG: belongs in createModule\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 8,
        "chars": 270
      },
      {
        "index": 32,
        "start_line": 754,
        "end_line": 763,
        "code": "const exe = b.addExecutable(.{\n    .name = \"app\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,     // Correct location\n        .optimize = optimize, // Correct location\n    }),\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 8,
        "chars": 250
      },
      {
        "index": 33,
        "start_line": 774,
        "end_line": 779,
        "code": "var buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Important data\\n\", .{});\nfile.close();  // \u274c Data still in buffer - LOST!",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 4,
        "chars": 164
      },
      {
        "index": 34,
        "start_line": 782,
        "end_line": 788,
        "code": "var buf: [4096]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Important data\\n\", .{});\ntry writer.interface.flush();  // \u2705 Write buffer to file\nfile.close();",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 5,
        "chars": 186
      },
      {
        "index": 35,
        "start_line": 793,
        "end_line": 801,
        "code": "test \"verify file size\" {\n    // ... write data ...\n    try writer.interface.flush();\n\n    const stat = try file.stat();\n    try std.testing.expectEqual(expected_size, stat.size);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 7,
        "chars": 181
      },
      {
        "index": 36,
        "start_line": 813,
        "end_line": 815,
        "code": "const stdout = std.io.getStdOut();",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 1,
        "chars": 34
      },
      {
        "index": 37,
        "start_line": 818,
        "end_line": 820,
        "code": "const stdout = std.fs.File.stdout();",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 1,
        "chars": 36
      },
      {
        "index": 38,
        "start_line": 834,
        "end_line": 838,
        "code": "var buf: [256]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.print(\"Hello\\n\", .{});  // \u274c No 'print' field",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 3,
        "chars": 118
      },
      {
        "index": 39,
        "start_line": 841,
        "end_line": 845,
        "code": "var buf: [256]u8 = undefined;\nvar writer = file.writer(&buf);\ntry writer.interface.print(\"Hello\\n\", .{});  // \u2705 Access via .interface",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 3,
        "chars": 133
      },
      {
        "index": 40,
        "start_line": 854,
        "end_line": 860,
        "code": "fn getWriter(file: std.fs.File) Writer {\n    var buf: [256]u8 = undefined;  // \u274c Stack allocation\n    var writer = file.writer(&buf);\n    return writer;  // \u274c buf is destroyed when function returns!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 5,
        "chars": 200
      },
      {
        "index": 41,
        "start_line": 863,
        "end_line": 881,
        "code": "const FileWriter = struct {\n    file: std.fs.File,\n    buffer: [4096]u8 = undefined,\n    writer: std.fs.File.Writer,\n\n    fn init(file: std.fs.File) FileWriter {\n        var self: FileWriter = undefined;\n        self.file = file;\n        self.writer = file.writer(&self.buffer);\n        return self;\n    }\n\n    fn deinit(self: *FileWriter) !void {\n        try self.writer.interface.flush();\n        self.file.close();\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 17,
        "chars": 426
      },
      {
        "index": 42,
        "start_line": 897,
        "end_line": 900,
        "code": "var list = std.ArrayList(u32).empty;\ndefer list.deinit();  // \u274c Needs allocator parameter",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 89
      },
      {
        "index": 43,
        "start_line": 903,
        "end_line": 906,
        "code": "var list = std.ArrayList(u32).empty;\ndefer list.deinit(allocator);  // \u2705 Pass allocator",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 87
      },
      {
        "index": 44,
        "start_line": 920,
        "end_line": 922,
        "code": "var list = std.ArrayList(u32).init(allocator);  // \u274c init() removed",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 1,
        "chars": 67
      },
      {
        "index": 45,
        "start_line": 925,
        "end_line": 928,
        "code": "var list = std.ArrayList(u32).empty;  // \u2705 Use .empty or .{}\n// Or: var list: std.ArrayList(u32) = .{};",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 2,
        "chars": 103
      },
      {
        "index": 46,
        "start_line": 942,
        "end_line": 944,
        "code": "try list.append(42);  // \u274c Needs allocator as first parameter",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 1,
        "chars": 61
      },
      {
        "index": 47,
        "start_line": 947,
        "end_line": 949,
        "code": "try list.append(allocator, 42);  // \u2705 Pass allocator",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 1,
        "chars": 52
      },
      {
        "index": 48,
        "start_line": 958,
        "end_line": 966,
        "code": "var gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar arena = std.heap.ArenaAllocator.init(gpa.allocator());\n\nvar list = std.ArrayList(u32).empty;\ntry list.append(arena.allocator(), 42);\n\nlist.deinit(gpa.allocator());  // \u274c WRONG: different allocator!",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 7,
        "chars": 252
      },
      {
        "index": 49,
        "start_line": 969,
        "end_line": 978,
        "code": "var gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar arena = std.heap.ArenaAllocator.init(gpa.allocator());\n\nconst alloc = arena.allocator();  // Use one allocator consistently\nvar list = std.ArrayList(u32).empty;\ntry list.append(alloc, 42);\n\nlist.deinit(alloc);  // \u2705 Same allocator",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 8,
        "chars": 285
      },
      {
        "index": 50,
        "start_line": 992,
        "end_line": 1003,
        "code": "const tigerbeetle = b.addExecutable(.{\n    .name = \"tigerbeetle\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/tigerbeetle/main.zig\"),\n        .target = options.target,\n        .optimize = options.mode,\n    }),\n});\ntigerbeetle.root_module.addImport(\"stdx\", options.stdx_module);\ntigerbeetle.root_module.addImport(\"vsr\", options.vsr_module);",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 10,
        "chars": 372
      },
      {
        "index": 51,
        "start_line": 1015,
        "end_line": 1035,
        "code": "const build_options = blk: {\n    const opts = b.addOptions();\n    opts.step.name = \"ZLS build options\";\n    opts.addOption(std.SemanticVersion, \"version\", resolved_version);\n    opts.addOption([]const u8, \"version_string\", b.fmt(\"{f}\", .{resolved_version}));\n    break :blk opts.createModule();\n};\n\nconst exe = b.addExecutable(.{\n    .name = \"zls\",\n    .root_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n        .imports = &.{\n            .{ .name = \"build_options\", .module = build_options },\n        },\n    }),\n});",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 19,
        "chars": 606
      },
      {
        "index": 52,
        "start_line": 1045,
        "end_line": 1055,
        "code": "// Terminal output with appropriate buffering\nvar stdout_buf: [8192]u8 = undefined;  // Larger buffer for terminal\nvar writer = stdout.writer(&stdout_buf);\n\n// Batch terminal updates\nfor (screen_updates) |update| {\n    try writer.interface.print(\"{}\", .{update});\n}\ntry writer.interface.flush();  // Flush after batch",
        "file": "/home/jack/workspace/zig_guide/sections/14_migration_guide/content.md",
        "lines": 9,
        "chars": 317
      }
    ]
  },
  {
    "chapter": "15_appendices",
    "content_file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
    "total_blocks": 96,
    "runnable_blocks": 1,
    "snippet_blocks": 95,
    "runnable": [
      {
        "index": 9,
        "start_line": 611,
        "end_line": 631,
        "code": "// \u2705 GOOD: Consistent ordering (from Zig stdlib)\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst Allocator = std.mem.Allocator;\nconst testing = std.testing;\n\n// Type definitions\npub const Config = struct { ... };\npub const Error = error { ... };\n\n// Public functions\npub fn init(allocator: Allocator) !Config { ... }\npub fn deinit(self: *Config) void { ... }\n\n// Private functions\nfn validateConfig(config: *const Config) bool { ... }\n\n// Tests\ntest \"config initialization\" { ... }",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 19,
        "chars": 503
      }
    ],
    "snippets": [
      {
        "index": 1,
        "start_line": 541,
        "end_line": 551,
        "code": "// \u2705 GOOD: Clear snake_case naming\npub fn calculate_total_price(items: []const Item) f64 {\n    var total: f64 = 0;\n    for (items) |item| total += item.price;\n    return total;\n}\n\nconst max_buffer_size = 4096;\nconst retry_count: u32 = 3;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 237
      },
      {
        "index": 2,
        "start_line": 553,
        "end_line": 557,
        "code": "// \u274c BAD: Avoid camelCase or PascalCase for functions/variables\npub fn CalculateTotalPrice(items: []const Item) f64 { }\nconst maxBufferSize = 4096;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 147
      },
      {
        "index": 3,
        "start_line": 561,
        "end_line": 569,
        "code": "// \u2705 GOOD: Types use PascalCase\npub const HttpServer = struct {\n    allocator: Allocator,\n    port: u16,\n};\n\npub const RequestError = error { InvalidMethod, Timeout };",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 7,
        "chars": 167
      },
      {
        "index": 4,
        "start_line": 571,
        "end_line": 575,
        "code": "// \u274c BAD: Avoid snake_case for types\npub const http_server = struct { };\npub const request_error = error { };",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 109
      },
      {
        "index": 5,
        "start_line": 579,
        "end_line": 583,
        "code": "// \u2705 GOOD: Regular snake_case for constants\nconst default_timeout_ms = 5000;\nconst max_connections = 100;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 105
      },
      {
        "index": 6,
        "start_line": 585,
        "end_line": 589,
        "code": "// \u274c BAD: Avoid SCREAMING_SNAKE_CASE (not Zig style)\nconst DEFAULT_TIMEOUT_MS = 5000;\nconst MAX_CONNECTIONS = 100;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 114
      },
      {
        "index": 7,
        "start_line": 593,
        "end_line": 599,
        "code": "// \u2705 GOOD: Unit suffixes for clarity (TigerBeetle convention)\nconst latency_ms_max: u64 = 100;\nconst timeout_ns: u64 = 1_000_000;\nconst file_size_bytes: usize = 1024;\nconst duration_seconds: f64 = 2.5;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 5,
        "chars": 201
      },
      {
        "index": 8,
        "start_line": 601,
        "end_line": 605,
        "code": "// \u274c BAD: Ambiguous units or prefixes\nconst max_latency: u64 = 100; // Units unclear\nconst timeout: u64 = 1_000_000; // Milliseconds? Nanoseconds?",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 146
      },
      {
        "index": 10,
        "start_line": 635,
        "end_line": 643,
        "code": "// \u2705 GOOD: Imports first, then type aliases\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst mylib = @import(\"mylib\");\n\nconst Allocator = std.mem.Allocator;\nconst ArrayList = std.ArrayList;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 7,
        "chars": 210
      },
      {
        "index": 11,
        "start_line": 645,
        "end_line": 650,
        "code": "// \u274c BAD: Mixed imports and code\nconst std = @import(\"std\");\nconst MyType = struct { ... };\nconst builtin = @import(\"builtin\"); // Import should be at top",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 154
      },
      {
        "index": 12,
        "start_line": 656,
        "end_line": 667,
        "code": "// \u2705 GOOD: Allocator first (Zig convention)\npub fn create(allocator: Allocator, capacity: usize) !*Self {\n    const self = try allocator.create(Self);\n    errdefer allocator.destroy(self);\n    // ...\n}\n\npub fn loadFile(allocator: Allocator, path: []const u8) ![]u8 {\n    // ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 10,
        "chars": 279
      },
      {
        "index": 13,
        "start_line": 669,
        "end_line": 672,
        "code": "// \u274c BAD: Allocator not first\npub fn create(capacity: usize, allocator: Allocator) !*Self { }",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 93
      },
      {
        "index": 14,
        "start_line": 676,
        "end_line": 688,
        "code": "// \u2705 GOOD: Consistent init/deinit pairing\npub fn init(allocator: Allocator) Self {\n    return Self{\n        .allocator = allocator,\n        .items = &[_]Item{},\n    };\n}\n\npub fn deinit(self: *Self) void {\n    self.allocator.free(self.items);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 11,
        "chars": 243
      },
      {
        "index": 15,
        "start_line": 692,
        "end_line": 699,
        "code": "// \u2705 GOOD: Explicit error set documents possible failures\npub const ReadError = error{ FileNotFound, PermissionDenied, OutOfMemory };\n\npub fn readConfig(path: []const u8) ReadError!Config {\n    // ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 6,
        "chars": 202
      },
      {
        "index": 16,
        "start_line": 701,
        "end_line": 704,
        "code": "// \u274c BAD: anyerror hides what can fail\npub fn readConfig(path: []const u8) anyerror!Config { }",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 94
      },
      {
        "index": 17,
        "start_line": 710,
        "end_line": 720,
        "code": "// \u2705 GOOD: defer right after acquisition\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\ndefer _ = gpa.deinit();\n\nconst file = try std.fs.cwd().openFile(\"data.txt\", .{});\ndefer file.close();\n\nconst buffer = try allocator.alloc(u8, 1024);\ndefer allocator.free(buffer);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 270
      },
      {
        "index": 18,
        "start_line": 722,
        "end_line": 728,
        "code": "// \u274c BAD: defer separated from acquisition\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\n// ... lots of code ...\ndefer _ = gpa.deinit(); // Easy to forget or misplace",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 5,
        "chars": 206
      },
      {
        "index": 19,
        "start_line": 732,
        "end_line": 743,
        "code": "// \u2705 GOOD: errdefer for cleanup on initialization failure\npub fn init(allocator: Allocator, capacity: usize) !Self {\n    const buffer = try allocator.alloc(u8, capacity);\n    errdefer allocator.free(buffer);\n\n    const metadata = try allocator.create(Metadata);\n    errdefer allocator.destroy(metadata);\n\n    return Self{ .buffer = buffer, .metadata = metadata };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 10,
        "chars": 365
      },
      {
        "index": 20,
        "start_line": 747,
        "end_line": 756,
        "code": "// \u2705 GOOD: try for simple error propagation\nconst data = try readFile(allocator, path);\n\n// \u2705 GOOD: catch when handling specific errors\nconst data = readFile(allocator, path) catch |err| switch (err) {\n    error.FileNotFound => return default_data,\n    else => return err,\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 8,
        "chars": 275
      },
      {
        "index": 21,
        "start_line": 758,
        "end_line": 761,
        "code": "// \u274c BAD: Unnecessary catch just to return error\nconst data = readFile(allocator, path) catch |e| return e; // Use try",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 118
      },
      {
        "index": 22,
        "start_line": 767,
        "end_line": 779,
        "code": "// \u2705 GOOD: Arena for request-scoped allocations\nfn handleRequest(parent_allocator: Allocator, request: Request) !Response {\n    var arena = std.heap.ArenaAllocator.init(parent_allocator);\n    defer arena.deinit();\n    const allocator = arena.allocator();\n\n    // All temporary allocations freed together\n    const parsed = try parseRequest(allocator, request);\n    const result = try processRequest(allocator, parsed);\n    return result;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 11,
        "chars": 439
      },
      {
        "index": 23,
        "start_line": 783,
        "end_line": 794,
        "code": "// \u2705 GOOD: Document ownership transfer\n/// Caller owns returned memory. Must call deinit() or use defer.\npub fn create(allocator: Allocator) !*Self {\n    // ...\n}\n\n/// Caller owns returned slice. Use allocator.free() to clean up.\npub fn readAll(allocator: Allocator, reader: anytype) ![]u8 {\n    // ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 10,
        "chars": 304
      },
      {
        "index": 24,
        "start_line": 798,
        "end_line": 805,
        "code": "// \u2705 GOOD: Slices carry length information\npub fn processData(data: []const u8) void {\n    for (data) |byte| {\n        // Safe: slice knows its length\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 6,
        "chars": 158
      },
      {
        "index": 25,
        "start_line": 807,
        "end_line": 815,
        "code": "// \u274c BAD: Raw pointer loses length (unsafe)\npub fn processData(data: [*]const u8, len: usize) void {\n    var i: usize = 0;\n    while (i < len) : (i += 1) { // Manual length tracking\n        _ = data[i];\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 7,
        "chars": 210
      },
      {
        "index": 26,
        "start_line": 821,
        "end_line": 834,
        "code": "// \u2705 GOOD: Assertions verify preconditions and invariants\npub fn findIndex(items: []const i32, target: i32) ?usize {\n    std.debug.assert(items.len > 0); // Precondition\n\n    for (items, 0..) |item, i| {\n        if (item == target) {\n            std.debug.assert(i < items.len); // Invariant\n            return i;\n        }\n    }\n    return null;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 348
      },
      {
        "index": 27,
        "start_line": 838,
        "end_line": 852,
        "code": "// \u2705 GOOD: Document assumptions with assertions\npub fn resize(self: *Self, new_size: usize) !void {\n    std.debug.assert(new_size > 0); // Size must be positive\n    std.debug.assert(self.capacity >= self.len); // Capacity invariant\n\n    if (new_size > self.capacity) {\n        std.debug.assert(self.allocator != null); // Need allocator to grow\n        try self.grow(new_size);\n    }\n\n    self.len = new_size;\n    std.debug.assert(self.len <= self.capacity); // Post-condition\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 13,
        "chars": 478
      },
      {
        "index": 28,
        "start_line": 856,
        "end_line": 866,
        "code": "// \u2705 GOOD: unreachable for exhaustive switch with known enum\nfn handleColor(color: Color) void {\n    switch (color) {\n        .red => std.debug.print(\"Red\\n\", .{}),\n        .green => std.debug.print(\"Green\\n\", .{}),\n        .blue => std.debug.print(\"Blue\\n\", .{}),\n        // No else needed; all cases covered\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 317
      },
      {
        "index": 29,
        "start_line": 868,
        "end_line": 871,
        "code": "// \u274c BAD: unreachable for lazy error handling\nconst value = parseInt(str) catch unreachable; // Could panic!",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 108
      },
      {
        "index": 30,
        "start_line": 877,
        "end_line": 889,
        "code": "// \u2705 GOOD: Doc comments with triple-slash\n/// Parses a JSON string into the specified type T.\n/// Caller owns returned memory; use deinit() or parseFree().\n/// Returns error.SyntaxError if JSON is malformed.\npub fn parseFromSlice(\n    comptime T: type,\n    allocator: Allocator,\n    json: []const u8,\n) !T {\n    // ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 11,
        "chars": 320
      },
      {
        "index": 31,
        "start_line": 893,
        "end_line": 902,
        "code": "// \u2705 GOOD: Clear ownership and error documentation\n/// Opens file at path for reading.\n/// Caller must call close() on returned file handle.\n/// Returns error.FileNotFound if path doesn't exist.\n/// Returns error.PermissionDenied if insufficient permissions.\npub fn openFile(path: []const u8) !File {\n    // ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 8,
        "chars": 313
      },
      {
        "index": 32,
        "start_line": 908,
        "end_line": 924,
        "code": "// \u2705 GOOD: Descriptive test names\ntest \"ArrayList.append increases length\" {\n    var list = ArrayList(i32).init(testing.allocator);\n    defer list.deinit();\n\n    try list.append(42);\n    try testing.expectEqual(@as(usize, 1), list.items.len);\n}\n\ntest \"HashMap.get returns null for missing key\" {\n    var map = AutoHashMap([]const u8, i32).init(testing.allocator);\n    defer map.deinit();\n\n    try testing.expect(map.get(\"missing\") == null);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 15,
        "chars": 442
      },
      {
        "index": 33,
        "start_line": 928,
        "end_line": 938,
        "code": "// \u2705 GOOD: Always use testing.allocator in tests\ntest \"memory leak detection\" {\n    const allocator = testing.allocator;\n\n    const buffer = try allocator.alloc(u8, 100);\n    defer allocator.free(buffer); // Leak detected if missing\n\n    // Test fails if defer forgotten\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 272
      },
      {
        "index": 34,
        "start_line": 944,
        "end_line": 948,
        "code": "// \u2705 GOOD: Stack allocation when size known at comptime\nvar buffer: [4096]u8 = undefined;\nconst result = try std.fmt.bufPrint(&buffer, \"Value: {}\", .{value});",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 158
      },
      {
        "index": 35,
        "start_line": 950,
        "end_line": 954,
        "code": "// \u274c BAD: Heap allocation for small fixed-size buffer\nconst buffer = try allocator.alloc(u8, 4096);\ndefer allocator.free(buffer);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 129
      },
      {
        "index": 36,
        "start_line": 958,
        "end_line": 963,
        "code": "// \u2705 GOOD: inline for small hot functions\ninline fn fastMin(a: i32, b: i32) i32 {\n    return if (a < b) a else b;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 115
      },
      {
        "index": 37,
        "start_line": 967,
        "end_line": 972,
        "code": "// \u2705 GOOD: Unroll comptime-known iterations\ninline for (0..4) |i| {\n    data[i] = computeValue(i);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 100
      },
      {
        "index": 38,
        "start_line": 1112,
        "end_line": 1118,
        "code": "const x: i32 = 42;              // Immutable, type explicit\nconst y = 42;                   // Immutable, type inferred\nvar z: i32 = 42;                // Mutable, type explicit\nvar w = 42;                     // Mutable, type inferred\nvar arr: [5]i32 = undefined;    // Array, uninitialized",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 5,
        "chars": 291
      },
      {
        "index": 39,
        "start_line": 1122,
        "end_line": 1136,
        "code": "fn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\npub fn publicFn() void { }      // Public function\n\nfn errorFn() !i32 {             // Returns i32 or error\n    return error.Failed;\n}\n\nfn genericFn(comptime T: type, val: T) T {\n    return val;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 13,
        "chars": 246
      },
      {
        "index": 40,
        "start_line": 1140,
        "end_line": 1180,
        "code": "// If expression\nconst max = if (a > b) a else b;\n\n// If statement\nif (condition) {\n    // ...\n} else if (other) {\n    // ...\n} else {\n    // ...\n}\n\n// While loop\nwhile (condition) {\n    // ...\n}\n\n// While with continue expression\nvar i: u32 = 0;\nwhile (i < 10) : (i += 1) {\n    // ...\n}\n\n// For loop (iterate over slice/array)\nfor (items) |item| {\n    // ...\n}\n\n// For with index\nfor (items, 0..) |item, i| {\n    // ...\n}\n\n// Switch expression\nconst result = switch (value) {\n    0 => \"zero\",\n    1, 2, 3 => \"low\",\n    else => \"high\",\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 39,
        "chars": 538
      },
      {
        "index": 41,
        "start_line": 1184,
        "end_line": 1208,
        "code": "// Error set\nconst MyError = error{ Failed, InvalidInput };\n\n// Error union type\nfn doWork() !i32 { }\n\n// Try (propagate error)\nconst val = try doWork();\n\n// Catch (handle error)\nconst val = doWork() catch |err| {\n    // Handle err\n    return default;\n};\n\n// Catch with default\nconst val = doWork() catch 0;\n\n// Defer (always runs at scope exit)\ndefer cleanup();\n\n// Errdefer (runs only on error)\nerrdefer cleanup();",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 23,
        "chars": 416
      },
      {
        "index": 42,
        "start_line": 1212,
        "end_line": 1229,
        "code": "// Optional type\nvar x: ?i32 = null;\nx = 42;\n\n// Unwrap with orelse\nconst val = x orelse 0;\n\n// Unwrap with if\nif (x) |value| {\n    // Use value\n}\n\n// Pointer unwrap\nif (ptr) |p| {\n    // p is non-null pointer\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 16,
        "chars": 211
      },
      {
        "index": 43,
        "start_line": 1233,
        "end_line": 1249,
        "code": "// Single-item pointer\nconst ptr: *i32 = &value;\n\n// Const pointer\nconst const_ptr: *const i32 = &value;\n\n// Many-item pointer\nconst many: [*]i32 = ptr;\n\n// Slice (fat pointer: pointer + length)\nconst slice: []i32 = array[0..3];\nconst const_slice: []const u8 = \"hello\";\n\n// Sentinel-terminated slice\nconst str: [:0]const u8 = \"null-terminated\";",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 15,
        "chars": 344
      },
      {
        "index": 44,
        "start_line": 1253,
        "end_line": 1269,
        "code": "const Point = struct {\n    x: f32,\n    y: f32,\n\n    pub fn init(x: f32, y: f32) Point {\n        return Point{ .x = x, .y = y };\n    }\n\n    pub fn distance(self: Point) f32 {\n        return @sqrt(self.x * self.x + self.y * self.y);\n    }\n};\n\n// Anonymous struct\nconst config = .{ .width = 800, .height = 600 };",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 15,
        "chars": 309
      },
      {
        "index": 45,
        "start_line": 1273,
        "end_line": 1287,
        "code": "const Color = enum {\n    red,\n    green,\n    blue,\n\n    pub fn toRgb(self: Color) [3]u8 {\n        return switch (self) {\n            .red => .{255, 0, 0},\n            .green => .{0, 255, 0},\n            .blue => .{0, 0, 255},\n        };\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 13,
        "chars": 245
      },
      {
        "index": 46,
        "start_line": 1291,
        "end_line": 1306,
        "code": "// Tagged union\nconst Value = union(enum) {\n    int: i32,\n    float: f64,\n    string: []const u8,\n};\n\nconst v = Value{ .int = 42 };\n\nswitch (v) {\n    .int => |i| std.debug.print(\"int: {}\\n\", .{i}),\n    .float => |f| std.debug.print(\"float: {}\\n\", .{f}),\n    .string => |s| std.debug.print(\"string: {s}\\n\", .{s}),\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 14,
        "chars": 314
      },
      {
        "index": 47,
        "start_line": 1310,
        "end_line": 1328,
        "code": "// Comptime variable\ncomptime var count = 0;\n\n// Comptime parameter\nfn generic(comptime T: type, val: T) T {\n    return val;\n}\n\n// Comptime block\ncomptime {\n    @compileLog(\"This runs at compile time\");\n}\n\n// Inline for (unrolled at compile time)\ninline for (0..4) |i| {\n    // Unrolled 4 times\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 17,
        "chars": 296
      },
      {
        "index": 48,
        "start_line": 1332,
        "end_line": 1345,
        "code": "@import(\"std\")                  // Import module\n@as(T, value)                   // Type coercion\n@intCast(value)                 // Integer cast\n@floatCast(value)               // Float cast\n@sizeOf(T)                      // Size of type in bytes\n@alignOf(T)                     // Alignment of type\n@TypeOf(expr)                   // Get type of expression\n@compileError(\"msg\")            // Compile-time error\n@compileLog(expr)               // Compile-time print\n@field(struct, \"name\")          // Access field by name\n@hasField(T, \"name\")            // Check field existence\n@embedFile(\"path\")              // Embed file at compile time",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 642
      },
      {
        "index": 49,
        "start_line": 1353,
        "end_line": 1375,
        "code": "pub const Server = struct {\n    allocator: Allocator,\n    port: u16,\n    clients: ArrayList(*Client),\n\n    pub fn init(allocator: Allocator, port: u16) !Server {\n        return Server{\n            .allocator = allocator,\n            .port = port,\n            .clients = ArrayList(*Client).init(allocator),\n        };\n    }\n\n    pub fn deinit(self: *Server) void {\n        for (self.clients.items) |client| {\n            client.deinit();\n            self.allocator.destroy(client);\n        }\n        self.clients.deinit();\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 21,
        "chars": 530
      },
      {
        "index": 50,
        "start_line": 1379,
        "end_line": 1392,
        "code": "pub fn createResource(allocator: Allocator) !*Resource {\n    const resource = try allocator.create(Resource);\n    errdefer allocator.destroy(resource);\n\n    resource.buffer = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(resource.buffer);\n\n    try resource.initialize();\n    // If initialize() fails, both buffer and resource are freed\n\n    return resource;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 372
      },
      {
        "index": 51,
        "start_line": 1396,
        "end_line": 1409,
        "code": "fn processRequest(parent_allocator: Allocator, request: Request) !Response {\n    var arena = std.heap.ArenaAllocator.init(parent_allocator);\n    defer arena.deinit(); // Free all at once\n    const allocator = arena.allocator();\n\n    const parsed = try parseJson(allocator, request.body);\n    const validated = try validateData(allocator, parsed);\n    const result = try computeResult(allocator, validated);\n\n    // All temporary allocations freed here\n    return result;\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 472
      },
      {
        "index": 52,
        "start_line": 1413,
        "end_line": 1440,
        "code": "fn Stack(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        items: ArrayList(T),\n\n        pub fn init(allocator: Allocator) Self {\n            return Self{ .items = ArrayList(T).init(allocator) };\n        }\n\n        pub fn deinit(self: *Self) void {\n            self.items.deinit();\n        }\n\n        pub fn push(self: *Self, item: T) !void {\n            try self.items.append(item);\n        }\n\n        pub fn pop(self: *Self) ?T {\n            return if (self.items.items.len > 0)\n                self.items.pop()\n            else\n                null;\n        }\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 26,
        "chars": 605
      },
      {
        "index": 53,
        "start_line": 1444,
        "end_line": 1456,
        "code": "fn processStream(reader: anytype, writer: anytype) !void {\n    var buffer: [4096]u8 = undefined;\n\n    while (true) {\n        const n = try reader.read(&buffer);\n        if (n == 0) break;\n\n        const processed = processData(buffer[0..n]);\n        try writer.writeAll(processed);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 11,
        "chars": 289
      },
      {
        "index": 54,
        "start_line": 1460,
        "end_line": 1480,
        "code": "pub fn Iterator(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        items: []const T,\n        index: usize,\n\n        pub fn init(items: []const T) Self {\n            return Self{ .items = items, .index = 0 };\n        }\n\n        pub fn next(self: *Self) ?T {\n            if (self.index >= self.items.len) return null;\n            const item = self.items[self.index];\n            self.index += 1;\n            return item;\n        }\n    };\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 19,
        "chars": 470
      },
      {
        "index": 55,
        "start_line": 1484,
        "end_line": 1513,
        "code": "pub const ConfigBuilder = struct {\n    host: ?[]const u8 = null,\n    port: ?u16 = null,\n    timeout_ms: u32 = 5000,\n\n    pub fn setHost(self: *ConfigBuilder, host: []const u8) *ConfigBuilder {\n        self.host = host;\n        return self;\n    }\n\n    pub fn setPort(self: *ConfigBuilder, port: u16) *ConfigBuilder {\n        self.port = port;\n        return self;\n    }\n\n    pub fn setTimeout(self: *ConfigBuilder, timeout: u32) *ConfigBuilder {\n        self.timeout_ms = timeout;\n        return self;\n    }\n\n    pub fn build(self: ConfigBuilder) !Config {\n        return Config{\n            .host = self.host orelse return error.MissingHost,\n            .port = self.port orelse 8080,\n            .timeout_ms = self.timeout_ms,\n        };\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 28,
        "chars": 747
      },
      {
        "index": 56,
        "start_line": 1517,
        "end_line": 1531,
        "code": "fn findUser(users: []const User, id: u32) ?User {\n    for (users) |user| {\n        if (user.id == id) return user;\n    }\n    return null;\n}\n\n// Usage\nif (findUser(users, 123)) |user| {\n    std.debug.print(\"Found: {s}\\n\", .{user.name});\n} else {\n    std.debug.print(\"Not found\\n\", .{});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 13,
        "chars": 287
      },
      {
        "index": 57,
        "start_line": 1535,
        "end_line": 1554,
        "code": "const GlobalConfig = struct {\n    var instance: ?*GlobalConfig = null;\n    var mutex: std.Thread.Mutex = .{};\n\n    value: i32,\n\n    pub fn getInstance(allocator: Allocator) !*GlobalConfig {\n        mutex.lock();\n        defer mutex.unlock();\n\n        if (instance) |inst| return inst;\n\n        const inst = try allocator.create(GlobalConfig);\n        inst.* = GlobalConfig{ .value = 0 };\n        instance = inst;\n        return inst;\n    }\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 18,
        "chars": 442
      },
      {
        "index": 58,
        "start_line": 1562,
        "end_line": 1584,
        "code": "const std = @import(\"std\");\n\n// Copy memory\nstd.mem.copy(u8, dest, src);\n\n// Set memory\nstd.mem.set(u8, buffer, 0);\n\n// Compare\nconst equal = std.mem.eql(u8, a, b);\n\n// Find\nconst index = std.mem.indexOf(u8, haystack, needle);\n\n// Split\nvar iter = std.mem.split(u8, text, \",\");\nwhile (iter.next()) |part| { }\n\n// Tokenize (skip empty)\nvar iter = std.mem.tokenize(u8, text, \" \\t\\n\");\nwhile (iter.next()) |token| { }",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 21,
        "chars": 414
      },
      {
        "index": 59,
        "start_line": 1588,
        "end_line": 1606,
        "code": "// GeneralPurposeAllocator (production)\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\ndefer _ = gpa.deinit();\nconst allocator = gpa.allocator();\n\n// ArenaAllocator (batch free)\nvar arena = std.heap.ArenaAllocator.init(parent_allocator);\ndefer arena.deinit();\nconst allocator = arena.allocator();\n\n// FixedBufferAllocator (stack)\nvar buffer: [1024]u8 = undefined;\nvar fba = std.heap.FixedBufferAllocator.init(&buffer);\nconst allocator = fba.allocator();\n\n// c_allocator (C interop)\nconst allocator = std.heap.c_allocator;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 17,
        "chars": 525
      },
      {
        "index": 60,
        "start_line": 1610,
        "end_line": 1625,
        "code": "// Allocate slice\nconst slice = try allocator.alloc(u8, size);\ndefer allocator.free(slice);\n\n// Allocate single item\nconst ptr = try allocator.create(MyStruct);\ndefer allocator.destroy(ptr);\n\n// Duplicate slice\nconst copy = try allocator.dupe(u8, original);\ndefer allocator.free(copy);\n\n// Reallocate\nslice = try allocator.realloc(slice, new_size);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 14,
        "chars": 348
      },
      {
        "index": 61,
        "start_line": 1629,
        "end_line": 1650,
        "code": "var list = std.ArrayList(i32).init(allocator);\ndefer list.deinit();\n\n// Append\ntry list.append(42);\n\n// Extend\ntry list.appendSlice(&[_]i32{1, 2, 3});\n\n// Access\nconst item = list.items[0];\n\n// Pop\nconst last = list.pop();\n\n// Insert\ntry list.insert(index, value);\n\n// Remove\n_ = list.orderedRemove(index);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 20,
        "chars": 306
      },
      {
        "index": 62,
        "start_line": 1654,
        "end_line": 1677,
        "code": "var map = std.AutoHashMap([]const u8, i32).init(allocator);\ndefer map.deinit();\n\n// Put\ntry map.put(\"key\", 42);\n\n// Get\nif (map.get(\"key\")) |value| {\n    // Use value\n}\n\n// Contains\nconst exists = map.contains(\"key\");\n\n// Remove\n_ = map.remove(\"key\");\n\n// Iterate\nvar iter = map.iterator();\nwhile (iter.next()) |entry| {\n    std.debug.print(\"{s} = {}\\n\", .{entry.key_ptr.*, entry.value_ptr.*});\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 22,
        "chars": 396
      },
      {
        "index": 63,
        "start_line": 1681,
        "end_line": 1701,
        "code": "// Open file\nconst file = try std.fs.cwd().openFile(\"data.txt\", .{});\ndefer file.close();\n\n// Read all\nconst allocator = std.heap.page_allocator;\nconst content = try file.readToEndAlloc(allocator, 1024 * 1024);\ndefer allocator.free(content);\n\n// Write\nconst bytes_written = try file.write(\"Hello, World!\");\n\n// Create file\nconst new_file = try std.fs.cwd().createFile(\"output.txt\", .{});\ndefer new_file.close();\n\n// Directory operations\ntry std.fs.cwd().makeDir(\"new_dir\");\ntry std.fs.cwd().deleteFile(\"temp.txt\");",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 19,
        "chars": 514
      },
      {
        "index": 64,
        "start_line": 1705,
        "end_line": 1722,
        "code": "// Print to stderr\nstd.debug.print(\"Value: {}\\n\", .{42});\n\n// Format to buffer\nvar buffer: [100]u8 = undefined;\nconst result = try std.fmt.bufPrint(&buffer, \"x={d}, y={d}\", .{10, 20});\n\n// Allocate formatted string\nconst str = try std.fmt.allocPrint(allocator, \"Value: {}\", .{value});\ndefer allocator.free(str);\n\n// Parse integer\nconst num = try std.fmt.parseInt(i32, \"123\", 10);\n\n// Parse float\nconst val = try std.fmt.parseFloat(f64, \"3.14\");",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 16,
        "chars": 444
      },
      {
        "index": 65,
        "start_line": 1726,
        "end_line": 1736,
        "code": "// Parse JSON\nconst parsed = try std.json.parseFromSlice(MyStruct, allocator, json_text, .{});\ndefer parsed.deinit();\nconst data = parsed.value;\n\n// Stringify\nvar buffer = std.ArrayList(u8).init(allocator);\ndefer buffer.deinit();\ntry std.json.stringify(data, .{}, buffer.writer());",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 281
      },
      {
        "index": 66,
        "start_line": 1740,
        "end_line": 1749,
        "code": "// SHA256\nconst hash = std.crypto.hash.sha2.Sha256;\nvar digest: [hash.digest_length]u8 = undefined;\nhash.hash(data, &digest, .{});\n\n// Hex encode\nvar hex_buffer: [hash.digest_length * 2]u8 = undefined;\nconst hex = std.fmt.bytesToHex(&digest, .lower);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 8,
        "chars": 250
      },
      {
        "index": 67,
        "start_line": 1753,
        "end_line": 1765,
        "code": "// Unix timestamp (seconds)\nconst timestamp = std.time.timestamp();\n\n// Milliseconds\nconst ms = std.time.milliTimestamp();\n\n// Nanoseconds\nconst ns = std.time.nanoTimestamp();\n\n// Sleep\nstd.time.sleep(1 * std.time.ns_per_s); // Sleep 1 second",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 11,
        "chars": 242
      },
      {
        "index": 68,
        "start_line": 1769,
        "end_line": 1790,
        "code": "// Spawn thread\nconst thread = try std.Thread.spawn(.{}, workerFn, .{arg1, arg2});\n\n// Join (wait for completion)\nthread.join();\n\n// Detach (run independently)\nthread.detach();\n\n// Mutex\nvar mutex = std.Thread.Mutex{};\nmutex.lock();\ndefer mutex.unlock();\n// Critical section\n\n// RwLock\nvar rw_lock = std.Thread.RwLock{};\nrw_lock.lockShared();\ndefer rw_lock.unlockShared();\n// Read access",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 20,
        "chars": 387
      },
      {
        "index": 69,
        "start_line": 1798,
        "end_line": 1823,
        "code": "const std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Create executable\n    const exe = b.addExecutable(.{\n        .name = \"myapp\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Install artifact\n    b.installArtifact(exe);\n\n    // Run step\n    const run_cmd = b.addRunArtifact(exe);\n    run_cmd.step.dependOn(b.getInstallStep());\n\n    const run_step = b.step(\"run\", \"Run the application\");\n    run_step.dependOn(&run_cmd.step);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 24,
        "chars": 626
      },
      {
        "index": 70,
        "start_line": 1827,
        "end_line": 1840,
        "code": "// Define options\nconst options = b.addOptions();\noptions.addOption(bool, \"enable_logging\", true);\noptions.addOption([]const u8, \"version\", \"1.0.0\");\n\nexe.root_module.addOptions(\"config\", options);\n\n// Use in code\nconst config = @import(\"config\");\nif (config.enable_logging) {\n    // ...\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 289
      },
      {
        "index": 71,
        "start_line": 1844,
        "end_line": 1857,
        "code": "// build.zig.zon\n.{\n    .name = \"myproject\",\n    .version = \"0.1.0\",\n    .dependencies = .{\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/v0.5.0.tar.gz\",\n            .hash = \"1220abcd...\",\n        },\n    },\n    .paths = .{\"\"},\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 258
      },
      {
        "index": 72,
        "start_line": 1859,
        "end_line": 1867,
        "code": "// In build.zig\nconst zap = b.dependency(\"zap\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"zap\", zap.module(\"zap\"));",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 7,
        "chars": 156
      },
      {
        "index": 73,
        "start_line": 1871,
        "end_line": 1880,
        "code": "const tests = b.addTest(.{\n    .root_source_file = b.path(\"src/main.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\n\nconst test_step = b.step(\"test\", \"Run unit tests\");\ntest_step.dependOn(&b.addRunArtifact(tests).step);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 8,
        "chars": 230
      },
      {
        "index": 74,
        "start_line": 1884,
        "end_line": 1893,
        "code": "const lib = b.addStaticLibrary(.{\n    .name = \"mylib\",\n    .root_source_file = b.path(\"src/lib.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\n\nb.installArtifact(lib);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 8,
        "chars": 178
      },
      {
        "index": 75,
        "start_line": 1897,
        "end_line": 1905,
        "code": "exe.linkLibC();\nexe.addIncludePath(b.path(\"include\"));\nexe.addCSourceFile(.{\n    .file = b.path(\"src/wrapper.c\"),\n    .flags = &[_][]const u8{\"-std=c99\"},\n});\nexe.linkSystemLibrary(\"sqlite3\");",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 7,
        "chars": 192
      },
      {
        "index": 76,
        "start_line": 1913,
        "end_line": 1920,
        "code": "const testing = std.testing;\n\ntest \"basic test\" {\n    const result = 2 + 2;\n    try testing.expectEqual(@as(i32, 4), result);\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 6,
        "chars": 127
      },
      {
        "index": 77,
        "start_line": 1924,
        "end_line": 1938,
        "code": "// Equality\ntry testing.expectEqual(expected, actual);\ntry testing.expectEqualSlices(u8, expected_slice, actual_slice);\ntry testing.expectEqualStrings(\"hello\", result);\n\n// Boolean\ntry testing.expect(condition);\n\n// Approximation\ntry testing.expectApproxEqAbs(expected, actual, tolerance);\n\n// Error\ntry testing.expectError(error.Expected, errorUnion);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 13,
        "chars": 352
      },
      {
        "index": 78,
        "start_line": 1942,
        "end_line": 1951,
        "code": "test \"memory test\" {\n    const allocator = testing.allocator; // Detects leaks\n\n    const buffer = try allocator.alloc(u8, 100);\n    defer allocator.free(buffer); // Required or test fails\n\n    // Test logic\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 8,
        "chars": 209
      },
      {
        "index": 79,
        "start_line": 1955,
        "end_line": 1968,
        "code": "test \"table-driven\" {\n    const cases = [_]struct { input: i32, expected: i32 }{\n        .{ .input = 0, .expected = 0 },\n        .{ .input = 1, .expected = 1 },\n        .{ .input = 5, .expected = 25 },\n    };\n\n    for (cases) |case| {\n        const result = square(case.input);\n        try testing.expectEqual(case.expected, result);\n    }\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 12,
        "chars": 341
      },
      {
        "index": 80,
        "start_line": 1978,
        "end_line": 1984,
        "code": "// \u274c BAD: Easy to forget cleanup\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\n// ... many lines later ...\n_ = gpa.deinit(); // Easy to forget!",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 5,
        "chars": 183
      },
      {
        "index": 81,
        "start_line": 1988,
        "end_line": 1993,
        "code": "// \u2705 GOOD: defer right after acquisition\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\ndefer _ = gpa.deinit(); // Cleanup guaranteed\nconst allocator = gpa.allocator();",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 172
      },
      {
        "index": 82,
        "start_line": 1999,
        "end_line": 2002,
        "code": "// \u274c BAD: anyerror hides what can go wrong\npub fn loadConfig(path: []const u8) anyerror!Config { }",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 98
      },
      {
        "index": 83,
        "start_line": 2006,
        "end_line": 2011,
        "code": "// \u2705 GOOD: Explicit errors document failure modes\npub const LoadError = error{ FileNotFound, ParseError, OutOfMemory };\n\npub fn loadConfig(path: []const u8) LoadError!Config { }",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 177
      },
      {
        "index": 84,
        "start_line": 2017,
        "end_line": 2021,
        "code": "// \u274c BAD: Reading undefined buffer\nvar buffer: [100]u8 = undefined;\nstd.debug.print(\"{s}\\n\", .{buffer}); // Undefined behavior!",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 3,
        "chars": 127
      },
      {
        "index": 85,
        "start_line": 2025,
        "end_line": 2030,
        "code": "// \u2705 GOOD: Initialize before use\nvar buffer: [100]u8 = undefined;\nconst n = try file.read(&buffer);\nstd.debug.print(\"{s}\\n\", .{buffer[0..n]}); // Only read initialized bytes",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 173
      },
      {
        "index": 86,
        "start_line": 2036,
        "end_line": 2041,
        "code": "// \u274c BAD: In 0.15+, this doesn't compile (no stored allocator)\nvar list = std.ArrayList(i32).init(allocator);\n// ... later ...\ntry list.append(42); // ERROR: append needs allocator parameter",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 4,
        "chars": 190
      },
      {
        "index": 87,
        "start_line": 2045,
        "end_line": 2055,
        "code": "// \u2705 GOOD: Explicit unmanaged (0.15+ default)\nvar list = std.ArrayList(i32).init(allocator);\ndefer list.deinit();\ntry list.append(42);\n\n// \u2705 GOOD: Or use managed explicitly\nvar list = std.ArrayListManaged(i32).init(allocator);\ndefer list.deinit(allocator);\ntry list.append(allocator, 42);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 288
      },
      {
        "index": 88,
        "start_line": 2061,
        "end_line": 2064,
        "code": "// \u274c BAD: Unnecessary catch\nconst data = readFile(path) catch |err| return err;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 79
      },
      {
        "index": 89,
        "start_line": 2068,
        "end_line": 2071,
        "code": "// \u2705 GOOD: try propagates automatically\nconst data = try readFile(path);",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 72
      },
      {
        "index": 90,
        "start_line": 2077,
        "end_line": 2080,
        "code": "// \u274c BAD: Could panic if input is invalid\nconst value = parseInt(user_input) catch unreachable;",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 2,
        "chars": 95
      },
      {
        "index": 91,
        "start_line": 2084,
        "end_line": 2090,
        "code": "// \u2705 GOOD: Proper error handling\nconst value = parseInt(user_input) catch |err| {\n    std.log.err(\"Invalid input: {}\", .{err});\n    return error.InvalidInput;\n};",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 5,
        "chars": 161
      },
      {
        "index": 92,
        "start_line": 2096,
        "end_line": 2102,
        "code": "// \u274c BAD: Returning pointer to stack memory\nfn getName() []const u8 {\n    const name = \"Alice\";\n    return name; // Dangling pointer!\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 5,
        "chars": 135
      },
      {
        "index": 93,
        "start_line": 2106,
        "end_line": 2116,
        "code": "// \u2705 GOOD: String literal (static storage)\nfn getName() []const u8 {\n    return \"Alice\";\n}\n\n// \u2705 GOOD: Heap-allocated (caller frees)\nfn getName(allocator: Allocator) ![]u8 {\n    return allocator.dupe(u8, \"Alice\");\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 9,
        "chars": 215
      },
      {
        "index": 94,
        "start_line": 2122,
        "end_line": 2129,
        "code": "// \u274c BAD: Leaks not detected\ntest \"leak not caught\" {\n    const allocator = std.heap.page_allocator;\n    const buf = try allocator.alloc(u8, 100);\n    // Forgot defer! But test passes.\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 6,
        "chars": 186
      },
      {
        "index": 95,
        "start_line": 2133,
        "end_line": 2140,
        "code": "// \u2705 GOOD: Leak causes test failure\ntest \"leak detected\" {\n    const allocator = testing.allocator;\n    const buf = try allocator.alloc(u8, 100);\n    defer allocator.free(buf); // Required or test fails\n}",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 6,
        "chars": 204
      },
      {
        "index": 96,
        "start_line": 2225,
        "end_line": 2233,
        "code": "// 0.14 code\nvar list = std.ArrayList(i32).init(allocator);\ntry list.append(42); // Works\n\n// 0.15 code (same API works)\nvar list = std.ArrayList(i32).init(allocator);\ntry list.append(42); // Still works",
        "file": "/home/jack/workspace/zig_guide/sections/15_appendices/content.md",
        "lines": 7,
        "chars": 203
      }
    ]
  }
]