╔════════════════════════════════════════════════════════════════╗
║        Zig Guide: Redundancy Detection Report                 ║
╚════════════════════════════════════════════════════════════════╝

Date: 2025-11-10

## Allocator Re-introductions (Primary: 02_memory_allocators)

⚠️  03_collections_containers: 10 mentions
    5:Zig's standard library provides dynamic collection types that integrate with the explicit allocator model covered in Chapter 3. This chapter examines container types including ArrayList, HashMap, and their variants, focusing on the distinction between managed and unmanaged containers, ownership semantics, and cleanup responsibilities.
    9:As of Zig 0.15, the standard library has shifted toward unmanaged containers as the default pattern.[^1] This change reflects a broader philosophy: explicit allocator parameters make allocation sites visible, reduce per-container memory overhead, and enable better composition of container-heavy data structures.
    17:**Managed containers** store an allocator as a struct field. Methods use this stored allocator implicitly. Prior to Zig 0.15, `std.ArrayList(T)` defaulted to this managed variant. The managed pattern provides a simpler API at the cost of increased memory usage per container instance.

   Subtotal: 10 redundant mentions

## Defer/Errdefer Re-introductions (Primary: 05_error_handling)

⚠️  01_language_idioms: 6 mentions
    12:- **defer and errdefer** provide deterministic resource cleanup
    86:Zig's `defer` executes code when leaving the current scope (via return, break, or block end). `errdefer` executes only when leaving via error return.[^5]
    94:    defer std.debug.print("3. Third (executed first)\n", .{});

⚠️  02_memory_allocators: 10 mentions
    167:Zig's `defer` and `errdefer` keywords provide deterministic cleanup without runtime overhead.
    169:**defer** executes cleanup code when leaving scope, regardless of how the scope exits (return, break, or fall-through). Defer statements execute in LIFO order. Best practice: place `defer` immediately after allocation.
    173:defer allocator.free(data); // Executes when scope exits

⚠️  04_io_streams: 7 mentions
    74:    defer file.close();  // Always close on scope exit
    201:Proper resource cleanup is critical for I/O operations. Zig provides `defer` and `errdefer` for deterministic cleanup:
    206:    defer file.close();  // Executed when scope exits (success or error)

⚠️  10_interoperability: 6 mentions
    11:Memory safety at language boundaries demands explicit attention. When Zig code calls C functions or vice versa, responsibility for allocation, deallocation, and lifetime management must be clearly defined. The defer mechanism provides scope-based resource cleanup that prevents leaks when crossing language boundaries. However, mixing allocators between Zig and C, or mismatching C types with Zig types, introduces subtle bugs that only surface on specific platforms or under certain conditions.
    1238:    // C memory allocation with defer cleanup
    1255:- defer for automatic cleanup

⚠️  11_testing_benchmarking: 6 mentions
    1612:- `errdefer` for cleanup on error paths
    1911:    defer list.deinit();  // Always defer cleanup
    1918:**Pattern:** Always pair allocation with `defer` cleanup immediately after initialization.

   Subtotal: 35 redundant mentions

## Error Unions Re-introductions (Primary: 05_error_handling)

   Subtotal: 0 redundant mentions

## Philosophical Introductions (Lines Before First Code)

⚠️  14_appendices: 541 lines before first code example (target: <75)

   Estimated excess intro lines: 466

## Verbose Comparisons (Table Candidates)


═══════════════════════════════════════════════════════════════
End of Redundancy Report
═══════════════════════════════════════════════════════════════
